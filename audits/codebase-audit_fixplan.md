# Fix Plan — Codebase Audit

**Source Audit:** `audits/codebase-audit.md`  
**Generated by:** /audit-review  
**Date:** 2025-01-27

---

## Summary

- **Critical:** 3 (2 SAFE_AUTO, 1 NEEDS_DECISION)
- **High:** 2 (1 SAFE_AUTO, 1 NEEDS_CONTEXT)
- **Medium:** 6 (all NEEDS_CONTEXT)
- **Low:** 1 (1 SAFE_AUTO)
- **Rejected issues:** 1 (performance memoization already implemented)

---

## Step 1 — Critical SAFE_AUTO

### [CRIT-01][SAFE_AUTO] — Empty Service File (Dead Code)

**Severity:** Critical  
**Review Status:** CONFIRMED  
**Files:** `services/parsingService.ts`

**What's wrong (confirmed):**  
The file `services/parsingService.ts` is completely empty. This is dead code that serves no purpose and creates confusion about the codebase structure.

**How to fix (clarified):**

1. Delete the file `services/parsingService.ts` entirely.
2. Verify no imports reference this file (search for `parsingService` imports).
3. If any imports are found, remove them.

**Impact:**  
Removes dead code, reduces confusion, and keeps the codebase clean. Prevents future developers from wondering if this file was meant to contain something important.

---

### [CRIT-02][SAFE_AUTO] — No Error Boundaries in React Application

**Severity:** Critical  
**Review Status:** CONFIRMED  
**Files:** `App.tsx`, `index.tsx`, create `components/ErrorBoundary.tsx`

**What's wrong (confirmed):**  
If any React component throws an error during rendering, the entire application will crash and show a blank white screen to the user. There's no error boundary to catch these errors and display a helpful message.

**How to fix (clarified):**

1. Create a new file `components/ErrorBoundary.tsx` that implements a React Error Boundary class component.
2. The ErrorBoundary should catch errors in its `componentDidCatch` lifecycle method.
3. Display a user-friendly error message with an option to reload the page.
4. Wrap the main app content in `App.tsx` with the ErrorBoundary component (around the `renderTab()` content).
5. Optionally, wrap the entire app in `index.tsx` as a fallback.

**Impact:**  
Prevents complete application crashes. Users will see a helpful error message instead of a blank screen, and can potentially recover without losing their data.

---

### [CRIT-03][SAFE_AUTO] — Fix MarketCategory Type Safety

**Severity:** Critical  
**Review Status:** CONFIRMED  
**Files:** `types.ts`, update all usages

**What's wrong (confirmed):**  
The `MarketCategory` type is defined as `string` in `types.ts` (line 4), but the code expects specific values like "Props", "Main Markets", "Futures", etc. This means TypeScript won't catch errors if someone passes an invalid category string.

**How to fix (clarified):**

1. In `types.ts`, change `export type MarketCategory = string;` to a union type using the values from `constants.ts`: `export type MarketCategory = "Props" | "Main Markets" | "Futures" | "SGP/SGP+" | "Parlays";`
2. Check all files that use `MarketCategory` to ensure they're compatible with the union type.
3. Update any string literals that don't match the union type.
4. Run TypeScript compiler to catch any type errors.

**Impact:**  
Prevents runtime errors from invalid category values. Makes the code more type-safe and self-documenting.

---

## Step 2 — Remaining Critical and High (including NEEDS_CONTEXT)

### [CRIT-04][NEEDS_DECISION] — DraftKings Parser is Placeholder Only

**Severity:** Critical  
**Review Status:** CONFIRMED  
**Files:** `parsers/draftkings.ts`, `views/ImportView.tsx`

**What's wrong (confirmed):**  
The DraftKings parser doesn't actually parse HTML. It just returns two hardcoded example bets. This means users cannot import real DraftKings bets - the parser will always return the same two fake bets regardless of what HTML is pasted.

**How to fix (clarified):**  
**DECISION REQUIRED:** Choose one of the following approaches:

**Option A: Implement Real Parser**

1. Study the FanDuel parser (`parsing/parsers/fanduel.ts`) as a reference.
2. Analyze DraftKings HTML structure from bet history pages.
3. Implement HTML parsing logic similar to FanDuel parser.
4. Extract real bet data (betId, placedAt, settledAt, odds, stake, payout, result, legs).
5. Test with real DraftKings HTML samples.

**Option B: Disable DraftKings Option**

1. Remove or disable DraftKings from the sportsbook selector in `ImportView.tsx`.
2. Add a clear message in the UI explaining that DraftKings parsing is not yet available.
3. Update the parser to throw a clear error if DraftKings is selected.
4. Document this limitation in the UI.

**Impact:**  
Currently, users trying to import DraftKings bets will get incorrect data. This is a critical functionality gap that makes the application partially broken for DraftKings users.

---

### [HIGH-01][NEEDS_CONTEXT] — localStorage Error Handling is Silent

**Severity:** High  
**Review Status:** CONFIRMED  
**Files:** `hooks/useBets.tsx` (lines 143-147, 154-156), `hooks/useInputs.tsx` (lines 47-50, 59-61)

**What's wrong (confirmed):**  
When localStorage operations fail (which can happen if the browser's storage is full, disabled, or corrupted), the code just logs to the console and continues silently. Users won't know their data isn't being saved, and the app might appear to work normally while losing all their bets.

**How to fix (clarified):**

1. Create a user-visible error notification system (banner, toast, or modal component).
2. In `useBets.tsx`, wrap localStorage operations in try-catch blocks.
3. When localStorage.setItem fails, show a warning banner/modal that explains the issue.
4. Suggest solutions: clear browser storage, check browser settings, export data as backup.
5. In `useInputs.tsx`, apply the same error handling pattern.
6. Consider implementing a fallback storage mechanism or at least warning users that data might not persist.
7. Optionally, add a periodic check to verify localStorage is working.

**Impact:**  
Prevents silent data loss. Users will be alerted if their data can't be saved, allowing them to take corrective action before losing information.

---

### [MED-01][NEEDS_CONTEXT] — Complex Migration Logic in useBets Hook

**Severity:** Medium  
**Review Status:** CONFIRMED  
**Files:** `hooks/useBets.tsx` (lines 99-130), create `utils/migrations.ts`

**What's wrong (confirmed):**  
The migration logic that converts old bet formats to new formats is embedded directly in the `useBets` hook's `useEffect`. This makes the hook harder to understand and test. The migration logic is doing multiple things: checking for sample data, migrating leg structures, backfilling `isLive`, and retroactively classifying bets.

**How to fix (clarified):**

1. Create a new file `utils/migrations.ts`.
2. Extract the migration logic from `useBets.tsx` into a pure function `migrateBets(bets: Bet[]): Bet[]`.
3. Move the sample data detection logic to a separate function `isSampleData(bets: Bet[]): boolean`.
4. Move the bet migration logic (legs array creation, isLive backfill, classification) to the `migrateBets` function.
5. Update `useBets.tsx` to import and call `migrateBets()` instead of having the logic inline.
6. This makes the code easier to test, understand, and maintain.

**Impact:**  
Improves code maintainability and testability. Makes it easier to add new migrations in the future and ensures migration logic can be tested independently.

---

### [MED-02][NEEDS_CONTEXT] — Race Condition in Bet Calculations

**Severity:** Medium  
**Review Status:** CONFIRMED  
**Files:** `hooks/useBets.tsx` (lines 24-32, 34-51), `views/BetTableView.tsx` (lines 54-62), create `utils/betCalculations.ts`

**What's wrong (confirmed):**  
The payout calculation happens in two places with slightly different logic. In `useBets.tsx`, `recalculatePayout()` and `calculateProfit()` are defined. In `BetTableView.tsx`, there's a separate `calculateProfit()` function. If these get out of sync, the displayed values won't match the stored values.

**How to fix (clarified):**

1. Create a new file `utils/betCalculations.ts`.
2. Move the `calculateProfit()` function from `useBets.tsx` to the new file.
3. Move the `recalculatePayout()` function from `useBets.tsx` to the new file.
4. Remove the duplicate `calculateProfit()` from `BetTableView.tsx`.
5. Update both `useBets.tsx` and `BetTableView.tsx` to import these functions from `utils/betCalculations.ts`.
6. Ensure both files use the exact same calculation logic.
7. Add unit tests for the calculation functions.

**Impact:**  
Prevents calculation inconsistencies and ensures the displayed values always match the stored values. Makes it easier to fix calculation bugs in one place.

---

### [MED-03][NEEDS_CONTEXT] — No Input Validation for Bet Updates

**Severity:** Medium  
**Review Status:** CONFIRMED  
**Files:** `hooks/useBets.tsx` (lines 271-302), `views/BetTableView.tsx` (editing logic), create `utils/validation.ts`

**What's wrong (confirmed):**  
When users edit bets in the table, there's no validation that the values make sense. For example, a user could enter a negative stake, odds of 0, or an invalid date. The app will save these invalid values, which could break calculations or display.

**How to fix (clarified):**

1. Create a new file `utils/validation.ts`.
2. Create a `validateBet(bet: Partial<Bet>): { valid: boolean; errors: string[] }` function.
3. Validate that:
   - Stake is positive and a valid number
   - Odds are reasonable (e.g., between -10000 and +10000) and not zero
   - Dates are valid ISO strings
   - Results are one of the allowed values ('win', 'loss', 'push', 'pending')
4. In `useBets.tsx` `updateBet()` function, call the validation function before saving.
5. In `BetTableView.tsx`, show error messages to users when validation fails (e.g., inline error text or toast notification).
6. Prevent saving invalid data.

**Impact:**  
Prevents data corruption and calculation errors. Ensures the data remains consistent and the application behaves predictably.

---

### [MED-04][NEEDS_CONTEXT] — Hardcoded Sample Bet IDs for Migration

**Severity:** Medium  
**Review Status:** CONFIRMED  
**Files:** `hooks/useBets.tsx` (lines 67-87)

**What's wrong (confirmed):**  
The code checks for sample data by comparing bet IDs against a hardcoded list of 19 specific sample bet IDs. If new sample data is added with different IDs, or if a user happens to have a bet with one of these IDs, the detection will fail or incorrectly trigger.

**How to fix (clarified):**

1. Choose a more robust detection method. Options:
   - Add an `isSample: true` flag to sample bets when they're created
   - Use a specific prefix pattern for sample bet IDs (e.g., all start with "SAMPLE-")
   - Store sample data in a separate localStorage key (e.g., `bettracker-sample-bets`)
2. Update the sample data creation logic (wherever sample bets are generated) to use the chosen method.
3. Update the detection logic in `useBets.tsx` to use the new method instead of hardcoded IDs.
4. If using a flag, add it to the `Bet` type in `types.ts`.

**Impact:**  
Makes sample data detection more reliable and prevents false positives/negatives. Ensures the migration logic works correctly even as the codebase evolves.

---

### [MED-05][NEEDS_CONTEXT] — Inconsistent Category Normalization

**Severity:** Medium  
**Review Status:** CONFIRMED  
**Files:** `parsing/betToFinalRows.ts` (lines 211-221)

**What's wrong (confirmed):**  
The `normalizeCategory()` function converts category names inconsistently. "Main Markets" becomes "Main", but "Props" stays "Props", and "SGP/SGP+" or "Parlays" become "Props". This creates confusion about what the actual category should be.

**How to fix (clarified):**

1. Review the `normalizeCategory()` function in `betToFinalRows.ts`.
2. Decide on a consistent normalization strategy:
   - Option A: Keep original category names (no normalization)
   - Option B: Normalize all to match the constants in `constants.ts` exactly
3. Update the function to apply the chosen strategy consistently.
4. Ensure the normalization is predictable and reversible (or at least well-documented).
5. Consider using the constants from `constants.ts` as the source of truth.

**Impact:**  
Prevents category confusion and ensures data consistency. Makes it easier to filter and group bets by category.

---

### [MED-06][NEEDS_CONTEXT] — Missing Error Handling in Parser

**Severity:** Medium  
**Review Status:** CONFIRMED  
**Files:** `parsing/pageProcessor.ts` (lines 41-44), `parsing/parsers/fanduel.ts` (error handling), `views/ImportView.tsx`

**What's wrong (confirmed):**  
When parsing fails, the code catches the error and returns an empty array, but only logs to the console. Users won't know why their import failed - they'll just see "0 bets found" with no explanation.

**How to fix (clarified):**

1. Modify parser functions to return more detailed error information. Options:
   - Return a `Result<Bet[], string>` type with success/error
   - Throw custom error types with descriptive messages
   - Return an object like `{ bets: Bet[], error?: string }`
2. Update `pageProcessor.ts` to capture and propagate error messages.
3. Update `ImportView.tsx` to display user-friendly error messages when parsing fails.
4. Show specific messages like "Could not find any bets in the HTML. Make sure you copied the full page source." or "Invalid HTML format for [Sportsbook]."

**Impact:**  
Improves user experience by providing actionable feedback when imports fail. Helps users troubleshoot issues instead of being left confused.

---

## Step 3 — Medium and Low

### [LOW-01][SAFE_AUTO] — Magic Numbers in Calculations

**Severity:** Low  
**Review Status:** CONFIRMED  
**Files:** `hooks/useBets.tsx` (lines 26-30), `views/BetTableView.tsx` (lines 54-62), create `utils/betCalculations.ts` (or add to existing if created in MED-02)

**What's wrong (confirmed):**  
The profit calculation uses the magic number `100` to convert American odds to decimal. This number appears in multiple places and isn't documented. If the calculation logic needs to change, it would need to be updated in multiple places.

**How to fix (clarified):**

1. If `utils/betCalculations.ts` was created in MED-02, add constants there. Otherwise, create the file.
2. Define a named constant: `const AMERICAN_ODDS_DIVISOR = 100;`
3. Create well-documented utility functions:
   - `americanOddsToDecimal(odds: number): number`
   - `calculateProfitFromAmericanOdds(stake: number, odds: number): number`
4. Replace all instances of the magic number `100` in odds calculations with the constant or function calls.
5. Update both `useBets.tsx` and `BetTableView.tsx` to use these utilities.

**Impact:**  
Makes the code more maintainable and self-documenting. Reduces the chance of calculation errors when modifying the code.

---

## Items Requiring Human Decision

### [CRIT-04] — DraftKings Parser Implementation Strategy

**Issue:** The DraftKings parser currently returns hardcoded example bets instead of parsing real HTML.

**Decision Required:**  
Choose one approach:

1. **Implement Real Parser** - Build a full HTML parser similar to the FanDuel parser. This requires:

   - Analysis of DraftKings HTML structure
   - Development time to implement parsing logic
   - Testing with real DraftKings HTML samples

2. **Disable DraftKings Option** - Remove DraftKings from the sportsbook selector and document the limitation. This is faster but reduces functionality.

**Recommendation:**  
If DraftKings support is important to users, implement the real parser. If it's not a priority, disable it with clear messaging until it can be properly implemented.

---

## Additional Notes

- The performance memoization issue mentioned in the audit is already addressed - `flattenedBets` in `BetTableView.tsx` already uses `useMemo` (line 534). This issue has been rejected as already fixed.
- Several issues (MED-02, LOW-01) can be addressed together when creating the `utils/betCalculations.ts` file.
- The migration logic extraction (MED-01) should be done carefully to preserve existing behavior.
