<repomix><file_summary>This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where content has been formatted for parsing in xml style.<purpose>This file contains a packed representation of the entire repository&apos;s contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.</purpose><file_format>The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file</file_format><usage_guidelines>- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.</usage_guidelines><notes>- Some files may have been excluded based on .gitignore rules and Repomix&apos;s configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching default ignore patterns are excluded
- Content has been formatted for parsing in xml style
- Files are sorted by Git change count (files with more changes are at the bottom)</notes></file_summary><directory_structure>.repomix/
  bundles.json
components/
  icons.tsx
data/
  sampleData.ts
hooks/
  useBets.tsx
  useInputs.tsx
parsers/
  draftkings.ts
  fanduel.ts
parsing/
  parsers/
    draftkings.ts
    fanduel.ts
  pageProcessor.ts
services/
  classificationService.ts
  csvParser.ts
  errors.ts
  importer.ts
  pageSourceProvider.ts
  parsingService.ts
views/
  BetTableView.tsx
  BySportView.tsx
  DashboardView.tsx
  ImportView.tsx
  InputManagementView.tsx
  PlayerProfileView.tsx
  SettingsView.tsx
  SportsbookBreakdownView.tsx
.env.local
.gitignore
App.tsx
constants.ts
index.html
index.tsx
metadata.json
package.json
README.md
tsconfig.json
types.ts
vite.config.ts</directory_structure><files>This section contains the contents of the repository&apos;s files.<file path=".repomix/bundles.json">{
  &quot;bundles&quot;: {
    &quot;bettracker-662&quot;: {
      &quot;name&quot;: &quot;bettracker&quot;,
      &quot;created&quot;: &quot;2025-11-17T03:29:35.453Z&quot;,
      &quot;lastUsed&quot;: &quot;2025-11-17T03:29:35.453Z&quot;,
      &quot;tags&quot;: [],
      &quot;files&quot;: []
    },
    &quot;bettracker1-368&quot;: {
      &quot;name&quot;: &quot;bettracker1&quot;,
      &quot;created&quot;: &quot;2025-11-17T03:30:40.744Z&quot;,
      &quot;lastUsed&quot;: &quot;2025-11-17T03:30:40.744Z&quot;,
      &quot;tags&quot;: [],
      &quot;files&quot;: []
    }
  }
}</file><file path="components/icons.tsx">import React from &apos;react&apos;;

// Using lucide-react style for icons
type IconProps = React.SVGProps&lt;SVGSVGElement&gt;;

export const DownloadCloud = (props: IconProps) =&gt; (
  &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;24&quot; height=&quot;24&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;none&quot; stroke=&quot;currentColor&quot; strokeWidth=&quot;2&quot; strokeLinecap=&quot;round&quot; strokeLinejoin=&quot;round&quot; {...props}&gt;
    &lt;path d=&quot;M4 14.899A7 7 0 1 1 15.71 8h1.79a4.5 4.5 0 0 1 2.5 8.242&quot; /&gt;
    &lt;path d=&quot;M12 12v9&quot; /&gt;
    &lt;path d=&quot;m8 17 4 4 4-4&quot; /&gt;
  &lt;/svg&gt;
);

export const BarChart2 = (props: IconProps) =&gt; (
  &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;24&quot; height=&quot;24&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;none&quot; stroke=&quot;currentColor&quot; strokeWidth=&quot;2&quot; strokeLinecap=&quot;round&quot; strokeLinejoin=&quot;round&quot; {...props}&gt;
    &lt;line x1=&quot;18&quot; x2=&quot;18&quot; y1=&quot;20&quot; y2=&quot;10&quot; /&gt;
    &lt;line x1=&quot;12&quot; x2=&quot;12&quot; y1=&quot;20&quot; y2=&quot;4&quot; /&gt;
    &lt;line x1=&quot;6&quot; x2=&quot;6&quot; y1=&quot;20&quot; y2=&quot;14&quot; /&gt;
  &lt;/svg&gt;
);

export const Settings = (props: IconProps) =&gt; (
  &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;24&quot; height=&quot;24&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;none&quot; stroke=&quot;currentColor&quot; strokeWidth=&quot;2&quot; strokeLinecap=&quot;round&quot; strokeLinejoin=&quot;round&quot; {...props}&gt;
    &lt;path d=&quot;M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 0 2.4l-.15.08a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.38a2 2 0 0 0-.73-2.73l-.15-.1a2 2 0 0 1 0 2.4l.15-.08a2 2 0 0 0 .73-2.73l.22.38a2 2 0 0 0-2.73.73l.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z&quot; /&gt;
    &lt;circle cx=&quot;12&quot; cy=&quot;12&quot; r=&quot;3&quot; /&gt;
  &lt;/svg&gt;
);

export const Table = (props: IconProps) =&gt; (
  &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;24&quot; height=&quot;24&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;none&quot; stroke=&quot;currentColor&quot; strokeWidth=&quot;2&quot; strokeLinecap=&quot;round&quot; strokeLinejoin=&quot;round&quot; {...props}&gt;
    &lt;path d=&quot;M12 3v18&quot; /&gt;
    &lt;rect width=&quot;18&quot; height=&quot;18&quot; x=&quot;3&quot; y=&quot;3&quot; rx=&quot;2&quot; /&gt;
    &lt;path d=&quot;M3 9h18&quot; /&gt;
    &lt;path d=&quot;M3 15h18&quot; /&gt;
  &lt;/svg&gt;
);

export const Sun = (props: IconProps) =&gt; (
  &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;24&quot; height=&quot;24&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;none&quot; stroke=&quot;currentColor&quot; strokeWidth=&quot;2&quot; strokeLinecap=&quot;round&quot; strokeLinejoin=&quot;round&quot; {...props}&gt;
    &lt;circle cx=&quot;12&quot; cy=&quot;12&quot; r=&quot;4&quot; /&gt;
    &lt;path d=&quot;M12 2v2&quot; /&gt;
    &lt;path d=&quot;M12 20v2&quot; /&gt;
    &lt;path d=&quot;m4.93 4.93 1.41 1.41&quot; /&gt;
    &lt;path d=&quot;m17.66 17.66 1.41 1.41&quot; /&gt;
    &lt;path d=&quot;M2 12h2&quot; /&gt;
    &lt;path d=&quot;M20 12h2&quot; /&gt;
    &lt;path d=&quot;m6.34 17.66-1.41 1.41&quot; /&gt;
    &lt;path d=&quot;m19.07 4.93-1.41 1.41&quot; /&gt;
  &lt;/svg&gt;
);

export const Moon = (props: IconProps) =&gt; (
  &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;24&quot; height=&quot;24&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;none&quot; stroke=&quot;currentColor&quot; strokeWidth=&quot;2&quot; strokeLinecap=&quot;round&quot; strokeLinejoin=&quot;round&quot; {...props}&gt;
    &lt;path d=&quot;M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z&quot; /&gt;
  &lt;/svg&gt;
);

export const AlertTriangle = (props: IconProps) =&gt; (
  &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;24&quot; height=&quot;24&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;none&quot; stroke=&quot;currentColor&quot; strokeWidth=&quot;2&quot; strokeLinecap=&quot;round&quot; strokeLinejoin=&quot;round&quot; {...props}&gt;
    &lt;path d=&quot;m21.73 18-8-14a2 2 0 0 0-3.46 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z&quot; /&gt;
    &lt;path d=&quot;M12 9v4&quot; /&gt;
    &lt;path d=&quot;M12 17h.01&quot; /&gt;
  &lt;/svg&gt;
);

export const CheckCircle2 = (props: IconProps) =&gt; (
    &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;24&quot; height=&quot;24&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;none&quot; stroke=&quot;currentColor&quot; strokeWidth=&quot;2&quot; strokeLinecap=&quot;round&quot; strokeLinejoin=&quot;round&quot; {...props}&gt;
        &lt;path d=&quot;M12 22c5.523 0 10-4.477 10-10S17.523 2 12 2 2 6.477 2 12s4.477 10 10 10z&quot;/&gt;
        &lt;path d=&quot;m9 12 2 2 4-4&quot;/&gt;
    &lt;/svg&gt;
);

export const ExternalLink = (props: IconProps) =&gt; (
  &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;24&quot; height=&quot;24&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;none&quot; stroke=&quot;currentColor&quot; strokeWidth=&quot;2&quot; strokeLinecap=&quot;round&quot; strokeLinejoin=&quot;round&quot; {...props}&gt;
    &lt;path d=&quot;M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6&quot; /&gt;
    &lt;polyline points=&quot;15 3 21 3 21 9&quot; /&gt;
    &lt;line x1=&quot;10&quot; y1=&quot;14&quot; x2=&quot;21&quot; y2=&quot;3&quot; /&gt;
  &lt;/svg&gt;
);

export const TrendingUp = (props: IconProps) =&gt; (
  &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;24&quot; height=&quot;24&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;none&quot; stroke=&quot;currentColor&quot; strokeWidth=&quot;2&quot; strokeLinecap=&quot;round&quot; strokeLinejoin=&quot;round&quot; {...props}&gt;
    &lt;polyline points=&quot;22 7 13.5 15.5 8.5 10.5 2 17&quot; /&gt;
    &lt;polyline points=&quot;16 7 22 7 22 13&quot; /&gt;
  &lt;/svg&gt;
);

export const TrendingDown = (props: IconProps) =&gt; (
  &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;24&quot; height=&quot;24&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;none&quot; stroke=&quot;currentColor&quot; strokeWidth=&quot;2&quot; strokeLinecap=&quot;round&quot; strokeLinejoin=&quot;round&quot; {...props}&gt;
    &lt;polyline points=&quot;22 17 13.5 8.5 8.5 13.5 2 7&quot; /&gt;
    &lt;polyline points=&quot;16 17 22 17 22 11&quot; /&gt;
  &lt;/svg&gt;
);

export const Scale = (props: IconProps) =&gt; (
  &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;24&quot; height=&quot;24&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;none&quot; stroke=&quot;currentColor&quot; strokeWidth=&quot;2&quot; strokeLinecap=&quot;round&quot; strokeLinejoin=&quot;round&quot; {...props}&gt;
    &lt;path d=&quot;m16 16 3-8 3 8c-.87.65-1.92 1-3 1s-2.13-.35-3-1Z&quot; /&gt;
    &lt;path d=&quot;m2 16 3-8 3 8c-.87.65-1.92 1-3 1s-2.13-.35-3-1Z&quot; /&gt;
    &lt;path d=&quot;M7 21h10&quot; /&gt;
    &lt;path d=&quot;M12 3v18&quot; /&gt;
    &lt;path d=&quot;M3 7h2c2 0 5-1 7-2 2 1 5 2 7 2h2&quot; /&gt;
  &lt;/svg&gt;
);

export const User = (props: IconProps) =&gt; (
  &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;24&quot; height=&quot;24&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;none&quot; stroke=&quot;currentColor&quot; strokeWidth=&quot;2&quot; strokeLinecap=&quot;round&quot; strokeLinejoin=&quot;round&quot; {...props}&gt;
    &lt;path d=&quot;M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2&quot; /&gt;
    &lt;circle cx=&quot;12&quot; cy=&quot;7&quot; r=&quot;4&quot; /&gt;
  &lt;/svg&gt;
);

export const Trophy = (props: IconProps) =&gt; (
  &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;24&quot; height=&quot;24&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;none&quot; stroke=&quot;currentColor&quot; strokeWidth=&quot;2&quot; strokeLinecap=&quot;round&quot; strokeLinejoin=&quot;round&quot; {...props}&gt;
    &lt;path d=&quot;M6 9H4.5a2.5 2.5 0 0 1 0-5H6&quot; /&gt;
    &lt;path d=&quot;M18 9h1.5a2.5 2.5 0 0 0 0-5H18&quot; /&gt;
    &lt;path d=&quot;M4 22h16&quot; /&gt;
    &lt;path d=&quot;M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22&quot; /&gt;
    &lt;path d=&quot;M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22&quot; /&gt;
    &lt;path d=&quot;M18 2H6v7a6 6 0 0 0 12 0V2Z&quot; /&gt;
  &lt;/svg&gt;
);

export const Wifi = (props: IconProps &amp; { title?: string }) =&gt; {
  const { title, ...rest } = props;
  return (
    &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;24&quot; height=&quot;24&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;none&quot; stroke=&quot;currentColor&quot; strokeWidth=&quot;2&quot; strokeLinecap=&quot;round&quot; strokeLinejoin=&quot;round&quot; {...rest}&gt;
      {title &amp;&amp; &lt;title&gt;{title}&lt;/title&gt;}
      &lt;path d=&quot;M5 12.55a11 11 0 0 1 14.08 0&quot; /&gt;
      &lt;path d=&quot;M1.42 9a16 16 0 0 1 21.16 0&quot; /&gt;
      &lt;path d=&quot;M8.53 16.11a6 6 0 0 1 6.95 0&quot; /&gt;
      &lt;line x1=&quot;12&quot; x2=&quot;12.01&quot; y1=&quot;20&quot; y2=&quot;20&quot; /&gt;
    &lt;/svg&gt;
  );
};

export const Trash2 = (props: IconProps) =&gt; (
    &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;24&quot; height=&quot;24&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;none&quot; stroke=&quot;currentColor&quot; strokeWidth=&quot;2&quot; strokeLinecap=&quot;round&quot; strokeLinejoin=&quot;round&quot; {...props}&gt;
        &lt;path d=&quot;M3 6h18&quot; /&gt;
        &lt;path d=&quot;M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2&quot; /&gt;
        &lt;line x1=&quot;10&quot; x2=&quot;10&quot; y1=&quot;11&quot; y2=&quot;17&quot; /&gt;
        &lt;line x1=&quot;14&quot; x2=&quot;14&quot; y1=&quot;11&quot; y2=&quot;17&quot; /&gt;
    &lt;/svg&gt;
);

export const ClipboardList = (props: IconProps) =&gt; (
  &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;24&quot; height=&quot;24&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;none&quot; stroke=&quot;currentColor&quot; strokeWidth=&quot;2&quot; strokeLinecap=&quot;round&quot; strokeLinejoin=&quot;round&quot; {...props}&gt;
    &lt;rect width=&quot;8&quot; height=&quot;4&quot; x=&quot;8&quot; y=&quot;2&quot; rx=&quot;1&quot; ry=&quot;1&quot; /&gt;
    &lt;path d=&quot;M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2&quot; /&gt;
    &lt;path d=&quot;m9 14 2 2 4-4&quot; /&gt;
  &lt;/svg&gt;
);

export const ChevronDown = (props: IconProps) =&gt; (
    &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;24&quot; height=&quot;24&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;none&quot; stroke=&quot;currentColor&quot; strokeWidth=&quot;2&quot; strokeLinecap=&quot;round&quot; strokeLinejoin=&quot;round&quot; {...props}&gt;
        &lt;path d=&quot;m6 9 6 6 6-6&quot;/&gt;
    &lt;/svg&gt;
);</file><file path="data/sampleData.ts">import { Bet } from &apos;../types&apos;;

// Set a fixed &quot;today&quot; for consistent recent dates
const today = new Date(&apos;2025-11-15T12:00:00Z&apos;);
const yesterday = new Date(today);
yesterday.setDate(today.getDate() - 1);
const twoDaysAgo = new Date(today);
twoDaysAgo.setDate(today.getDate() - 2);

const getDate = (daysAgo: number, hour: number = 20) =&gt; {
    const date = new Date(today);
    date.setDate(today.getDate() - daysAgo);
    date.setHours(hour, 0, 0, 0);
    return date.toISOString();
}

export const sampleBets: Bet[] = [
  // === PENDING BETS ===
  {
    id: &apos;DK-PENDING-NFL-2025-11-15-1&apos;,
    book: &apos;DraftKings&apos;,
    betId: &apos;DK-PEND-001&apos;,
    placedAt: today.toISOString(),
    betType: &apos;sgp&apos;,
    marketCategory: &apos;SGP/SGP+&apos;,
    sport: &apos;NFL&apos;,
    description: &quot;Chiefs vs Bills SGP&quot;,
    odds: 450,
    stake: 25,
    payout: 0,
    result: &apos;pending&apos;,
    legs: [
      { entities: [&apos;Patrick Mahomes&apos;], market: &apos;Passing Touchdowns&apos;, ou: &apos;Over&apos;, target: 2.5, result: &apos;pending&apos; },
      { entities: [&apos;Travis Kelce&apos;], market: &apos;Receiving Yards&apos;, ou: &apos;Over&apos;, target: 70.5, result: &apos;pending&apos; }
    ]
  },
  {
    id: &apos;FD-PENDING-NBA-2025-11-15-2&apos;,
    book: &apos;FanDuel&apos;,
    betId: &apos;FD-PEND-002&apos;,
    placedAt: today.toISOString(),
    betType: &apos;single&apos;,
    marketCategory: &apos;Main Markets&apos;,
    sport: &apos;NBA&apos;,
    description: &quot;Los Angeles Lakers ML&quot;,
    odds: -150,
    stake: 50,
    payout: 0,
    result: &apos;pending&apos;,
    legs: [
      { entities: [&apos;Los Angeles Lakers&apos;], market: &apos;Moneyline&apos;, result: &apos;pending&apos; }
    ]
  },

  // === SETTLED BETS (MOST RECENT FIRST) ===

  // --- NBA ---
  {
    id: &apos;FD-SGP1-NBA-2025-11-14&apos;,
    book: &apos;FanDuel&apos;,
    betId: &apos;FD-SGP-NBA-001&apos;,
    placedAt: getDate(1),
    settledAt: getDate(1, 22),
    betType: &apos;sgp&apos;,
    marketCategory: &apos;SGP/SGP+&apos;,
    sport: &apos;NBA&apos;,
    description: &quot;Lakers vs Warriors SGP&quot;,
    odds: 350,
    stake: 20,
    payout: 90.00,
    result: &apos;win&apos;,
    tail: &apos;ActionAl&apos;,
    legs: [
        { market: &quot;Player Points&quot;, entities: [&quot;LeBron James&quot;], result: &apos;win&apos;, ou: &apos;Over&apos;, target: &apos;25.5&apos; },
        { market: &quot;Player Rebounds&quot;, entities: [&quot;Anthony Davis&quot;], result: &apos;win&apos;, ou: &apos;Over&apos;, target: &apos;12.5&apos; }
    ]
  },
  {
    id: &apos;DK-SINGLE1-NBA-2025-11-14&apos;,
    book: &apos;DraftKings&apos;,
    betId: &apos;DK-SINGLE-NBA-001&apos;,
    placedAt: getDate(1),
    settledAt: getDate(1, 23),
    betType: &apos;single&apos;,
    marketCategory: &apos;Props&apos;,
    sport: &apos;NBA&apos;,
    description: &quot;Stephen Curry Prop&quot;,
    odds: -115,
    stake: 23,
    payout: 0,
    result: &apos;loss&apos;,
    legs: [
        { entities: [&apos;Stephen Curry&apos;], market: &apos;Player Threes&apos;, ou: &apos;Over&apos;, target: 4.5, result: &apos;loss&apos; }
    ]
  },
   {
    id: &apos;FD-PARLAY1-NBA-2025-11-13&apos;,
    book: &apos;FanDuel&apos;,
    betId: &apos;FD-PARLAY-NBA-001&apos;,
    placedAt: getDate(2),
    settledAt: getDate(2, 22),
    betType: &apos;parlay&apos;,
    marketCategory: &apos;Parlays&apos;,
    sport: &apos;NBA&apos;,
    description: &quot;2-Leg Moneyline Parlay&quot;,
    odds: 250,
    stake: 30,
    payout: 105.00,
    result: &apos;win&apos;,
    legs: [
        { market: &quot;Moneyline&quot;, entities: [&quot;Boston Celtics&quot;], result: &apos;win&apos; },
        { market: &quot;Moneyline&quot;, entities: [&quot;Milwaukee Bucks&quot;], result: &apos;win&apos; }
    ]
  },
  {
    id: &apos;DK-LIVE-NBA-2025-11-13&apos;,
    book: &apos;DraftKings&apos;,
    betId: &apos;DK-LIVE-NBA-001&apos;,
    placedAt: getDate(2, 21),
    settledAt: getDate(2, 23),
    betType: &apos;live&apos;,
    marketCategory: &apos;Main Markets&apos;,
    sport: &apos;NBA&apos;,
    description: &quot;Nuggets vs Suns (Live)&quot;,
    odds: 150,
    stake: 50,
    payout: 0,
    result: &apos;loss&apos;,
    legs: [
        { market: &quot;Spread&quot;, entities: [&quot;Denver Nuggets&quot;], target: 6.5, result: &apos;loss&apos; }
    ]
  },
  {
    id: &apos;FD-PROP-NBA-2025-11-12&apos;,
    book: &apos;FanDuel&apos;,
    betId: &apos;FD-PROP-NBA-001&apos;,
    placedAt: getDate(3),
    settledAt: getDate(3, 22),
    betType: &apos;single&apos;,
    marketCategory: &apos;Props&apos;,
    sport: &apos;NBA&apos;,
    description: &quot;Nikola Jokic Triple Double&quot;,
    odds: 220,
    stake: 25,
    payout: 80.00,
    result: &apos;win&apos;,
    legs: [
      { entities: [&apos;Nikola Jokic&apos;], market: &apos;To Record a Triple-Double&apos;, result: &apos;win&apos; }
    ]
  },
  {
    id: &apos;DK-PUSH-NBA-2025-11-12&apos;,
    book: &apos;DraftKings&apos;,
    betId: &apos;DK-PUSH-NBA-001&apos;,
    placedAt: getDate(3),
    settledAt: getDate(3, 23),
    betType: &apos;single&apos;,
    marketCategory: &apos;Main Markets&apos;,
    sport: &apos;NBA&apos;,
    description: &quot;Game Total Push&quot;,
    odds: -110,
    stake: 110,
    payout: 110,
    result: &apos;push&apos;,
    legs: [
      { entities: [&apos;76ers&apos;, &apos;Heat&apos;], market: &apos;Total Points&apos;, ou: &apos;Over&apos;, target: 215.0, result: &apos;push&apos; }
    ]
  },

  // --- NFL ---
  {
    id: &apos;DK-SINGLE1-NFL-2025-11-09&apos;,
    book: &apos;DraftKings&apos;,
    betId: &apos;DK-SINGLE-NFL-001&apos;,
    placedAt: getDate(6),
    settledAt: getDate(6, 22),
    betType: &apos;single&apos;,
    marketCategory: &apos;Main Markets&apos;,
    sport: &apos;NFL&apos;,
    description: &quot;Buffalo Bills Spread&quot;,
    odds: -110,
    stake: 55,
    payout: 0,
    result: &apos;loss&apos;,
    tail: &apos;BettingPro&apos;,
    legs: [
        { entities: [&apos;Buffalo Bills&apos;], market: &apos;Spread&apos;, target: -3.5, result: &apos;loss&apos; }
    ]
  },
  {
    id: &apos;FD-PROP-NFL-2025-11-09&apos;,
    book: &apos;FanDuel&apos;,
    betId: &apos;FD-PROP-NFL-01&apos;,
    placedAt: getDate(6),
    settledAt: getDate(6, 22),
    betType: &apos;single&apos;,
    marketCategory: &apos;Props&apos;,
    sport: &apos;NFL&apos;,
    description: &quot;Christian McCaffrey Prop&quot;,
    odds: -115,
    stake: 23,
    payout: 43.00,
    result: &apos;win&apos;,
    legs: [
      { entities: [&apos;Christian McCaffrey&apos;], market: &apos;Rushing Yards&apos;, ou: &apos;Over&apos;, target: 85.5, result: &apos;win&apos; }
    ]
  },
  {
    id: &apos;DK-SGP-NFL-2025-11-09&apos;,
    book: &apos;DraftKings&apos;,
    betId: &apos;DK-SGP-NFL-01&apos;,
    placedAt: getDate(6),
    settledAt: getDate(6, 23),
    betType: &apos;sgp&apos;,
    marketCategory: &apos;SGP/SGP+&apos;,
    sport: &apos;NFL&apos;,
    description: &quot;Eagles vs Cowboys SGP&quot;,
    odds: 1200,
    stake: 10,
    payout: 0,
    result: &apos;loss&apos;,
    legs: [
      { market: &quot;Anytime Touchdown Scorer&quot;, entities: [&quot;A.J. Brown&quot;], result: &apos;win&apos; },
      { market: &quot;Player Rushing Yards&quot;, entities: [&quot;Tony Pollard&quot;], result: &apos;win&apos;, ou: &apos;Over&apos;, target: &apos;60.5&apos; },
      { market: &quot;Player Passing Yards&quot;, entities: [&quot;Jalen Hurts&quot;], result: &apos;loss&apos;, ou: &apos;Over&apos;, target: &apos;250.5&apos; }
    ]
  },
  {
    id: &apos;FD-PARLAY-NFL-2025-11-02&apos;,
    book: &apos;FanDuel&apos;,
    betId: &apos;FD-PARLAY-NFL-001&apos;,
    placedAt: getDate(13),
    settledAt: getDate(13, 23),
    betType: &apos;parlay&apos;,
    marketCategory: &apos;Parlays&apos;,
    sport: &apos;NFL&apos;,
    description: &quot;3-Team ML Parlay&quot;,
    odds: 600,
    stake: 10,
    payout: 0,
    result: &apos;loss&apos;,
    tail: &apos;ActionAl&apos;,
    legs: [
        { market: &quot;Moneyline&quot;, entities: [&quot;Kansas City Chiefs&quot;], result: &apos;win&apos; },
        { market: &quot;Moneyline&quot;, entities: [&quot;San Francisco 49ers&quot;], result: &apos;win&apos; },
        { market: &quot;Moneyline&quot;, entities: [&quot;Baltimore Ravens&quot;], result: &apos;loss&apos; }
    ]
  },
  {
    id: &apos;DK-FUTURE-NFL-2025-08-01&apos;,
    book: &apos;DraftKings&apos;,
    betId: &apos;DK-FUTURE-NFL-01&apos;,
    placedAt: &apos;2025-08-01T12:00:00Z&apos;,
    settledAt: &apos;2026-02-10T03:00:00Z&apos;,
    betType: &apos;single&apos;,
    marketCategory: &apos;Futures&apos;,
    sport: &apos;NFL&apos;,
    description: &quot;Super Bowl Winner&quot;,
    odds: 650,
    stake: 100,
    payout: 750.00,
    result: &apos;win&apos;, // Pretend they won
    legs: [
      { entities: [&apos;Kansas City Chiefs&apos;], market: &apos;Outright Winner&apos;, result: &apos;win&apos; }
    ]
  },
  
  // --- Other Sports ---
  {
    id: &apos;FD-FUTURE1-TENNIS-2025-08-20&apos;,
    book: &apos;FanDuel&apos;,
    betId: &apos;FD-FUTURE-TENNIS-002&apos;,
    placedAt: &apos;2025-08-20T12:00:00Z&apos;,
    settledAt: &apos;2025-09-08T15:00:00Z&apos;,
    betType: &apos;single&apos;,
    marketCategory: &apos;Futures&apos;,
    sport: &apos;Tennis&apos;,
    description: &quot;US Open Winner&quot;,
    odds: 150,
    stake: 100,
    payout: 250.00,
    result: &apos;win&apos;,
    legs: [
        { entities: [&apos;Carlos Alcaraz&apos;], market: &apos;Outright Winner&apos;, result: &apos;win&apos; }
    ]
  },
  {
    id: &apos;DK-PROP-NHL-2025-10-25&apos;,
    book: &apos;DraftKings&apos;,
    betId: &apos;DK-PROP-NHL-01&apos;,
    placedAt: getDate(21),
    settledAt: getDate(21, 23),
    betType: &apos;single&apos;,
    marketCategory: &apos;Props&apos;,
    sport: &apos;NHL&apos;,
    description: &quot;Connor McDavid Prop&quot;,
    odds: 110,
    stake: 20,
    payout: 0,
    result: &apos;loss&apos;,
    legs: [
      { entities: [&apos;Connor McDavid&apos;], market: &apos;Points&apos;, ou: &apos;Over&apos;, target: 1.5, result: &apos;loss&apos; }
    ]
  },
  {
    id: &apos;FD-TOTAL-SOCCER-2025-10-18&apos;,
    book: &apos;FanDuel&apos;,
    betId: &apos;FD-TOTAL-SOC-01&apos;,
    placedAt: getDate(28),
    settledAt: getDate(28, 23),
    betType: &apos;single&apos;,
    marketCategory: &apos;Main Markets&apos;,
    sport: &apos;Soccer&apos;,
    description: &quot;Man U vs Arsenal Total&quot;,
    odds: -125,
    stake: 40,
    payout: 72.00,
    result: &apos;win&apos;,
    legs: [
      { entities: [&apos;Manchester United&apos;, &apos;Arsenal&apos;], market: &apos;Total Goals&apos;, ou: &apos;Over&apos;, target: 2.5, result: &apos;win&apos; }
    ]
  },
  {
    id: &apos;DK-PARLAY-MLB-2025-09-10&apos;,
    book: &apos;DraftKings&apos;,
    betId: &apos;DK-PARLAY-MLB-003&apos;,
    placedAt: &apos;2025-09-10T17:00:00Z&apos;,
    settledAt: &apos;2025-09-10T22:00:00Z&apos;,
    betType: &apos;parlay&apos;,
    marketCategory: &apos;Parlays&apos;,
    sport: &apos;MLB&apos;,
    description: &quot;2-Leg Run Line Parlay&quot;,
    odds: 450,
    stake: 15,
    payout: 0,
    result: &apos;loss&apos;,
    tail: &apos;BettingPro&apos;,
    legs: [
        { market: &quot;Run Line&quot;, entities: [&quot;Los Angeles Dodgers&quot;], result: &apos;win&apos;, target: -1.5 },
        { market: &quot;Run Line&quot;, entities: [&quot;Houston Astros&quot;], result: &apos;loss&apos;, target: -1.5 }
    ]
  },
  {
    id: &apos;FD-SGP-MLB-2025-09-05&apos;,
    book: &apos;FanDuel&apos;,
    betId: &apos;FD-SGP-MLB-003&apos;,
    placedAt: &apos;2025-09-05T18:20:00Z&apos;,
    settledAt: &apos;2025-09-05T21:00:00Z&apos;,
    betType: &apos;sgp&apos;,
    marketCategory: &apos;SGP/SGP+&apos;,
    sport: &apos;MLB&apos;,
    description: &quot;Yankees vs Red Sox SGP&quot;,
    odds: 800,
    stake: 5,
    payout: 45.00,
    result: &apos;win&apos;,
    legs: [
        { market: &quot;Player Home Runs&quot;, entities: [&quot;Aaron Judge&quot;], result: &apos;win&apos;, ou: &apos;Over&apos;, target: &apos;0.5&apos; },
        { market: &quot;Player Strikeouts&quot;, entities: [&quot;Gerrit Cole&quot;], result: &apos;win&apos;, ou: &apos;Over&apos;, target: &apos;6.5&apos; },
        { market: &quot;Moneyline&quot;, entities: [&quot;New York Yankees&quot;], result: &apos;win&apos; }
    ]
  },
  {
    id: &apos;FD-LIVE-NBA-2025-11-01&apos;,
    book: &apos;FanDuel&apos;,
    betId: &apos;FD-LIVE-NBA-01&apos;,
    placedAt: getDate(14, 21),
    settledAt: getDate(14, 22),
    betType: &apos;live&apos;,
    marketCategory: &apos;Main Markets&apos;,
    sport: &apos;NBA&apos;,
    description: &quot;Phoenix Suns ML (Live)&quot;,
    odds: 180,
    stake: 50,
    payout: 0,
    result: &apos;loss&apos;,
    tail: &apos;ActionAl&apos;,
    legs: [
      { entities: [&apos;Phoenix Suns&apos;], market: &apos;Moneyline&apos;, result: &apos;loss&apos; }
    ]
  },
];</file><file path="hooks/useBets.tsx">import React, { createContext, useContext, useState, useEffect, ReactNode, useCallback } from &apos;react&apos;;
import { Bet, BetResult } from &apos;../types&apos;;
import { sampleBets } from &apos;../data/sampleData&apos;;
import { useInputs } from &apos;./useInputs&apos;;
import { classifyBet } from &apos;../services/classificationService&apos;;

interface BetsContextType {
  bets: Bet[];
  addBets: (newBets: Bet[]) =&gt; number;
  updateBet: (betId: string, updates: Partial&lt;Bet&gt;) =&gt; void;
  clearBets: () =&gt; void;
  loading: boolean;
}

const BetsContext = createContext&lt;BetsContextType | undefined&gt;(undefined);

// --- Calculation Helpers ---
const calculateProfit = (stake: number, odds: number): number =&gt; {
    if (isNaN(stake) || isNaN(odds)) return 0;
    if (odds &gt; 0) {
        return stake * (odds / 100);
    } else if (odds &lt; 0) {
        return stake / (Math.abs(odds) / 100);
    }
    return 0;
};

const recalculatePayout = (stake: number, odds: number, result: BetResult): number =&gt; {
    switch (result) {
        case &apos;win&apos;:
            return stake + calculateProfit(stake, odds);
        case &apos;loss&apos;:
            return 0;
        case &apos;push&apos;:
            return stake;
        case &apos;pending&apos;:
            return 0;
        default:
            return 0;
    }
};

export const BetsProvider: React.FC&lt;{ children: ReactNode }&gt; = ({ children }) =&gt; {
  const [bets, setBets] = useState&lt;Bet[]&gt;([]);
  const [loading, setLoading] = useState&lt;boolean&gt;(true);
  const { addPlayer, addTeam } = useInputs();

  useEffect(() =&gt; {
    try {
      const storedBets = localStorage.getItem(&apos;bettracker-bets&apos;);
      if (storedBets) {
        const parsedBets: Bet[] = JSON.parse(storedBets);
        // Retroactively classify bets that don&apos;t have a category for backward compatibility
        const classifiedBets = parsedBets.map(bet =&gt; {
            if (!bet.marketCategory) {
                return { ...bet, marketCategory: classifyBet(bet) };
            }
            return bet;
        });
        setBets(classifiedBets);
      } else {
        // If no bets are in storage, load the sample data for the first time.
        const sortedSampleBets = [...sampleBets].sort((a, b) =&gt; new Date(b.placedAt).getTime() - new Date(a.placedAt).getTime());
        
        // Extract entities from sample data on first load to populate player/team lists.
        const teamMarketKeywords = [&apos;moneyline&apos;, &apos;ml&apos;, &apos;spread&apos;, &apos;total&apos;, &apos;run line&apos;, &apos;money line&apos;, &apos;outright winner&apos;, &apos;to win&apos;];
        const playerMarketKeywords = [&apos;player&apos;, &apos;prop&apos;, &apos;yards&apos;, &apos;points&apos;, &apos;rebounds&apos;, &apos;assists&apos;, &apos;touchdown&apos;, &apos;strikeouts&apos;, &apos;hits&apos;, &apos;goals&apos;, &apos;scorer&apos;, &apos;triple-double&apos;, &apos;threes&apos;];

        sortedSampleBets.forEach(bet =&gt; {
            const processEntities = (entities: string[], market: string) =&gt; {
                const lowerMarket = market.toLowerCase();
                const isTeamMarket = teamMarketKeywords.some(keyword =&gt; lowerMarket.includes(keyword));
                const isPlayerMarket = playerMarketKeywords.some(keyword =&gt; lowerMarket.includes(keyword));

                entities.forEach(entity =&gt; {
                    if (isPlayerMarket &amp;&amp; !isTeamMarket) {
                        addPlayer(bet.sport, entity);
                    } else if (isTeamMarket &amp;&amp; !isPlayerMarket) {
                        addTeam(bet.sport, entity);
                    } else {
                        // Ambiguous case. Let&apos;s infer from the sport type.
                        const teamSports = [&apos;NFL&apos;, &apos;NBA&apos;, &apos;MLB&apos;, &apos;NHL&apos;, &apos;Soccer&apos;];
                        if (teamSports.includes(bet.sport)) {
                            // For team sports, ambiguous markets are more likely to be for teams.
                            addTeam(bet.sport, entity);
                        } else {
                            // For individual sports (e.g., Tennis), default to player.
                            addPlayer(bet.sport, entity);
                        }
                    }
                });
            };
            
            bet.legs?.forEach(leg =&gt; {
                if (leg.entities &amp;&amp; leg.market) {
                    processEntities(leg.entities, leg.market);
                }
            });
            
            if (!bet.legs || bet.legs.length === 0) {
                const teamPatterns = [
                    /^(.*?)\s+(?:ML|Moneyline|[+-]\d{1,4}(?:\.\d+)?)\s*$/i, // &quot;Team Name ML&quot;, &quot;Team Name -3.5&quot;
                ];
                for (const pattern of teamPatterns) {
                    const match = bet.description.match(pattern);
                    if (match &amp;&amp; match[1]) {
                        addTeam(bet.sport, match[1].trim());
                        break;
                    }
                }
            }
        });


        setBets(sortedSampleBets);
        localStorage.setItem(&apos;bettracker-bets&apos;, JSON.stringify(sortedSampleBets));
      }
    } catch (error) {
      console.error(&quot;Failed to load bets from localStorage&quot;, error);
    } finally {
      setLoading(false);
    }
  }, []);

  const saveBets = (updatedBets: Bet[]) =&gt; {
      try {
        localStorage.setItem(&apos;bettracker-bets&apos;, JSON.stringify(updatedBets));
        setBets(updatedBets);
      } catch (error) {
        console.error(&quot;Failed to save bets to localStorage&quot;, error);
      }
  };

  const addBets = useCallback((newBets: Bet[]) =&gt; {
    // Keywords to help identify if a market is for a team or a player
    const teamMarketKeywords = [&apos;moneyline&apos;, &apos;ml&apos;, &apos;spread&apos;, &apos;total&apos;, &apos;run line&apos;, &apos;money line&apos;, &apos;outright winner&apos;, &apos;to win&apos;];
    const playerMarketKeywords = [&apos;player&apos;, &apos;prop&apos;, &apos;yards&apos;, &apos;points&apos;, &apos;rebounds&apos;, &apos;assists&apos;, &apos;touchdown&apos;, &apos;strikeouts&apos;, &apos;hits&apos;, &apos;goals&apos;, &apos;scorer&apos;, &apos;triple-double&apos;, &apos;threes&apos;];

    newBets.forEach(bet =&gt; {
        const processEntities = (entities: string[], market: string) =&gt; {
            const lowerMarket = market.toLowerCase();
            const isTeamMarket = teamMarketKeywords.some(keyword =&gt; lowerMarket.includes(keyword));
            const isPlayerMarket = playerMarketKeywords.some(keyword =&gt; lowerMarket.includes(keyword));

            entities.forEach(entity =&gt; {
                if (isPlayerMarket &amp;&amp; !isTeamMarket) {
                    addPlayer(bet.sport, entity);
                } else if (isTeamMarket &amp;&amp; !isPlayerMarket) {
                    addTeam(bet.sport, entity);
                } else {
                    // Ambiguous case. Let&apos;s infer from the sport type.
                    const teamSports = [&apos;NFL&apos;, &apos;NBA&apos;, &apos;MLB&apos;, &apos;NHL&apos;, &apos;Soccer&apos;];
                    if (teamSports.includes(bet.sport)) {
                        // For team sports, ambiguous markets are more likely to be for teams.
                        addTeam(bet.sport, entity);
                    } else {
                        // For individual sports (e.g., Tennis), default to player.
                        addPlayer(bet.sport, entity);
                    }
                }
            });
        };
        
        // Process entities from structured legs first
        bet.legs?.forEach(leg =&gt; {
            if (leg.entities &amp;&amp; leg.market) {
                processEntities(leg.entities, leg.market);
            }
        });
        
        // Fallback for single bets without structured legs: parse description for team names in main markets
        if (!bet.legs || bet.legs.length === 0) {
            const teamPatterns = [
                /^(.*?)\s+(?:ML|Moneyline|[+-]\d{1,4}(?:\.\d+)?)\s*$/i, // &quot;Team Name ML&quot;, &quot;Team Name -3.5&quot;
            ];
            for (const pattern of teamPatterns) {
                const match = bet.description.match(pattern);
                if (match &amp;&amp; match[1]) {
                    addTeam(bet.sport, match[1].trim());
                    break;
                }
            }
        }
    });

    let importedCount = 0;
    setBets(prevBets =&gt; {
      const existingBetIds = new Set(prevBets.map(b =&gt; b.id));
      const trulyNewBets = newBets.filter(newBet =&gt; !existingBetIds.has(newBet.id));
      
      // Classify new bets before adding them
      const classifiedNewBets = trulyNewBets.map(bet =&gt; ({
          ...bet,
          marketCategory: classifyBet(bet),
      }));
      importedCount = classifiedNewBets.length;
      
      if (importedCount &gt; 0) {
        const updatedBets = [...prevBets, ...classifiedNewBets].sort((a, b) =&gt; new Date(b.placedAt).getTime() - new Date(a.placedAt).getTime());
        saveBets(updatedBets);
        return updatedBets;
      }
      return prevBets;
    });
    return importedCount;
  }, [addPlayer, addTeam]);

  const updateBet = useCallback((betId: string, updates: Partial&lt;Bet&gt;) =&gt; {
    setBets(prevBets =&gt; {
      const betIndex = prevBets.findIndex(b =&gt; b.id === betId);
      if (betIndex === -1) {
        console.warn(`Bet with id ${betId} not found for update.`);
        return prevBets;
      }
      const updatedBets = [...prevBets];
      const originalBet = updatedBets[betIndex];
      const updatedBet = { ...originalBet, ...updates };
      
      // If tail is an empty string, remove the property
      if (updatedBet.tail === &apos;&apos;) {
        delete updatedBet.tail;
      }

      // Automatically recalculate payout if a relevant field changed
      const needsPayoutRecalc = &apos;stake&apos; in updates || &apos;odds&apos; in updates || &apos;result&apos; in updates;
      if (needsPayoutRecalc) {
        updatedBet.payout = recalculatePayout(updatedBet.stake, updatedBet.odds, updatedBet.result);
      }

      updatedBets[betIndex] = updatedBet;
      saveBets(updatedBets);
      return updatedBets;
    });
  }, []);

  const clearBets = useCallback(() =&gt; {
    saveBets([]);
  }, []);

  return (
    &lt;BetsContext.Provider value={{ bets, addBets, updateBet, clearBets, loading }}&gt;
      {children}
    &lt;/BetsContext.Provider&gt;
  );
};

export const useBets = (): BetsContextType =&gt; {
  const context = useContext(BetsContext);
  if (context === undefined) {
    throw new Error(&apos;useBets must be used within a BetsProvider&apos;);
  }
  return context;
};</file><file path="hooks/useInputs.tsx">import React, { createContext, useContext, useState, useEffect, ReactNode, useCallback } from &apos;react&apos;;
import { Sportsbook, SportsbookName } from &apos;../types&apos;;

export interface ItemsBySport {
  [sport: string]: string[];
}

interface InputsContextType {
  sportsbooks: Sportsbook[];
  addSportsbook: (book: Sportsbook) =&gt; boolean;
  removeSportsbook: (name: SportsbookName) =&gt; void;
  sports: string[];
  addSport: (sport: string) =&gt; boolean;
  removeSport: (sport: string) =&gt; void;
  betTypes: ItemsBySport;
  addBetType: (sport: string, type: string) =&gt; boolean;
  removeBetType: (sport: string, type: string) =&gt; void;
  players: ItemsBySport;
  addPlayer: (sport: string, player: string) =&gt; void;
  removePlayer: (sport: string, player: string) =&gt; void;
  teams: ItemsBySport;
  addTeam: (sport: string, team: string) =&gt; void;
  removeTeam: (sport: string, team: string) =&gt; void;
  loading: boolean;
}

const InputsContext = createContext&lt;InputsContextType | undefined&gt;(undefined);

const useLocalStorage = &lt;T,&gt;(key: string, initialValue: T): [T, (value: T | ((val: T) =&gt; T)) =&gt; void] =&gt; {
  const [storedValue, setStoredValue] = useState&lt;T&gt;(() =&gt; {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error(error);
      return initialValue;
    }
  });

  const setValue = (value: T | ((val: T) =&gt; T)) =&gt; {
    try {
      const valueToStore = value instanceof Function ? value(storedValue) : value;
      setStoredValue(valueToStore);
      window.localStorage.setItem(key, JSON.stringify(valueToStore));
    } catch (error) {
      console.error(error);
    }
  };

  return [storedValue, setValue];
};

const defaultSportsbooks: Sportsbook[] = [
    { name: &apos;FanDuel&apos;, abbreviation: &apos;FD&apos;, url: &apos;https://www.fanduel.com/&apos; },
    { name: &apos;DraftKings&apos;, abbreviation: &apos;DK&apos;, url: &apos;https://www.draftkings.com/&apos; }
];
const defaultSports: string[] = [&apos;NBA&apos;, &apos;NFL&apos;, &apos;MLB&apos;, &apos;NHL&apos;, &apos;Soccer&apos;, &apos;Tennis&apos;];
const defaultBetTypes: ItemsBySport = {
    &apos;NBA&apos;: [&apos;Player Points&apos;, &apos;Player Rebounds&apos;, &apos;Player Assists&apos;, &apos;Player Threes&apos;],
    &apos;NFL&apos;: [&apos;Passing Yards&apos;, &apos;Rushing Yards&apos;, &apos;Receiving Yards&apos;, &apos;Anytime Touchdown Scorer&apos;],
    &apos;MLB&apos;: [&apos;Home Runs&apos;, &apos;Strikeouts&apos;, &apos;Hits&apos;],
    &apos;NHL&apos;: [&apos;Goals&apos;, &apos;Assists&apos;, &apos;Shots on Goal&apos;],
    &apos;Soccer&apos;: [&apos;Goals&apos;, &apos;Shots&apos;, &apos;Assists&apos;]
};

export const InputsProvider: React.FC&lt;{ children: ReactNode }&gt; = ({ children }) =&gt; {
  const [sportsbooks, setSportsbooks] = useLocalStorage&lt;Sportsbook[]&gt;(&apos;bettracker-sportsbooks&apos;, defaultSportsbooks);
  const [sports, setSports] = useLocalStorage&lt;string[]&gt;(&apos;bettracker-sports&apos;, defaultSports);
  const [betTypes, setBetTypes] = useLocalStorage&lt;ItemsBySport&gt;(&apos;bettracker-bettypes&apos;, defaultBetTypes);
  const [players, setPlayers] = useLocalStorage&lt;ItemsBySport&gt;(&apos;bettracker-players&apos;, {});
  const [teams, setTeams] = useLocalStorage&lt;ItemsBySport&gt;(&apos;bettracker-teams&apos;, {});
  const [loading, setLoading] = useState(true);

  useEffect(() =&gt; {
    // This effect ensures that we don&apos;t render children until hydration from localStorage is complete.
    setLoading(false);
  }, []);

  const addSportsbook = useCallback((book: Sportsbook) =&gt; {
    if (sportsbooks.some(b =&gt; b.name.toLowerCase() === book.name.toLowerCase())) {
        return false;
    }
    setSportsbooks([...sportsbooks, book].sort((a,b) =&gt; a.name.localeCompare(b.name)));
    return true;
  }, [sportsbooks, setSportsbooks]);

  const removeSportsbook = useCallback((name: SportsbookName) =&gt; {
    setSportsbooks(sportsbooks.filter(b =&gt; b.name !== name));
  }, [sportsbooks, setSportsbooks]);

  const addSport = useCallback((sport: string) =&gt; {
    if (sports.some(s =&gt; s.toLowerCase() === sport.toLowerCase())) {
        return false;
    }
    setSports([...sports, sport].sort());
    return true;
  }, [sports, setSports]);

  const removeSport = useCallback((sportToRemove: string) =&gt; {
    setSports(sports.filter(s =&gt; s !== sportToRemove));
    // Also remove associated bet types, players, and teams
    const newBetTypes = { ...betTypes };
    delete newBetTypes[sportToRemove];
    setBetTypes(newBetTypes);
    const newPlayers = { ...players };
    delete newPlayers[sportToRemove];
    setPlayers(newPlayers);
    const newTeams = { ...teams };
    delete newTeams[sportToRemove];
    setTeams(newTeams);
  }, [sports, setSports, betTypes, setBetTypes, players, setPlayers, teams, setTeams]);

  const addBetType = useCallback((sport: string, type: string) =&gt; {
    const sportTypes = betTypes[sport] || [];
    if (sportTypes.some(t =&gt; t.toLowerCase() === type.toLowerCase())) {
        return false;
    }
    const newBetTypes = {
      ...betTypes,
      [sport]: [...sportTypes, type].sort()
    };
    setBetTypes(newBetTypes);
    return true;
  }, [betTypes, setBetTypes]);

  const removeBetType = useCallback((sport: string, typeToRemove: string) =&gt; {
    const sportTypes = betTypes[sport] || [];
    const newSportTypes = sportTypes.filter(t =&gt; t !== typeToRemove);
    const newBetTypes = {
      ...betTypes,
      [sport]: newSportTypes
    };
    if (newSportTypes.length === 0) {
        delete newBetTypes[sport];
    }
    setBetTypes(newBetTypes);
  }, [betTypes, setBetTypes]);

  const addBySport = useCallback((sport: string, item: string, setter: (value: ItemsBySport | ((val: ItemsBySport) =&gt; ItemsBySport)) =&gt; void) =&gt; {
    if (!sport || !item) return;
    setter(prevList =&gt; {
      const sportList = prevList[sport] || [];
      if (!sportList.some(i =&gt; i.toLowerCase() === item.toLowerCase())) {
        const newList = { ...prevList, [sport]: [...sportList, item].sort() };
        return newList;
      }
      return prevList;
    });
  }, []);

  const removeBySport = useCallback((sport: string, itemToRemove: string, setter: (value: ItemsBySport | ((val: ItemsBySport) =&gt; ItemsBySport)) =&gt; void) =&gt; {
    setter(prevList =&gt; {
      const sportList = prevList[sport] || [];
      const newSportList = sportList.filter(item =&gt; item !== itemToRemove);
      const newList = { ...prevList, [sport]: newSportList };
      if (newSportList.length === 0) {
        delete newList[sport];
      }
      return newList;
    });
  }, []);

  const addPlayer = useCallback((sport: string, player: string) =&gt; addBySport(sport, player, setPlayers), [addBySport, setPlayers]);
  const removePlayer = useCallback((sport: string, player: string) =&gt; removeBySport(sport, player, setPlayers), [removeBySport, setPlayers]);
  const addTeam = useCallback((sport: string, team: string) =&gt; addBySport(sport, team, setTeams), [addBySport, setTeams]);
  const removeTeam = useCallback((sport: string, team: string) =&gt; removeBySport(sport, team, setTeams), [removeBySport, setTeams]);


  const value = {
    sportsbooks, addSportsbook, removeSportsbook,
    sports, addSport, removeSport,
    betTypes, addBetType, removeBetType,
    players, addPlayer, removePlayer,
    teams, addTeam, removeTeam,
    loading
  };

  return &lt;InputsContext.Provider value={value}&gt;{!loading &amp;&amp; children}&lt;/InputsContext.Provider&gt;;
};

export const useInputs = (): InputsContextType =&gt; {
  const context = useContext(InputsContext);
  if (context === undefined) {
    throw new Error(&apos;useInputs must be used within an InputsProvider&apos;);
  }
  return context;
};</file><file path="parsers/draftkings.ts">import { Bet, BetResult, BetType } from &apos;../types&apos;;
// FIX: Import the classification service to automatically determine the market category.
import { classifyBet } from &apos;../services/classificationService&apos;;

/**
 * Parses raw HTML content from a DraftKings settled bets page.
 * This is a placeholder and needs to be implemented with real data.
 */
export const parse = (htmlContent: string): Bet[] =&gt; {
  console.log(&quot;Starting DraftKings parse...&quot;);
  const bets: Bet[] = [];
  
  // Placeholder Example 1
  const betId1 = &apos;DK638982435218573479&apos;;
  const placedAt1 = new Date(&apos;2023-11-12T14:00:00Z&apos;).toISOString();
  // FIX: Add missing &apos;marketCategory&apos; property to conform to the Bet type.
  const bet1Data = {
    id: `DraftKings-${betId1}-${placedAt1}`,
    book: &apos;DraftKings&apos;,
    betId: betId1,
    placedAt: placedAt1,
    settledAt: new Date(&apos;2023-11-12T17:00:00Z&apos;).toISOString(),
    betType: &apos;parlay&apos; as BetType,
    sport: &apos;NBA&apos;,
    description: &quot;2-Leg Parlay: T. Watford Assists / J. Allen Rebounds&quot;,
    odds: 192,
    stake: 2.00,
    payout: 5.84,
    result: &apos;win&apos; as BetResult,
    legs: [
        // FIX: Explicitly cast &apos;result&apos; to BetResult to resolve type incompatibility.
        // FIX: The &apos;BetLeg&apos; type uses &apos;entities&apos; not &apos;player&apos;. Corrected the property name.
        { market: &quot;Assists&quot;, entities: [&quot;Trendon Watford&quot;], result: &apos;win&apos; as BetResult },
        // FIX: Explicitly cast &apos;result&apos; to BetResult to resolve type incompatibility.
        // FIX: The &apos;BetLeg&apos; type uses &apos;entities&apos; not &apos;player&apos;. Corrected the property name.
        { market: &quot;Rebounds&quot;, entities: [&quot;Jarrett Allen&quot;], result: &apos;win&apos; as BetResult }
    ],
    raw: &quot;4++192\nTrendon Watford Assists\nWon\nWager: $2.00 Paid: $5.84\nDK638982435218573479&quot;
  };
  bets.push({ ...bet1Data, marketCategory: classifyBet(bet1Data) });

  // Placeholder Example 2
  const betId2 = &apos;DK638982435218573485&apos;;
  const placedAt2 = new Date(&apos;2023-11-13T19:30:00Z&apos;).toISOString();
  // FIX: Add missing &apos;marketCategory&apos; property to conform to the Bet type.
  const bet2Data = {
    id: `DraftKings-${betId2}-${placedAt2}`,
    book: &apos;DraftKings&apos;,
    betId: betId2,
    placedAt: placedAt2,
    settledAt: new Date(&apos;2023-11-13T22:30:00Z&apos;).toISOString(),
    betType: &apos;single&apos; as BetType,
    sport: &apos;NBA&apos;,
    description: &quot;New York Knicks Moneyline&quot;,
    odds: -150,
    stake: 15.00,
    payout: 0.00,
    result: &apos;loss&apos; as BetResult,
    raw: &quot;New York Knicks ML\nLost\nWager: $15.00 Paid: $0.00\nDK638982435218573485&quot;
  };
  bets.push({ ...bet2Data, marketCategory: classifyBet(bet2Data) });

  console.log(`DraftKings parser found ${bets.length} placeholder bets.`);
  return bets;
};</file><file path="parsers/fanduel.ts">import { Bet, BetResult, BetType } from &apos;../types&apos;;
// FIX: Import the classification service to automatically determine the market category.
import { classifyBet } from &apos;../services/classificationService&apos;;

/**
 * Parses raw HTML content from a FanDuel settled bets page.
 * This is a placeholder and needs to be implemented with real data.
 * The logic would involve using a DOM parser (like cheerio if in Node, or browser DOM APIs)
 * to find the container for each bet, then extracting details.
 */
export const parse = (htmlContent: string): Bet[] =&gt; {
  console.log(&quot;Starting FanDuel parse...&quot;);
  // In a real scenario, we wouldn&apos;t use the full HTML string with regex.
  // We&apos;d use the browser&apos;s DOMParser to create a document object.
  // const parser = new DOMParser();
  // const doc = parser.parseFromString(htmlContent, &apos;text/html&apos;);
  // const betSlips = doc.querySelectorAll(&apos;.bet-slip-selector&apos;); // Fictional selector

  // For this placeholder, we&apos;ll use a simple regex approach on a sample text block.
  // This is brittle and for demonstration only.

  const bets: Bet[] = [];

  // Placeholder Example 1
  const betId1 = &apos;O/0242888/0027898&apos;;
  const placedAt1 = new Date(&apos;2023-11-14T21:39:00Z&apos;).toISOString();
  // FIX: Add missing &apos;marketCategory&apos; property to conform to the Bet type.
  const bet1Data = {
    id: `FanDuel-${betId1}-${placedAt1}`,
    book: &apos;FanDuel&apos;,
    betId: betId1,
    placedAt: placedAt1,
    settledAt: new Date(&apos;2023-11-14T23:50:00Z&apos;).toISOString(),
    betType: &apos;sgp&apos; as BetType,
    sport: &apos;NBA&apos;,
    description: &quot;SGP: De&apos;Aaron Fox 25+ Pts / Domantas Sabonis 10+ Reb&quot;,
    odds: 250,
    stake: 10.00,
    payout: 35.00,
    result: &apos;win&apos; as BetResult,
    legs: [
        // FIX: Explicitly cast &apos;result&apos; to BetResult to resolve type incompatibility.
        // FIX: The &apos;BetLeg&apos; type uses &apos;entities&apos; not &apos;player&apos;. Corrected the property name.
        { market: &quot;To Score 25+ Points&quot;, entities: [&quot;De&apos;Aaron Fox&quot;], result: &apos;win&apos; as BetResult },
        // FIX: Explicitly cast &apos;result&apos; to BetResult to resolve type incompatibility.
        // FIX: The &apos;BetLeg&apos; type uses &apos;entities&apos; not &apos;player&apos;. Corrected the property name.
        { market: &quot;10+ Rebounds&quot;, entities: [&quot;Domantas Sabonis&quot;], result: &apos;win&apos; as BetResult }
    ],
    raw: &quot;De&apos;Aaron Fox\nTo Score 25+ Points\nBET ID: O/0242888/0027898\nPLACED: 11/14/2023 9:39PM ET&quot;
  };
  bets.push({ ...bet1Data, marketCategory: classifyBet(bet1Data) });

  // Placeholder Example 2
  const betId2 = &apos;O/0242888/0027901&apos;;
  const placedAt2 = new Date(&apos;2023-11-15T18:00:00Z&apos;).toISOString();
  // FIX: Add missing &apos;marketCategory&apos; property to conform to the Bet type.
  const bet2Data = {
    id: `FanDuel-${betId2}-${placedAt2}`,
    book: &apos;FanDuel&apos;,
    betId: betId2,
    placedAt: placedAt2,
    settledAt: new Date(&apos;2023-11-15T22:00:00Z&apos;).toISOString(),
    betType: &apos;single&apos; as BetType,
    sport: &apos;NFL&apos;,
    description: &quot;Kansas City Chiefs -7.5&quot;,
    odds: -110,
    stake: 22.00,
    payout: 0.00,
    result: &apos;loss&apos; as BetResult,
    raw: &quot;Kansas City Chiefs -7.5\nSpread\nBET ID: O/0242888/0027901&quot;
  };
  bets.push({ ...bet2Data, marketCategory: classifyBet(bet2Data) });


  console.log(`FanDuel parser found ${bets.length} placeholder bets.`);
  return bets;
};</file><file path="parsing/parsers/draftkings.ts">import { Bet, BetResult, BetType } from &apos;../../types&apos;;

/**
 * Parses raw HTML content from a DraftKings settled bets page.
 * This is a placeholder and needs to be implemented with real data.
 */
export const parse = (htmlContent: string): Bet[] =&gt; {
  console.log(&quot;Starting DraftKings parse...&quot;);
  const bets: Bet[] = [];
  
  // In a real implementation, you would parse the htmlContent to find bet information.
  // Example using DOMParser (in a browser environment):
  /*
  const parser = new DOMParser();
  const doc = parser.parseFromString(htmlContent, &apos;text/html&apos;);
  const betElements = doc.querySelectorAll(&apos;.your-bet-selector&apos;); // Use actual selector
  
  betElements.forEach(element =&gt; {
      // Extract data from the element and build a Bet object
      const bet: Bet = { ... };
      bets.push(bet);
  });
  */

  console.log(`DraftKings parser found ${bets.length} bets.`);
  return bets;
};</file><file path="parsing/parsers/fanduel.ts">import { Bet, BetResult, BetType } from &apos;../../types&apos;;

/**
 * Parses raw HTML content from a FanDuel settled bets page.
 * This is a placeholder and needs to be implemented with real data.
 * The logic would involve using a DOM parser (like cheerio if in Node, or browser DOM APIs)
 * to find the container for each bet, then extracting details.
 */
export const parse = (htmlContent: string): Bet[] =&gt; {
  console.log(&quot;Starting FanDuel parse...&quot;);
  // In a real scenario, we wouldn&apos;t use the full HTML string with regex.
  // We&apos;d use the browser&apos;s DOMParser to create a document object.
  // const parser = new DOMParser();
  // const doc = parser.parseFromString(htmlContent, &apos;text/html&apos;);
  // const betSlips = doc.querySelectorAll(&apos;.bet-slip-selector&apos;); // Fictional selector

  // For this placeholder, we will return an empty array.
  // The real implementation will find and parse bet slips from the HTML content.
  const bets: Bet[] = [];

  console.log(`FanDuel parser found ${bets.length} bets.`);
  return bets;
};</file><file path="parsing/pageProcessor.ts">import { SportsbookName, Bet } from &apos;../types&apos;;
import { parse as parseFanDuel } from &apos;./parsers/fanduel&apos;;
import { parse as parseDraftKings } from &apos;./parsers/draftkings&apos;;

export const processPage = (book: SportsbookName, html: string): Bet[] =&gt; {
  if (!html) {
    console.warn(&quot;HTML content is empty, skipping parse.&quot;);
    return [];
  }

  let parsedBets: Bet[] = [];
  try {
    switch (book) {
      case &apos;FanDuel&apos;:
        parsedBets = parseFanDuel(html);
        break;
      case &apos;DraftKings&apos;:
        parsedBets = parseDraftKings(html);
        break;
      case &apos;Other&apos;:
        // A generic parser or a user-defined parser could be called here.
        console.warn(&apos;Parsing for &quot;Other&quot; is not implemented.&apos;);
        break;
      default:
        console.warn(`No specific parser available for sportsbook: ${book}. A generic attempt can be made here in the future.`);
        break;
    }
  } catch (error) {
    console.error(`Error parsing data for ${book}:`, error);
    alert(`An error occurred while parsing the page for ${book}. Check the console for details.`);
    return [];
  }

  return parsedBets;
};</file><file path="services/classificationService.ts">import { Bet, MarketCategory } from &apos;../types&apos;;

// Omit fields that are not available during classification of a new bet object.
type ClassifiableBet = Omit&lt;Bet, &apos;id&apos; | &apos;marketCategory&apos; | &apos;raw&apos; | &apos;tail&apos;&gt;;

const isProp = (bet: ClassifiableBet): boolean =&gt; {
    // Check legs for player/team props
    // FIX: The &apos;BetLeg&apos; type does not have a &apos;player&apos; property. Use &apos;entities&apos; to check for player/team props.
    if (bet.legs?.some(leg =&gt; leg.entities &amp;&amp; leg.entities.length &gt; 0)) {
        return true;
    }
    // Check description for common prop keywords
    const propKeywords = [
        &apos;Pts&apos;, &apos;Reb&apos;, &apos;Ast&apos;, // NBA
        &apos;Points&apos;, &apos;Rebounds&apos;, &apos;Assists&apos;, &apos;Threes&apos;, // General
        &apos;Yards&apos;, &apos;Touchdown&apos;, &apos;TD&apos;, &apos;Receiving&apos;, &apos;Rushing&apos;, &apos;Passing&apos;, // NFL
        &apos;Home Runs&apos;, &apos;Strikeouts&apos;, &apos;Hits&apos;, &apos;Runs&apos;, // MLB
        &apos;Goals&apos;, &apos;Shots on Goal&apos;, // NHL / Soccer
    ];
    if (propKeywords.some(keyword =&gt; new RegExp(`\\b${keyword}\\b`, &apos;i&apos;).test(bet.description))) {
        return true;
    }
    return false;
};

const isMainMarket = (bet: ClassifiableBet): boolean =&gt; {
    const mainMarketKeywords = [&apos;Moneyline&apos;, &apos;ML&apos;, &apos;Spread&apos;];
    if (mainMarketKeywords.some(keyword =&gt; new RegExp(`\\b${keyword}\\b`, &apos;i&apos;).test(bet.description))) {
        return true;
    }
    // Check for spread patterns like -7.5 or +3.5 at the end of the description
    if (/[+-]\d{1,3}(\.5)?$/.test(bet.description.trim())) {
        return true;
    }
     // Check for totals patterns
    if (/\b(Total|Over|Under)\b/i.test(bet.description)) {
        return true;
    }
    return false;
};

const isFuture = (bet: ClassifiableBet): boolean =&gt; {
    const futureKeywords = [&apos;to win&apos;, &apos;Award&apos;, &apos;MVP&apos;, &apos;Champion&apos;, &apos;Outright&apos;, &apos;Win Total&apos;];
    if (futureKeywords.some(keyword =&gt; new RegExp(`\\b${keyword}\\b`, &apos;i&apos;).test(bet.description))) {
        return true;
    }
    return false;
};

export const classifyBet = (bet: ClassifiableBet): MarketCategory =&gt; {
    if (bet.betType === &apos;sgp&apos;) {
        return &apos;SGP/SGP+&apos;;
    }
    if (bet.betType === &apos;parlay&apos;) {
        return &apos;Parlays&apos;;
    }

    if (isFuture(bet)) {
        return &apos;Futures&apos;;
    }
    
    // For single/live bets, check for market type
    if ([&apos;single&apos;, &apos;live&apos;, &apos;other&apos;].includes(bet.betType)) {
        if (isMainMarket(bet)) {
            return &apos;Main Markets&apos;;
        }
        if (isProp(bet)) {
            return &apos;Props&apos;;
        }
    }
    
    // Fallback for parlays/sgps that might be prop-heavy but not caught above
    if (isProp(bet)) {
        return &apos;Props&apos;;
    }

    return &apos;Other&apos;;
};</file><file path="services/csvParser.ts">import { BetResult } from &apos;../types&apos;;

// This is the shape of the object after parsing and cleaning a row from the CSV
export interface ParsedCsvRow {
    date: string;
    site: string;
    sport: string;
    type: string;
    name: string;
    ou?: &apos;Over&apos; | &apos;Under&apos;;
    line?: string;
    odds: number;
    bet: number;
    toWin: number;
    result: BetResult;
    tail?: string;
    notes?: string;
}

// This interface is a direct mapping of the expected CSV headers.
interface CsvRow {
  Date: string;
  Site: string;
  Sport: string;
  Type: string;
  Name: string;
  &apos;O/U&apos;: &apos;Over&apos; | &apos;Under&apos; | string;
  Line: string;
  Odds: string;
  Bet: string;
  &apos;To Win&apos;: string;
  Result: string;
  Net: string;
  Tail: string;
  Notes: string;
}

export const parseCsv = (csvString: string): ParsedCsvRow[] =&gt; {
    const lines = csvString.replace(/\r/g, &apos;&apos;).split(&apos;\n&apos;).filter(line =&gt; line.trim() !== &apos;&apos;);
    if (lines.length &lt; 2) {
        throw new Error(&quot;CSV must have a header row and at least one data row.&quot;);
    }

    const parseLine = (line: string): string[] =&gt; {
        const result: string[] = [];
        let current = &apos;&apos;;
        let inQuotes = false;
        for (let i = 0; i &lt; line.length; i++) {
            const char = line[i];
            if (char === &apos;&quot;&apos;) {
                if (inQuotes &amp;&amp; line[i + 1] === &apos;&quot;&apos;) {
                    current += &apos;&quot;&apos;;
                    i++;
                } else {
                    inQuotes = !inQuotes;
                }
            } else if (char === &apos;,&apos; &amp;&amp; !inQuotes) {
                result.push(current.trim());
                current = &apos;&apos;;
            } else {
                current += char;
            }
        }
        result.push(current.trim());
        return result;
    };

    const header = parseLine(lines[0]);
    const requiredHeaders = [&apos;Date&apos;, &apos;Site&apos;, &apos;Sport&apos;, &apos;Type&apos;, &apos;Name&apos;, &apos;Odds&apos;, &apos;Bet&apos;, &apos;To Win&apos;, &apos;Result&apos;];
    const missingHeaders = requiredHeaders.filter(h =&gt; !header.includes(h));

    // Allow for flexibility if some optional columns are missing, but error on required ones.
    if (missingHeaders.length &gt; 0) {
        throw new Error(`CSV is missing required headers: ${missingHeaders.join(&apos;, &apos;)}. Please check the instructions.`);
    }

    const rows = lines.slice(1);

    const data = rows.map((rowString, rowIndex) =&gt; {
        const values = parseLine(rowString);
        const rowObject = header.reduce((obj, key, index) =&gt; {
            obj[key as keyof CsvRow] = values[index];
            return obj;
        }, {} as Partial&lt;CsvRow&gt;);

        const cleanString = (str: string | undefined) =&gt; (str || &apos;&apos;).trim();

        const resultStr = cleanString(rowObject.Result).toLowerCase();
        let result: BetResult;
        if (resultStr.startsWith(&apos;won&apos;)) result = &apos;win&apos;;
        else if (resultStr.startsWith(&apos;lost&apos;)) result = &apos;loss&apos;;
        else if (resultStr.startsWith(&apos;push&apos;)) result = &apos;push&apos;;
        else result = &apos;pending&apos;;

        const ouStr = cleanString(rowObject[&apos;O/U&apos;]);
        
        const parsedRow: ParsedCsvRow = {
            date: cleanString(rowObject.Date),
            site: cleanString(rowObject.Site),
            sport: cleanString(rowObject.Sport),
            type: cleanString(rowObject.Type),
            name: cleanString(rowObject.Name),
            ou: ouStr.toLowerCase() === &apos;over&apos; ? &apos;Over&apos; : ouStr.toLowerCase() === &apos;under&apos; ? &apos;Under&apos; : undefined,
            line: cleanString(rowObject.Line),
            odds: parseFloat(cleanString(rowObject.Odds).replace(&apos;+&apos;, &apos;&apos;)),
            bet: parseFloat(cleanString(rowObject.Bet).replace(/[\$,]/g, &apos;&apos;)),
            toWin: parseFloat(cleanString(rowObject[&apos;To Win&apos;]).replace(/[\$,]/g, &apos;&apos;)),
            result: result,
            tail: cleanString(rowObject.Tail) || undefined,
            notes: cleanString(rowObject.Notes) || undefined,
        };

        // Validate required numeric fields
        const numericErrors = [];
        if (isNaN(parsedRow.odds)) numericErrors.push(&apos;Odds&apos;);
        if (isNaN(parsedRow.bet)) numericErrors.push(&apos;Bet&apos;);
        if (isNaN(parsedRow.toWin)) numericErrors.push(&apos;To Win&apos;);
        if (numericErrors.length &gt; 0) {
            throw new Error(`Row ${rowIndex + 2}: Invalid number format for ${numericErrors.join(&apos;, &apos;)}.`);
        }
        
        return parsedRow;
    });

    return data;
};</file><file path="services/errors.ts">/**
 * Custom error thrown when a PageSourceProvider cannot retrieve data.
 */
export class NoSourceDataError extends Error {
    constructor(message: string) {
        super(message);
        this.name = &quot;NoSourceDataError&quot;;
    }
}</file><file path="services/importer.ts">import { processPage } from &apos;../parsing/pageProcessor&apos;;
import { PageSourceProvider } from &apos;./pageSourceProvider&apos;;
import { SportsbookName, Bet } from &apos;../types&apos;;

/**
 * Orchestrates the import process: get source -&gt; parse -&gt; add to storage.
 * @param book The sportsbook being imported.
 * @param provider The PageSourceProvider to use for getting HTML.
 * @param addBets The function from useBets context to add bets and persist them.
 * @returns A promise that resolves to the number of bets found and newly imported.
 */
export async function handleImport(
    book: SportsbookName,
    provider: PageSourceProvider,
    addBets: (newBets: Bet[]) =&gt; number
): Promise&lt;{ foundCount: number, importedCount: number }&gt; {
    const rawHtml = await provider.getPageSource(book);
    
    const parsedBets = processPage(book, rawHtml);
    const importedCount = addBets(parsedBets);

    return { foundCount: parsedBets.length, importedCount };
}</file><file path="services/pageSourceProvider.ts">import { SportsbookName } from &apos;../types&apos;;
import { NoSourceDataError } from &apos;./errors&apos;;

/**
 * An abstraction for providing the HTML source of a sportsbook page.
 * This allows swapping between manual pasting and a live webview.
 */
export interface PageSourceProvider {
  /**
   * Retrieves the page source for a given sportsbook.
   * @param book The sportsbook to get the source for.
   * @returns A promise that resolves to the page&apos;s HTML source as a string.
   */
  getPageSource(book: SportsbookName): Promise&lt;string&gt;;
}

/**
 * A PageSourceProvider that gets its content from a user-populated textarea.
 * This is used in the web-based Gemini environment.
 */
export class ManualPasteSourceProvider implements PageSourceProvider {
  /**
   * @param getTextareaValue A function that returns the current value of the HTML source textarea.
   */
  constructor(private getTextareaValue: () =&gt; string) {}

  async getPageSource(book: SportsbookName): Promise&lt;string&gt; {
    const value = this.getTextareaValue();
    if (!value || !value.trim()) {
        throw new NoSourceDataError(&quot;Please paste the page&apos;s HTML source into the text area before importing.&quot;);
    }
    return Promise.resolve(value);
  }
}

/**
 * A PageSourceProvider that interacts with an embedded webview.
 * This is the target implementation for a real desktop app (e.g., Electron, Tauri).
 */
// TODO: When this project is moved to Electron or Tauri,
// replace ManualPasteSourceProvider with this real implementation.
export class WebviewSourceProvider implements PageSourceProvider {
  /**
   * @param webview An instance of the webview controller from the desktop framework.
   */
  constructor(private webview: any) {}

  async getPageSource(book: SportsbookName): Promise&lt;string&gt; {
    // In the desktop version, this will run code inside a real browser view:
    // This example gets the innerHTML, but you could get outerHTML for full parsing.
    // return await this.webview.executeJavaScript(&apos;document.body.innerHTML&apos;);
    console.error(&quot;WebviewSourceProvider is not implemented in the Gemini environment.&quot;, book, this.webview);
    throw new Error(&quot;WebviewSourceProvider is not implemented in the Gemini environment.&quot;);
  }
}</file><file path="views/BetTableView.tsx">import React, { useState, useMemo, useCallback } from &apos;react&apos;;
import { useBets } from &apos;../hooks/useBets&apos;;
import { useInputs } from &apos;../hooks/useInputs&apos;;
import { Bet, SportsbookName, BetResult, MarketCategory, BetLeg, BetType } from &apos;../types&apos;;
import { Wifi } from &apos;../components/icons&apos;;
import { MARKET_CATEGORIES } from &apos;../constants&apos;;

interface FlatBet {
    id: string; // unique ID for the row, e.g., bet.id or bet.id-leg-index
    betId: string; // original bet ID, for updates
    date: string;
    site: SportsbookName;
    sport: string;
    type: string;
    category: MarketCategory;
    name: string;
    ou?: &apos;Over&apos; | &apos;Under&apos;;
    line?: string | number;
    odds?: number;
    bet: number;
    toWin: number; // Potential Payout (stake + profit)
    result: BetResult;
    net: number;
    isLive: boolean;
    overallResult: BetResult;
    tail?: string;
}

// --- Calculation Helper ---
const calculateProfit = (stake: number, odds: number): number =&gt; {
    if (isNaN(stake) || isNaN(odds) || stake &lt;= 0) return 0;
    if (odds &gt; 0) {
        return stake * (odds / 100);
    } else if (odds &lt; 0) {
        return stake / (Math.abs(odds) / 100);
    }
    return 0;
};

// --- Formatting Helpers ---
const formatDate = (isoString: string) =&gt; {
    const date = new Date(isoString);
    if (isNaN(date.getTime())) return &apos;Invalid Date&apos;;
    const month = String(date.getMonth() + 1).padStart(2, &apos;0&apos;);
    const day = String(date.getDate()).padStart(2, &apos;0&apos;);
    const year = String(date.getFullYear()).slice(-2);
    return `${month}/${day}/${year}`;
};

const abbreviateMarket = (market: string): string =&gt; {
    if (!market) return &apos;&apos;;
    const lowerMarket = market.toLowerCase();
    
    const abbreviations: { [key: string]: string } = {
        &apos;player points&apos;: &apos;Pts&apos;,
        &apos;points&apos;: &apos;Pts&apos;,
        &apos;player rebounds&apos;: &apos;Reb&apos;,
        &apos;rebounds&apos;: &apos;Reb&apos;,
        &apos;player assists&apos;: &apos;Ast&apos;,
        &apos;assists&apos;: &apos;Ast&apos;,
        &apos;passing touchdowns&apos;: &apos;Pass TD&apos;,
        &apos;receiving yards&apos;: &apos;Rec Yds&apos;,
        &apos;moneyline&apos;: &apos;ML&apos;,
        &apos;player threes&apos;: &apos;3pt&apos;,
        &apos;to record a triple-double&apos;: &apos;TD&apos;,
        &apos;rushing yards&apos;: &apos;Rush Yds&apos;,
        &apos;anytime touchdown scorer&apos;: &apos;ATTD&apos;,
        &apos;home runs&apos;: &apos;HR&apos;,
        &apos;player home runs&apos;: &apos;HR&apos;,
        &apos;player strikeouts&apos;: &apos;Ks&apos;,
        &apos;strikeouts&apos;: &apos;Ks&apos;,
        &apos;player hits&apos;: &apos;Hits&apos;,
        &apos;hits&apos;: &apos;Hits&apos;,
        &apos;total points&apos;: &apos;Total&apos;,
        &apos;total goals&apos;: &apos;Total&apos;,
        &apos;run line&apos;: &apos;RL&apos;,
        &apos;spread&apos;: &apos;Sprd&apos;,
        &apos;passing yards&apos;: &apos;Pass Yds&apos;,
        &apos;outright winner&apos;: &apos;Future&apos;,
        &apos;to win outright&apos;: &apos;Future&apos;
    };
    return abbreviations[lowerMarket] || market;
};


// --- Editable Cell Components ---

const EditableCell: React.FC&lt;{ 
    value: string | number; 
    onSave: (newValue: string) =&gt; void; 
    type?: &apos;text&apos; | &apos;number&apos;;
    formatAsOdds?: boolean;
    suggestions?: string[];
    className?: string;
}&gt; = ({ value, onSave, type = &apos;text&apos;, formatAsOdds = false, suggestions = [], className = &apos;&apos; }) =&gt; {
    const [text, setText] = useState(value?.toString() || &apos;&apos;);
    const listId = useMemo(() =&gt; `suggestions-${Math.random()}`, []);

    // Update internal state if the external value prop changes
    React.useEffect(() =&gt; {
        setText(value?.toString() || &apos;&apos;);
    }, [value]);


    const handleBlur = () =&gt; {
        let formattedText = text;

        // Auto-format odds to add &apos;+&apos; for positive numbers if it&apos;s not there
        if (formatAsOdds &amp;&amp; type === &apos;number&apos; &amp;&amp; formattedText.match(/^[0-9]+(\.[0-9]+)?$/)) {
            // It&apos;s a positive number without a sign
            formattedText = `+${formattedText}`;
        }

        // Always update the visual state to the formatted version
        setText(formattedText);

        // Only call onSave if the final formatted value is different from the original prop
        if (value?.toString() !== formattedText) {
            onSave(formattedText);
        }
    };

    const handleKeyDown = (e: React.KeyboardEvent&lt;HTMLInputElement&gt;) =&gt; {
        if (e.key === &apos;Enter&apos;) {
            (e.target as HTMLInputElement).blur();
        } else if (e.key === &apos;Escape&apos;) {
            setText(value?.toString() || &apos;&apos;);
            (e.target as HTMLInputElement).blur();
        }
    };

    return (
        &lt;&gt;
            &lt;input
                type={type === &apos;number&apos; ? &apos;text&apos; : &apos;text&apos;} // Use text to allow for &apos;+&apos; sign
                inputMode={type === &apos;number&apos; ? &apos;decimal&apos; : &apos;text&apos;}
                value={text}
                onChange={(e) =&gt; setText(e.target.value)}
                onBlur={handleBlur}
                onKeyDown={handleKeyDown}
                className={`bg-transparent w-full p-0 m-0 border-none focus:ring-0 focus:outline-none focus:bg-neutral-100 dark:focus:bg-neutral-800 rounded text-sm ${className}`}
                placeholder=&quot;&quot;
                list={suggestions.length &gt; 0 ? listId : undefined}
            /&gt;
             {suggestions.length &gt; 0 &amp;&amp; (
                &lt;datalist id={listId}&gt;
                    {suggestions.map(s =&gt; &lt;option key={s} value={s} /&gt;)}
                &lt;/datalist&gt;
            )}
        &lt;/&gt;
    );
};

const ResultCell: React.FC&lt;{ value: BetResult, onSave: (newValue: BetResult) =&gt; void }&gt; = ({ value, onSave }) =&gt; {
    return (
        &lt;select
            value={value}
            onChange={(e) =&gt; onSave(e.target.value as BetResult)}
            className=&quot;bg-transparent w-full p-0 m-0 border-none focus:ring-0 focus:outline-none capitalize font-semibold rounded&quot;
        &gt;
            &lt;option value=&quot;win&quot;&gt;Win&lt;/option&gt;
            &lt;option value=&quot;loss&quot;&gt;Loss&lt;/option&gt;
            &lt;option value=&quot;push&quot;&gt;Push&lt;/option&gt;
            &lt;option value=&quot;pending&quot;&gt;Pending&lt;/option&gt;
        &lt;/select&gt;
    );
};

const OUCell: React.FC&lt;{
    value?: &apos;Over&apos; | &apos;Under&apos;;
    onSave: (newValue: &apos;Over&apos; | &apos;Under&apos; | undefined) =&gt; void;
}&gt; = ({ value, onSave }) =&gt; {
    const handleChange = (e: React.ChangeEvent&lt;HTMLSelectElement&gt;) =&gt; {
        const val = e.target.value;
        onSave(val === &apos;Over&apos; || val === &apos;Under&apos; ? val : undefined);
    };

    return (
        &lt;select
            value={value || &apos;none&apos;}
            onChange={handleChange}
            className=&quot;bg-transparent w-full p-0 m-0 border-none focus:ring-0 focus:outline-none capitalize font-semibold rounded text-center focus:bg-neutral-100 dark:focus:bg-neutral-800 appearance-none&quot;
        &gt;
            &lt;option value=&quot;none&quot;&gt;&lt;/option&gt;
            &lt;option value=&quot;Over&quot;&gt;O&lt;/option&gt;
            &lt;option value=&quot;Under&quot;&gt;U&lt;/option&gt;
        &lt;/select&gt;
    );
};


const BetTableView: React.FC = () =&gt; {
    const { bets, loading, updateBet } = useBets();
    const { sportsbooks, sports, betTypes, players, teams, addSport, addBetType, addPlayer, addTeam } = useInputs();
    const [searchTerm, setSearchTerm] = useState(&apos;&apos;);
    const [filters, setFilters] = useState&lt;{ sport: string | &apos;all&apos;; type: string | &apos;all&apos;; result: BetResult | &apos;all&apos;, category: MarketCategory | &apos;all&apos; }&gt;({
        sport: &apos;all&apos;,
        type: &apos;all&apos;,
        result: &apos;all&apos;,
        category: &apos;all&apos;,
    });
    const [sortConfig, setSortConfig] = useState&lt;{ key: keyof FlatBet; direction: &apos;asc&apos; | &apos;desc&apos; } | null&gt;({ key: &apos;date&apos;, direction: &apos;desc&apos; });
    
    const siteShortNameMap = useMemo(() =&gt; {
        return sportsbooks.reduce((acc, book) =&gt; {
            acc[book.name] = book.abbreviation;
            return acc;
        }, {} as Record&lt;SportsbookName, string&gt;);
    }, [sportsbooks]);

    const flattenedBets = useMemo(() =&gt; {
        const flatBets: FlatBet[] = [];
        bets.forEach(bet =&gt; {
            const isLive = bet.betType === &apos;live&apos;;
            
            // Calculate potential profit from stake and odds.
            const potentialProfit = calculateProfit(bet.stake, bet.odds);
            
            // &quot;To Win&quot; is the total potential payout (stake + profit).
            // For a push, the payout is just the stake.
            const toWin = bet.result === &apos;push&apos; ? bet.stake : bet.stake + potentialProfit;
            
            // &quot;Net&quot; is the actualized profit or loss.
            let net = 0;
            if (bet.result === &apos;win&apos;) {
                // For a win, the net profit is the calculated profit amount.
                net = potentialProfit;
            } else if (bet.result === &apos;loss&apos;) {
                net = -bet.stake; // For a loss, the net is the stake lost.
            }
            // For &apos;push&apos; or &apos;pending&apos;, net remains 0, which is correct.

            if (!bet.legs || bet.legs.length === 0) {
                // Handles single bets without leg data
                flatBets.push({
                    id: bet.id,
                    betId: bet.id,
                    date: bet.placedAt,
                    site: bet.book,
                    sport: bet.sport,
                    bet: bet.stake,
                    toWin: toWin,
                    net,
                    overallResult: bet.result,
                    type: isLive ? &apos;live&apos; : bet.betType,
                    category: bet.marketCategory,
                    name: bet.description,
                    ou: undefined,
                    line: undefined,
                    odds: bet.odds,
                    result: bet.result,
                    isLive,
                    tail: bet.tail,
                });
            } else {
                // Handles parlays, SGPs, and single bets with structured leg data
                bet.legs.forEach((leg, index) =&gt; {
                    flatBets.push({
                        id: `${bet.id}-leg-${index}`,
                        betId: bet.id,
                        date: bet.placedAt,
                        site: bet.book,
                        sport: bet.sport,
                        bet: bet.stake,
                        toWin: toWin, // Parlay payout is for the whole bet
                        net, // Parlay net is for the whole bet
                        overallResult: bet.result,
                        type: leg.market,
                        category: bet.marketCategory,
                        name: leg.entities?.join(&apos; / &apos;) || (bet.legs.length === 1 ? bet.description : &apos;N/A&apos;),
                        ou: leg.ou,
                        line: leg.target,
                        odds: bet.legs.length &gt; 1 ? leg.odds : bet.odds, // Show leg odds only for multi-leg bets
                        result: leg.result,
                        isLive,
                        tail: bet.tail,
                    });
                });
            }
        });
        return flatBets;
    }, [bets]);

    const handleLegUpdate = useCallback((betId: string, legIndex: number, updates: Partial&lt;BetLeg&gt;) =&gt; {
        const originalBet = bets.find(b =&gt; b.id === betId);
        if (!originalBet || !originalBet.legs || legIndex &gt;= originalBet.legs.length) return;

        const newLegs = originalBet.legs.map((leg, index) =&gt; {
            if (index === legIndex) {
                return { ...leg, ...updates };
            }
            return leg;
        });

        updateBet(betId, { legs: newLegs });
    }, [bets, updateBet]);

    // Very basic entity detection for auto-add
    const autoAddEntity = (sport: string, entity: string, market: string) =&gt; {
        const lowerMarket = market.toLowerCase();
        const teamMarketKeywords = [&apos;moneyline&apos;, &apos;ml&apos;, &apos;spread&apos;, &apos;total&apos;, &apos;run line&apos;, &apos;money line&apos;, &apos;outright winner&apos;, &apos;to win&apos;];
        const playerMarketKeywords = [&apos;player&apos;, &apos;prop&apos;, &apos;yards&apos;, &apos;points&apos;, &apos;rebounds&apos;, &apos;assists&apos;, &apos;touchdown&apos;, &apos;strikeouts&apos;, &apos;hits&apos;, &apos;goals&apos;, &apos;scorer&apos;, &apos;triple-double&apos;, &apos;threes&apos;];
        const isTeamMarket = teamMarketKeywords.some(keyword =&gt; lowerMarket.includes(keyword));
        const isPlayerMarket = playerMarketKeywords.some(keyword =&gt; lowerMarket.includes(keyword));

        if (isPlayerMarket &amp;&amp; !isTeamMarket) {
            addPlayer(sport, entity);
        } else if (isTeamMarket &amp;&amp; !isPlayerMarket) {
            addTeam(sport, entity);
        } else {
            const teamSports = [&apos;NFL&apos;, &apos;NBA&apos;, &apos;MLB&apos;, &apos;NHL&apos;, &apos;Soccer&apos;];
            if (teamSports.includes(sport)) {
                addTeam(sport, entity);
            } else {
                addPlayer(sport, entity);
            }
        }
    };


    const availableTypes = useMemo(() =&gt; {
        if (filters.sport === &apos;all&apos;) {
            return Array.from(new Set(Object.values(betTypes).flat())).sort();
        }
        return (betTypes[filters.sport] || []).sort();
    }, [betTypes, filters.sport]);
    
    const availableSites = useMemo(() =&gt; sportsbooks.map(b =&gt; b.name).sort(), [sportsbooks]);
    const suggestionLists = useMemo(() =&gt; ({
        sports: sports,
        sites: availableSites,
        categories: MARKET_CATEGORIES,
        types: (sport: string) =&gt; betTypes[sport] || [],
        players: (sport: string) =&gt; players[sport] || [],
        teams: (sport: string) =&gt; teams[sport] || [],
    }), [sports, availableSites, betTypes, players, teams]);


    const filteredBets = useMemo(() =&gt; {
        return flattenedBets
            .filter(bet =&gt;
                (filters.sport === &apos;all&apos; || bet.sport === filters.sport) &amp;&amp;
                (filters.type === &apos;all&apos; || bet.type === filters.type) &amp;&amp;
                (filters.result === &apos;all&apos; || bet.result === filters.result || bet.overallResult === filters.result) &amp;&amp;
                (filters.category === &apos;all&apos; || bet.category === filters.category) &amp;&amp;
                (searchTerm === &apos;&apos; || 
                 bet.name.toLowerCase().includes(searchTerm.toLowerCase()) || 
                 bet.type.toLowerCase().includes(searchTerm.toLowerCase()) ||
                 bet.category.toLowerCase().includes(searchTerm.toLowerCase()) ||
                 bet.tail?.toLowerCase().includes(searchTerm.toLowerCase())
                )
            );
    }, [flattenedBets, filters, searchTerm]);

    const sortedBets = useMemo(() =&gt; {
        let sortableBets = [...filteredBets];
        if (sortConfig !== null) {
            sortableBets.sort((a, b) =&gt; {
                const aValue = a[sortConfig.key];
                const bValue = b[sortConfig.key];
                
                if(sortConfig.key === &apos;date&apos;) {
                    return sortConfig.direction === &apos;asc&apos; ? 
                        new Date(aValue as string).getTime() - new Date(bValue as string).getTime() : 
                        new Date(bValue as string).getTime() - new Date(aValue as string).getTime();
                }

                if (aValue === undefined || aValue === null) return 1;
                if (bValue === undefined || bValue === null) return -1;
                
                if (aValue &lt; bValue) return sortConfig.direction === &apos;asc&apos; ? -1 : 1;
                if (aValue &gt; bValue) return sortConfig.direction === &apos;asc&apos; ? 1 : -1;
                return 0;
            });
        }
        return sortableBets;
    }, [filteredBets, sortConfig]);

    const requestSort = (key: keyof FlatBet) =&gt; {
        let direction: &apos;asc&apos; | &apos;desc&apos; = &apos;asc&apos;;
        if (sortConfig &amp;&amp; sortConfig.key === key &amp;&amp; sortConfig.direction === &apos;asc&apos;) {
            direction = &apos;desc&apos;;
        }
        setSortConfig({ key, direction });
    };

    const FilterControl: React.FC&lt;{ label: string; value: string; onChange: (e: React.ChangeEvent&lt;HTMLSelectElement&gt;) =&gt; void; options: string[] }&gt; = ({ label, value, onChange, options }) =&gt; (
        &lt;div&gt;
            &lt;label className=&quot;text-sm font-medium text-neutral-500 dark:text-neutral-400 mr-2&quot;&gt;{label}:&lt;/label&gt;
            &lt;select value={value} onChange={onChange} className=&quot;bg-white dark:bg-neutral-800 border border-neutral-300 dark:border-neutral-600 rounded-md p-1 text-sm&quot;&gt;
                &lt;option value=&quot;all&quot;&gt;All&lt;/option&gt;
                {options.map(o =&gt; &lt;option key={o} value={o}&gt;{o.charAt(0).toUpperCase() + o.slice(1)}&lt;/option&gt;)}
            &lt;/select&gt;
        &lt;/div&gt;
    );

    const headers: { key: keyof FlatBet; label: string; style: React.CSSProperties }[] = [
        { key: &apos;date&apos;, label: &apos;Date&apos;, style: { width: &apos;5%&apos; } },
        { key: &apos;site&apos;, label: &apos;Site&apos;, style: { width: &apos;4%&apos; } },
        { key: &apos;sport&apos;, label: &apos;Sport&apos;, style: { width: &apos;4%&apos; } },
        { key: &apos;category&apos;, label: &apos;Category&apos;, style: { width: &apos;8%&apos; } },
        { key: &apos;type&apos;, label: &apos;Type&apos;, style: { width: &apos;8%&apos; } },
        { key: &apos;name&apos;, label: &apos;Name&apos;, style: {} }, // Flexible width
        { key: &apos;ou&apos;, label: &apos;O/U&apos;, style: { width: &apos;4%&apos;, textAlign: &apos;center&apos; } },
        { key: &apos;line&apos;, label: &apos;Line&apos;, style: { width: &apos;4%&apos;, textAlign: &apos;center&apos; } },
        { key: &apos;odds&apos;, label: &apos;Odds&apos;, style: { width: &apos;5%&apos; } },
        { key: &apos;bet&apos;, label: &apos;Bet&apos;, style: { width: &apos;6%&apos; } },
        { key: &apos;toWin&apos;, label: &apos;To Win&apos;, style: { width: &apos;5%&apos; } },
        { key: &apos;result&apos;, label: &apos;Result&apos;, style: { width: &apos;7%&apos; } },
        { key: &apos;net&apos;, label: &apos;Net&apos;, style: { width: &apos;6%&apos; } },
        { key: &apos;isLive&apos;, label: &apos;Live&apos;, style: { width: &apos;3%&apos;, textAlign: &apos;center&apos; } },
        { key: &apos;tail&apos;, label: &apos;Tail&apos;, style: { width: &apos;8%&apos; } }
    ];

    const formatOdds = (odds: number | undefined): string =&gt; {
        if (odds === undefined || odds === null) return &apos;&apos;;
        if (odds &gt; 0) return `+${odds}`;
        return odds.toString();
    };

    return (
        &lt;div className=&quot;p-6 h-full flex flex-col space-y-4 bg-neutral-100 dark:bg-neutral-950&quot;&gt;
            &lt;header&gt;
                &lt;h1 className=&quot;text-3xl font-bold text-neutral-900 dark:text-white&quot;&gt;Bet Table&lt;/h1&gt;
                &lt;p className=&quot;text-neutral-500 dark:text-neutral-400 mt-1&quot;&gt;View, sort, and filter all your imported bets.&lt;/p&gt;
            &lt;/header&gt;

            &lt;div className=&quot;p-4 bg-white dark:bg-neutral-900 rounded-lg shadow-md flex items-center justify-between space-x-4&quot;&gt;
                &lt;input
                    type=&quot;text&quot;
                    placeholder=&quot;Search...&quot;
                    value={searchTerm}
                    onChange={e =&gt; setSearchTerm(e.target.value)}
                    className=&quot;flex-grow p-2 border border-neutral-300 dark:border-neutral-600 rounded-md bg-white dark:bg-neutral-800 placeholder-neutral-400 dark:placeholder-neutral-500&quot;
                /&gt;
                &lt;div className=&quot;flex items-center space-x-4&quot;&gt;
                    &lt;FilterControl label=&quot;Sport&quot; value={filters.sport} onChange={e =&gt; setFilters({ ...filters, sport: e.target.value as any, type: &apos;all&apos; })} options={sports} /&gt;
                    &lt;FilterControl label=&quot;Category&quot; value={filters.category} onChange={e =&gt; setFilters({ ...filters, category: e.target.value as any })} options={MARKET_CATEGORIES} /&gt;
                    &lt;FilterControl label=&quot;Type&quot; value={filters.type} onChange={e =&gt; setFilters({ ...filters, type: e.target.value as any })} options={availableTypes} /&gt;
                    &lt;FilterControl label=&quot;Result&quot; value={filters.result} onChange={e =&gt; setFilters({ ...filters, result: e.target.value as any })} options={[&apos;win&apos;, &apos;loss&apos;, &apos;push&apos;, &apos;pending&apos;]} /&gt;
                &lt;/div&gt;
            &lt;/div&gt;

            &lt;div className=&quot;flex-grow bg-white dark:bg-neutral-900 rounded-lg shadow-md overflow-auto&quot;&gt;
                &lt;table className=&quot;w-full text-sm text-left text-neutral-500 dark:text-neutral-400 table-fixed&quot;&gt;
                    &lt;thead className=&quot;text-xs text-neutral-700 uppercase bg-neutral-50 dark:bg-neutral-800 dark:text-neutral-400 sticky top-0 z-10&quot;&gt;
                        &lt;tr className=&quot;whitespace-nowrap&quot;&gt;
                            {headers.map(header =&gt; (
                                &lt;th key={header.key} scope=&quot;col&quot; className=&quot;px-2 py-3&quot; style={header.style}&gt;
                                    {header.label}
                                &lt;/th&gt;
                            ))}
                        &lt;/tr&gt;
                    &lt;/thead&gt;
                    &lt;tbody&gt;
                        {loading ? (
                            &lt;tr&gt;&lt;td colSpan={headers.length} className=&quot;text-center p-8&quot;&gt;Loading bets...&lt;/td&gt;&lt;/tr&gt;
                        ) : sortedBets.length === 0 ? (
                            &lt;tr&gt;&lt;td colSpan={headers.length} className=&quot;text-center p-8&quot;&gt;No bets found matching your criteria.&lt;/td&gt;&lt;/tr&gt;
                        ) : (
                            sortedBets.map(row =&gt; {
                                const isLeg = row.id.includes(&apos;-leg-&apos;);
                                const legIndex = isLeg ? parseInt(row.id.split(&apos;-leg-&apos;).pop()!, 10) : -1;
                                const net = row.net;
                                const resultColorClass = net &gt; 0 ? &apos;bg-accent-500/10&apos; : net &lt; 0 ? &apos;bg-danger-500/10&apos; : &apos;&apos;;
                                const netColorClass = net &gt; 0 ? &apos;text-accent-500&apos; : net &lt; 0 ? &apos;text-danger-500&apos; : &apos;&apos;;

                                return (
                                    &lt;tr key={row.id} className=&quot;border-b dark:border-neutral-800 hover:bg-neutral-100 dark:hover:bg-neutral-800/50 odd:bg-white dark:odd:bg-neutral-900 even:bg-neutral-50 dark:even:bg-neutral-800/50 whitespace-nowrap&quot;&gt;
                                        &lt;td className=&quot;px-2 py-2&quot;&gt;{formatDate(row.date)}&lt;/td&gt;
                                        &lt;td className=&quot;px-2 py-2 font-bold&quot;&gt;
                                            &lt;EditableCell
                                                value={siteShortNameMap[row.site] || row.site}
                                                onSave={(val) =&gt; {
                                                    const book = sportsbooks.find(b =&gt; b.name.toLowerCase() === val.toLowerCase() || b.abbreviation.toLowerCase() === val.toLowerCase());
                                                    updateBet(row.betId, { book: book ? book.name : val });
                                                }}
                                                suggestions={suggestionLists.sites}
                                            /&gt;
                                        &lt;/td&gt;
                                        &lt;td className=&quot;px-2 py-2&quot;&gt;
                                            &lt;EditableCell value={row.sport} onSave={(val) =&gt; { addSport(val); updateBet(row.betId, { sport: val }); }} suggestions={suggestionLists.sports} /&gt;
                                        &lt;/td&gt;
                                        &lt;td className=&quot;px-2 py-2&quot;&gt;
                                            &lt;EditableCell value={row.category} onSave={(val) =&gt; updateBet(row.betId, { marketCategory: val as MarketCategory })} suggestions={suggestionLists.categories} /&gt;
                                        &lt;/td&gt;
                                        &lt;td className=&quot;px-2 py-2 capitalize&quot;&gt;
                                            &lt;EditableCell
                                                value={row.type}
                                                onSave={(val) =&gt; {
                                                    if (isLeg) {
                                                        addBetType(row.sport, val);
                                                        handleLegUpdate(row.betId, legIndex, { market: val });
                                                    } else {
                                                        updateBet(row.betId, { betType: val as BetType });
                                                    }
                                                }}
                                                suggestions={isLeg ? suggestionLists.types(row.sport) : [&apos;single&apos;, &apos;parlay&apos;, &apos;sgp&apos;, &apos;live&apos;, &apos;other&apos;]}
                                            /&gt;
                                        &lt;/td&gt;
                                        &lt;td className=&quot;px-2 py-2 font-medium text-neutral-900 dark:text-white truncate&quot;&gt;
                                            &lt;EditableCell value={row.name} onSave={(val) =&gt; {
                                                if (isLeg) {
                                                    autoAddEntity(row.sport, val, row.type);
                                                    handleLegUpdate(row.betId, legIndex, { entities: [val] });
                                                } else {
                                                    autoAddEntity(row.sport, val, row.type);
                                                    updateBet(row.betId, { description: val });
                                                }
                                            }} suggestions={[...suggestionLists.players(row.sport), ...suggestionLists.teams(row.sport)]}/&gt;
                                        &lt;/td&gt;
                                        &lt;td className=&quot;px-2 py-2 text-center&quot;&gt;
                                            {isLeg ? (
                                                &lt;OUCell value={row.ou} onSave={(val) =&gt; handleLegUpdate(row.betId, legIndex, { ou: val })} /&gt;
                                            ) : (
                                                row.ou ? row.ou[0] : &apos;&apos;
                                            )}
                                        &lt;/td&gt;
                                        &lt;td className=&quot;px-2 py-2 text-center&quot;&gt;
                                            &lt;EditableCell value={row.line || &apos;&apos;} type=&quot;text&quot; onSave={(val) =&gt; {
                                                if (isLeg) {
                                                    handleLegUpdate(row.betId, legIndex, { target: val });
                                                }
                                            }} /&gt;
                                        &lt;/td&gt;
                                        &lt;td className=&quot;px-2 py-2&quot;&gt;
                                             &lt;EditableCell
                                                value={formatOdds(row.odds)}
                                                type=&quot;number&quot;
                                                formatAsOdds={true}
                                                onSave={(val) =&gt; {
                                                    const numVal = parseInt(val.replace(&apos;+&apos;, &apos;&apos;), 10);
                                                    if (!isNaN(numVal)) {
                                                        // Always update the main bet&apos;s odds, which drives the &quot;To Win&quot; calculation.
                                                        updateBet(row.betId, { odds: numVal });
                                                    }
                                                }}
                                            /&gt;
                                        &lt;/td&gt;
                                        &lt;td className=&quot;px-2 py-2&quot;&gt;
                                             &lt;div className=&quot;relative&quot;&gt;
                                                &lt;span className=&quot;absolute left-2 top-1/2 -translate-y-1/2 text-neutral-400 pointer-events-none&quot;&gt;$&lt;/span&gt;
                                                &lt;EditableCell value={row.bet.toFixed(2)} type=&quot;number&quot; onSave={(val) =&gt; {
                                                    const numVal = parseFloat(val);
                                                    if (!isNaN(numVal)) updateBet(row.betId, { stake: numVal });
                                                }} className=&quot;pl-5&quot; /&gt;
                                            &lt;/div&gt;
                                        &lt;/td&gt;
                                        &lt;td className=&quot;px-2 py-2&quot;&gt;${row.toWin.toFixed(2)}&lt;/td&gt;
                                        &lt;td className={`px-2 py-2 capitalize ${resultColorClass}`}&gt;
                                            &lt;div className={net &gt; 0 ? &apos;text-accent-600 dark:text-accent-400&apos; : net &lt; 0 ? &apos;text-danger-600 dark:text-danger-400&apos; : &apos;&apos;}&gt;
                                                 &lt;ResultCell value={isLeg ? row.result : row.overallResult} onSave={(val) =&gt; {
                                                     if (isLeg) {
                                                         handleLegUpdate(row.betId, legIndex, { result: val });
                                                     } else {
                                                         updateBet(row.betId, { result: val });
                                                     }
                                                 }}/&gt;
                                            &lt;/div&gt;
                                        &lt;/td&gt;
                                        &lt;td className={`px-2 py-2 font-bold ${resultColorClass} ${netColorClass}`}&gt;{net &lt; 0 ? &apos;-&apos; : &apos;&apos;}${Math.abs(net).toFixed(2)}&lt;/td&gt;
                                        &lt;td className=&quot;px-2 py-2 text-center&quot;&gt;
                                            {row.isLive &amp;&amp; &lt;Wifi className=&quot;w-5 h-5 text-primary-500 mx-auto&quot; title=&quot;Live Bet&quot;/&gt;}
                                        &lt;/td&gt;
                                        &lt;td className=&quot;px-2 py-2&quot;&gt;
                                            &lt;EditableCell
                                                value={row.tail || &apos;&apos;}
                                                onSave={(newValue) =&gt; {
                                                    updateBet(row.betId, { tail: newValue });
                                                }}
                                            /&gt;
                                        &lt;/td&gt;
                                    &lt;/tr&gt;
                                )
                            })
                        )}
                    &lt;/tbody&gt;
                &lt;/table&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    );
};

export default BetTableView;</file><file path="views/BySportView.tsx">import React, { useMemo, useState } from &apos;react&apos;;
import { useBets } from &apos;../hooks/useBets&apos;;
import { useInputs } from &apos;../hooks/useInputs&apos;;
import { BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer, LineChart, Line, PieChart, Pie, Cell, Sector } from &apos;recharts&apos;;
import { TrendingUp, TrendingDown, Scale, BarChart2, Trophy } from &apos;../components/icons&apos;;
import { Bet, BetResult } from &apos;../types&apos;;

// --- HELPER FUNCTIONS &amp; COMPONENTS ---

const CustomTooltip = ({ active, payload, label }: any) =&gt; {
    if (active &amp;&amp; payload &amp;&amp; payload.length) {
        return (
            &lt;div className=&quot;bg-white dark:bg-neutral-800 p-2 border border-neutral-300 dark:border-neutral-600 rounded shadow-lg text-sm&quot;&gt;
                &lt;p className=&quot;label font-bold mb-1&quot;&gt;{`${label}`}&lt;/p&gt;
                {payload.map((pld: any, index: number) =&gt; (
                    &lt;p key={index} style={{ color: pld.color || pld.fill }}&gt;
                        {`${pld.name}: ${typeof pld.value === &apos;number&apos; ? pld.value.toFixed(2) : pld.value}`}
                    &lt;/p&gt;
                ))}
            &lt;/div&gt;
        );
    }
    return null;
};

const ChartContainer: React.FC&lt;{ title: string; children: React.ReactNode }&gt; = ({ title, children }) =&gt; (
    &lt;div className=&quot;bg-white dark:bg-neutral-900 rounded-lg shadow-md p-6&quot;&gt;
        &lt;h2 className=&quot;text-xl font-semibold mb-4 text-neutral-800 dark:text-neutral-200&quot;&gt;{title}&lt;/h2&gt;
        &lt;div className=&quot;h-72&quot;&gt;{children}&lt;/div&gt;
    &lt;/div&gt;
);

const StatCard: React.FC&lt;{ title: string; value: string; icon: React.ReactNode; change?: string; }&gt; = ({ title, value, icon, change }) =&gt; {
    const isPositive = change &amp;&amp; parseFloat(change) &gt; 0;
    const isNegative = change &amp;&amp; parseFloat(change) &lt; 0;
    const changeColor = isPositive ? &apos;text-accent-500&apos; : isNegative ? &apos;text-danger-500&apos; : &apos;text-neutral-500 dark:text-neutral-400&apos;;

    return (
        &lt;div className=&quot;bg-white dark:bg-neutral-900 p-6 rounded-lg shadow-md flex items-start justify-between&quot;&gt;
            &lt;div&gt;
                &lt;p className=&quot;text-sm font-medium text-neutral-500 dark:text-neutral-400 uppercase&quot;&gt;{title}&lt;/p&gt;
                &lt;p className=&quot;text-3xl font-bold text-neutral-900 dark:text-white mt-1&quot;&gt;{value}&lt;/p&gt;
                {change &amp;&amp; (
                    &lt;p className={`text-sm font-semibold flex items-center mt-2 ${changeColor}`}&gt;
                        {isPositive &amp;&amp; &lt;TrendingUp className=&quot;w-4 h-4 mr-1&quot; /&gt;}
                        {isNegative &amp;&amp; &lt;TrendingDown className=&quot;w-4 h-4 mr-1&quot; /&gt;}
                        {change}
                    &lt;/p&gt;
                )}
            &lt;/div&gt;
            &lt;div className=&quot;bg-primary-100 dark:bg-primary-900/50 text-primary-600 dark:text-primary-400 p-3 rounded-full&quot;&gt;
                {icon}
            &lt;/div&gt;
        &lt;/div&gt;
    );
};


type StatsData = { name: string; count: number; wins: number; losses: number; stake: number; net: number; roi: number; sport?: string };
interface StatsTableProps {
    data: StatsData[];
    title: string;
    searchPlaceholder: string;
    className?: string;
    children?: React.ReactNode;
}

const StatsTable: React.FC&lt;StatsTableProps&gt; = ({ data, title, searchPlaceholder, className, children }) =&gt; {
    const [searchTerm, setSearchTerm] = useState(&apos;&apos;);
    const [sortConfig, setSortConfig] = useState&lt;{ key: keyof StatsData; direction: &apos;asc&apos; | &apos;desc&apos; }&gt;({ key: &apos;net&apos;, direction: &apos;desc&apos; });
    
    const sortedData = useMemo(() =&gt; {
        const filtered = data.filter(item =&gt; item.name.toLowerCase().includes(searchTerm.toLowerCase()));
        return [...filtered].sort((a, b) =&gt; {
            if (a[sortConfig.key] &lt; b[sortConfig.key]) return sortConfig.direction === &apos;asc&apos; ? -1 : 1;
            if (a[sortConfig.key] &gt; b[sortConfig.key]) return sortConfig.direction === &apos;asc&apos; ? 1 : -1;
            return 0;
        });
    }, [data, searchTerm, sortConfig]);

    const requestSort = (key: keyof StatsData) =&gt; {
        let direction: &apos;asc&apos; | &apos;desc&apos; = &apos;asc&apos;;
        if (sortConfig.key === key &amp;&amp; sortConfig.direction === &apos;asc&apos;) {
            direction = &apos;desc&apos;;
        }
        setSortConfig({ key, direction });
    };

    return (
        &lt;div className={`bg-white dark:bg-neutral-900 rounded-lg shadow-md p-6 flex flex-col ${className}`}&gt;
             &lt;div className=&quot;flex justify-between items-center&quot;&gt;
                &lt;h2 className=&quot;text-xl font-semibold text-neutral-800 dark:text-neutral-200&quot;&gt;{title}&lt;/h2&gt;
                {children}
            &lt;/div&gt;
            &lt;input
                type=&quot;text&quot;
                placeholder={searchPlaceholder}
                value={searchTerm}
                onChange={e =&gt; setSearchTerm(e.target.value)}
                className=&quot;my-4 p-2 border border-neutral-300 dark:border-neutral-700 rounded-md bg-neutral-50 dark:bg-neutral-800 w-full&quot;
            /&gt;
            &lt;div className=&quot;overflow-y-auto flex-grow&quot;&gt;
                &lt;table className=&quot;w-full text-sm text-left&quot;&gt;
                    &lt;thead className=&quot;text-xs text-neutral-500 dark:text-neutral-400 uppercase sticky top-0 bg-white dark:bg-neutral-900&quot;&gt;
                        &lt;tr&gt;
                            &lt;th className=&quot;px-4 py-2 cursor-pointer&quot; onClick={() =&gt; requestSort(&apos;name&apos;)}&gt;
                                {searchPlaceholder.split(&apos; &apos;)[1]} {sortConfig.key === &apos;name&apos; ? (sortConfig.direction === &apos;desc&apos; ? &apos;&apos; : &apos;&apos;) : &apos;&apos;}
                            &lt;/th&gt;
                            &lt;th className=&quot;px-4 py-2 cursor-pointer text-center&quot; onClick={() =&gt; requestSort(&apos;count&apos;)}&gt;
                                # Bets {sortConfig.key === &apos;count&apos; ? (sortConfig.direction === &apos;desc&apos; ? &apos;&apos; : &apos;&apos;) : &apos;&apos;}
                            &lt;/th&gt;
                            &lt;th className=&quot;px-4 py-2 cursor-pointer text-center&quot; onClick={() =&gt; requestSort(&apos;wins&apos;)}&gt;Win {sortConfig.key === &apos;wins&apos; ? (sortConfig.direction === &apos;desc&apos; ? &apos;&apos; : &apos;&apos;) : &apos;&apos;}&lt;/th&gt;
                            &lt;th className=&quot;px-4 py-2 cursor-pointer text-center&quot; onClick={() =&gt; requestSort(&apos;losses&apos;)}&gt;Loss {sortConfig.key === &apos;losses&apos; ? (sortConfig.direction === &apos;desc&apos; ? &apos;&apos; : &apos;&apos;) : &apos;&apos;}&lt;/th&gt;
                            &lt;th className=&quot;px-4 py-2 text-center&quot;&gt;Win %&lt;/th&gt;
                            &lt;th className=&quot;px-4 py-2 cursor-pointer&quot; onClick={() =&gt; requestSort(&apos;stake&apos;)}&gt;
                                Wagered {sortConfig.key === &apos;stake&apos; ? (sortConfig.direction === &apos;desc&apos; ? &apos;&apos; : &apos;&apos;) : &apos;&apos;}
                            &lt;/th&gt;
                            &lt;th className=&quot;px-4 py-2 cursor-pointer&quot; onClick={() =&gt; requestSort(&apos;net&apos;)}&gt;
                                Net {sortConfig.key === &apos;net&apos; ? (sortConfig.direction === &apos;desc&apos; ? &apos;&apos; : &apos;&apos;) : &apos;&apos;}
                            &lt;/th&gt;
                            &lt;th className=&quot;px-4 py-2 cursor-pointer&quot; onClick={() =&gt; requestSort(&apos;roi&apos;)}&gt;
                                ROI {sortConfig.key === &apos;roi&apos; ? (sortConfig.direction === &apos;desc&apos; ? &apos;&apos; : &apos;&apos;) : &apos;&apos;}
                            &lt;/th&gt;
                        &lt;/tr&gt;
                    &lt;/thead&gt;
                    &lt;tbody className=&quot;divide-y divide-neutral-200 dark:divide-neutral-800&quot;&gt;
                        {sortedData.map(item =&gt; {
                            const netColor = item.net &gt; 0 ? &apos;text-accent-500&apos; : item.net &lt; 0 ? &apos;text-danger-500&apos; : &apos;text-neutral-500&apos;;
                            const winPct = item.wins + item.losses &gt; 0 ? (item.wins / (item.wins + item.losses)) * 100 : 0;
                            const winPctColor = winPct &gt; 50 ? &apos;text-accent-500&apos; : winPct &lt; 50 &amp;&amp; (item.wins + item.losses &gt; 0) ? &apos;text-danger-500&apos; : &apos;text-neutral-500&apos;;
                            
                            return (
                                &lt;tr key={item.sport ? `${item.sport}-${item.name}` : item.name} className=&quot;odd:bg-white dark:odd:bg-neutral-900 even:bg-neutral-50 dark:even:bg-neutral-800/50 hover:bg-neutral-100 dark:hover:bg-neutral-800&quot;&gt;
                                    &lt;td className=&quot;px-4 py-2 font-medium text-neutral-900 dark:text-neutral-100 truncate max-w-xs&quot;&gt;{item.name}&lt;/td&gt;
                                    &lt;td className=&quot;px-4 py-2 text-center&quot;&gt;{item.count}&lt;/td&gt;
                                    &lt;td className=&quot;px-4 py-2 text-center&quot;&gt;{item.wins}&lt;/td&gt;
                                    &lt;td className=&quot;px-4 py-2 text-center&quot;&gt;{item.losses}&lt;/td&gt;
                                    &lt;td className={`px-4 py-2 text-center font-semibold ${winPctColor}`}&gt;{winPct.toFixed(1)}%&lt;/td&gt;
                                    &lt;td className=&quot;px-4 py-2&quot;&gt;${item.stake.toFixed(2)}&lt;/td&gt;
                                    &lt;td className={`px-4 py-2 font-semibold ${netColor}`}&gt;{item.net.toFixed(2)}&lt;/td&gt;
                                    &lt;td className={`px-4 py-2 font-semibold ${netColor}`}&gt;{item.roi.toFixed(1)}%&lt;/td&gt;
                                &lt;/tr&gt;
                            )
                        })}
                    &lt;/tbody&gt;
                &lt;/table&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    );
};

const extractEntityFromDescription = (description: string): string =&gt; {
    const patterns = [
        /^(.*?)\s+([+-]\d+(\.\d+)?|ML|PK|pk)$/i, 
        /^(.*?)\s+(?:to win|To Win|to Win Outright)/i,
        /^(.*?)\s+(?:Over|Under|O|U)\s+\d+(\.\d+)?/i,
    ];
    for (const pattern of patterns) {
        const match = description.match(pattern);
        if (match &amp;&amp; match[1]) return match[1].trim();
    }
    return description;
};

const ToggleButton: React.FC&lt;{
  value: string;
  label: string;
  currentValue: string;
  onClick: (value: string) =&gt; void;
}&gt; = ({ value, label, currentValue, onClick }) =&gt; (
  &lt;button
    onClick={() =&gt; onClick(value)}
    className={`px-2.5 py-1 rounded-md font-medium text-xs transition-colors ${
      currentValue === value
        ? &apos;bg-primary-600 text-white shadow&apos;
        : &apos;text-neutral-600 dark:text-neutral-300 bg-neutral-100 dark:bg-neutral-800 hover:bg-neutral-200 dark:hover:bg-neutral-700&apos;
    }`}
  &gt;
    {label}
  &lt;/button&gt;
);

const OverUnderBreakdown: React.FC&lt;{ bets: Bet[] }&gt; = ({ bets }) =&gt; {
    const [filter, setFilter] = useState&lt;&apos;props&apos; | &apos;totals&apos; | &apos;all&apos;&gt;(&apos;all&apos;);

    const data = useMemo(() =&gt; {
        const filteredBets = bets.filter(bet =&gt; {
            if (filter === &apos;props&apos;) return bet.marketCategory === &apos;Props&apos;;
            if (filter === &apos;totals&apos;) return bet.marketCategory === &apos;Main Markets&apos;;
            return bet.marketCategory === &apos;Props&apos; || bet.marketCategory === &apos;Main Markets&apos;;
        });

        const stats = { 
            over: { count: 0, wins: 0, losses: 0, stake: 0, net: 0 }, 
            under: { count: 0, wins: 0, losses: 0, stake: 0, net: 0 }
        };

        filteredBets.forEach(bet =&gt; {
            if (bet.legs?.length) {
                bet.legs.forEach(leg =&gt; {
                    if (leg.ou) {
                        const ou = leg.ou.toLowerCase() as &apos;over&apos; | &apos;under&apos;;
                        const net = bet.payout - bet.stake;
                        stats[ou].count++; 
                        stats[ou].stake += bet.stake; 
                        stats[ou].net += net;
                        if (bet.result === &apos;win&apos;) stats[ou].wins++; 
                        if (bet.result === &apos;loss&apos;) stats[ou].losses++;
                    }
                });
            }
        });

        const calculateRoi = (s: { stake: number, net: number }) =&gt; s.stake &gt; 0 ? (s.net / s.stake) * 100 : 0;
        
        return { 
            over: {...stats.over, roi: calculateRoi(stats.over)}, 
            under: {...stats.under, roi: calculateRoi(stats.under)}
        };
    }, [bets, filter]);

    const pieData = [
        { name: &apos;Over&apos;, value: data.over.count, color: &apos;#8b5cf6&apos; },
        { name: &apos;Under&apos;, value: data.under.count, color: &apos;#6d28d9&apos; }
    ].filter(d =&gt; d.value &gt; 0);

    const StatCard = ({ title, stats, color }: { title: string; stats: any; color: string }) =&gt; {
        const netColor = stats.net &gt; 0 ? &apos;text-accent-500&apos; : stats.net &lt; 0 ? &apos;text-danger-500&apos; : &apos;&apos;;
        const NetIcon = stats.net &gt; 0 ? TrendingUp : TrendingDown;
        const winPct = stats.wins + stats.losses &gt; 0 ? (stats.wins / (stats.wins + stats.losses)) * 100 : 0;
        return (
            &lt;div className=&quot;p-4 rounded-lg bg-neutral-100 dark:bg-neutral-800/50 flex-1&quot;&gt;
                &lt;h4 className=&quot;font-bold text-lg&quot; style={{ color }}&gt;{title}&lt;/h4&gt;
                &lt;div className=&quot;text-sm mt-2 space-y-1 text-neutral-600 dark:text-neutral-300&quot;&gt;
                    &lt;p&gt;&lt;b&gt;Bets:&lt;/b&gt; {stats.count}&lt;/p&gt;
                    &lt;p&gt;&lt;b&gt;W/L:&lt;/b&gt; {stats.wins}-{stats.losses}&lt;/p&gt;
                    &lt;p&gt;&lt;b&gt;Win %:&lt;/b&gt; {winPct.toFixed(1)}%&lt;/p&gt;
                    &lt;p className={`flex items-center ${netColor}`}&gt;&lt;b&gt;Net:&lt;/b&gt;&lt;NetIcon className=&quot;w-4 h-4 mx-1&quot;/&gt; ${stats.net.toFixed(2)}&lt;/p&gt;
                    &lt;p className={netColor}&gt;&lt;b&gt;ROI:&lt;/b&gt; {stats.roi.toFixed(1)}%&lt;/p&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        )
    };
    
    return (
        &lt;div className=&quot;bg-white dark:bg-neutral-900 rounded-lg shadow-md p-6 h-full flex flex-col&quot;&gt;
            &lt;div className=&quot;flex justify-between items-center mb-4&quot;&gt;
                &lt;h2 className=&quot;text-xl font-semibold text-neutral-800 dark:text-neutral-200&quot;&gt;Over vs. Under&lt;/h2&gt;
                &lt;div className=&quot;flex items-center space-x-1 flex-wrap gap-y-2 bg-neutral-100 dark:bg-neutral-800/50 p-1 rounded-lg&quot;&gt;
                    &lt;ToggleButton value=&quot;props&quot; label=&quot;Props&quot; currentValue={filter} onClick={(v) =&gt; setFilter(v as any)} /&gt;
                    &lt;ToggleButton value=&quot;totals&quot; label=&quot;Totals&quot; currentValue={filter} onClick={(v) =&gt; setFilter(v as any)} /&gt;
                    &lt;ToggleButton value=&quot;all&quot; label=&quot;All&quot; currentValue={filter} onClick={(v) =&gt; setFilter(v as any)} /&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            &lt;div className=&quot;h-40&quot;&gt;
                &lt;ResponsiveContainer width=&quot;100%&quot; height=&quot;100%&quot;&gt;
                    &lt;PieChart&gt;
                        &lt;Pie data={pieData} dataKey=&quot;value&quot; nameKey=&quot;name&quot; cx=&quot;50%&quot; cy=&quot;50%&quot; outerRadius={60} label={({ name, percent }) =&gt; `${name} ${(percent * 100).toFixed(0)}%`}&gt;
                            {pieData.map((entry) =&gt; &lt;Cell key={`cell-${entry.name}`} fill={entry.color} /&gt;)}
                        &lt;/Pie&gt;
                        &lt;Tooltip /&gt;
                    &lt;/PieChart&gt;
                &lt;/ResponsiveContainer&gt;
            &lt;/div&gt;
            &lt;div className=&quot;flex gap-4 mt-4&quot;&gt;
                &lt;StatCard title=&quot;Over&quot; stats={data.over} color={pieData.find(d =&gt; d.name === &apos;Over&apos;)?.color || &apos;#8b5cf6&apos;} /&gt;
                &lt;StatCard title=&quot;Under&quot; stats={data.under} color={pieData.find(d =&gt; d.name === &apos;Under&apos;)?.color || &apos;#6d28d9&apos;} /&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    );
}


const LiveVsPreMatchBreakdown: React.FC&lt;{ bets: Bet[] }&gt; = ({ bets }) =&gt; {
    const [filter, setFilter] = useState&lt;&apos;all&apos; | &apos;props&apos; | &apos;main&apos;&gt;(&apos;all&apos;);

    const data = useMemo(() =&gt; {
        const filteredBets = bets.filter(bet =&gt; {
            if (filter === &apos;props&apos;) return bet.marketCategory === &apos;Props&apos;;
            if (filter === &apos;main&apos;) return bet.marketCategory === &apos;Main Markets&apos;;
            return true; // all
        });
        
        const stats = { 
            live: { count: 0, wins: 0, losses: 0, stake: 0, net: 0 }, 
            preMatch: { count: 0, wins: 0, losses: 0, stake: 0, net: 0 }
        };

        filteredBets.forEach(bet =&gt; {
            const result = bet.result;
            const net = bet.payout - bet.stake;
            const liveTarget = bet.betType === &apos;live&apos; ? stats.live : stats.preMatch;
            liveTarget.count++; 
            liveTarget.stake += bet.stake; 
            liveTarget.net += net;
            if (result === &apos;win&apos;) liveTarget.wins++; 
            if (result === &apos;loss&apos;) liveTarget.losses++;
        });

        const calculateRoi = (s: { stake: number, net: number }) =&gt; s.stake &gt; 0 ? (s.net / s.stake) * 100 : 0;
        
        return { 
            live: {...stats.live, roi: calculateRoi(stats.live)}, 
            preMatch: {...stats.preMatch, roi: calculateRoi(stats.preMatch)}
        };
    }, [bets, filter]);

    const pieData = [
        { name: &apos;Pre-Match&apos;, value: data.preMatch.count, color: &apos;#4c1d95&apos; },
        { name: &apos;Live&apos;, value: data.live.count, color: &apos;#a78bfa&apos; }
    ].filter(d =&gt; d.value &gt; 0);

    const StatCard = ({ title, stats, color }: { title: string, stats: any, color: string }) =&gt; {
        const netColor = stats.net &gt; 0 ? &apos;text-accent-500&apos; : stats.net &lt; 0 ? &apos;text-danger-500&apos; : &apos;&apos;;
        const NetIcon = stats.net &gt; 0 ? TrendingUp : TrendingDown;
        const winPct = stats.wins + stats.losses &gt; 0 ? (stats.wins / (stats.wins + stats.losses)) * 100 : 0;
        return (
            &lt;div className=&quot;p-4 rounded-lg bg-neutral-100 dark:bg-neutral-800/50 flex-1&quot;&gt;
                &lt;h4 className=&quot;font-bold text-lg&quot; style={{ color }}&gt;{title}&lt;/h4&gt;
                &lt;div className=&quot;text-sm mt-2 space-y-1 text-neutral-600 dark:text-neutral-300&quot;&gt;
                    &lt;p&gt;&lt;b&gt;Bets:&lt;/b&gt; {stats.count}&lt;/p&gt;
                    &lt;p&gt;&lt;b&gt;W/L:&lt;/b&gt; {stats.wins}-{stats.losses}&lt;/p&gt;
                    &lt;p&gt;&lt;b&gt;Win %:&lt;/b&gt; {winPct.toFixed(1)}%&lt;/p&gt;
                    &lt;p className={`flex items-center ${netColor}`}&gt;&lt;b&gt;Net:&lt;/b&gt;&lt;NetIcon className=&quot;w-4 h-4 mx-1&quot;/&gt; ${stats.net.toFixed(2)}&lt;/p&gt;
                    &lt;p className={netColor}&gt;&lt;b&gt;ROI:&lt;/b&gt; {stats.roi.toFixed(1)}%&lt;/p&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        )
    };
    
    return (
        &lt;div className=&quot;bg-white dark:bg-neutral-900 rounded-lg shadow-md p-6 h-full flex flex-col&quot;&gt;
            &lt;div className=&quot;flex justify-between items-center mb-4&quot;&gt;
                &lt;h2 className=&quot;text-xl font-semibold text-neutral-800 dark:text-neutral-200&quot;&gt;Live vs. Pre-Match&lt;/h2&gt;
                &lt;div className=&quot;flex items-center space-x-1 flex-wrap gap-y-2 bg-neutral-100 dark:bg-neutral-800/50 p-1 rounded-lg&quot;&gt;
                    &lt;ToggleButton value=&quot;props&quot; label=&quot;Props&quot; currentValue={filter} onClick={(v) =&gt; setFilter(v as any)} /&gt;
                    &lt;ToggleButton value=&quot;main&quot; label=&quot;Main Markets&quot; currentValue={filter} onClick={(v) =&gt; setFilter(v as any)} /&gt;
                    &lt;ToggleButton value=&quot;all&quot; label=&quot;All&quot; currentValue={filter} onClick={(v) =&gt; setFilter(v as any)} /&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            &lt;div className=&quot;h-40&quot;&gt;
                &lt;ResponsiveContainer width=&quot;100%&quot; height=&quot;100%&quot;&gt;
                    &lt;PieChart&gt;
                        &lt;Pie data={pieData} dataKey=&quot;value&quot; nameKey=&quot;name&quot; cx=&quot;50%&quot; cy=&quot;50%&quot; outerRadius={60} label={({ name, percent }) =&gt; `${name} ${(percent * 100).toFixed(0)}%`}&gt;
                            {pieData.map((entry) =&gt; &lt;Cell key={`cell-${entry.name}`} fill={entry.color} /&gt;)}
                        &lt;/Pie&gt;
                        &lt;Tooltip /&gt;
                    &lt;/PieChart&gt;
                &lt;/ResponsiveContainer&gt;
            &lt;/div&gt;
            &lt;div className=&quot;flex gap-4 mt-4&quot;&gt;
                &lt;StatCard title=&quot;Pre-Match&quot; stats={data.preMatch} color={pieData.find(d=&gt;d.name===&apos;Pre-Match&apos;)?.color || &apos;#4c1d95&apos;} /&gt;
                &lt;StatCard title=&quot;Live&quot; stats={data.live} color={pieData.find(d=&gt;d.name===&apos;Live&apos;)?.color || &apos;#a78bfa&apos;} /&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    );
}

type DateRange = &apos;all&apos; | &apos;1d&apos; | &apos;3d&apos; | &apos;1w&apos; | &apos;1m&apos; | &apos;1y&apos; | &apos;custom&apos;;

const DateRangeButton: React.FC&lt;{
  range: DateRange;
  label: string;
  currentRange: DateRange;
  onClick: (range: DateRange) =&gt; void;
}&gt; = ({ range, label, currentRange, onClick }) =&gt; (
  &lt;button
    onClick={() =&gt; onClick(range)}
    className={`px-3 py-1.5 rounded-md font-medium text-xs transition-colors ${
      currentRange === range
        ? &apos;bg-primary-600 text-white shadow&apos;
        : &apos;text-neutral-600 dark:text-neutral-300 hover:bg-white dark:hover:bg-neutral-700&apos;
    }`}
  &gt;
    {label}
  &lt;/button&gt;
);


const BySportView: React.FC = () =&gt; {
    const { bets, loading } = useBets();
    const { sports, players, teams } = useInputs();
    const [selectedSport, setSelectedSport] = useState&lt;string&gt;(sports[0] || &apos;&apos;);
    const [dateRange, setDateRange] = useState&lt;DateRange&gt;(&apos;all&apos;);
    const [customDateRange, setCustomDateRange] = useState&lt;{ start: string; end: string }&gt;({ start: &apos;&apos;, end: &apos;&apos; });
    const [entityType, setEntityType] = useState&lt;&apos;all&apos; | &apos;player&apos; | &apos;team&apos;&gt;(&apos;all&apos;);
    
    const allPlayers = useMemo(() =&gt; new Set(Object.values(players).flat()), [players]);
    const allTeams = useMemo(() =&gt; new Set(Object.values(teams).flat()), [teams]);

    const availableSports = useMemo(() =&gt; {
        if (loading) return [];
        const sports = new Set(bets.map(bet =&gt; bet.sport));
        return [...Array.from(sports).sort()];
    }, [bets, loading]);
    
    // Set default sport once available
    useState(() =&gt; {
        if(availableSports.length &gt; 0) {
            setSelectedSport(availableSports[0]);
        }
    });

    const filteredBets = useMemo(() =&gt; {
        let betsToFilter = bets.filter(bet =&gt; bet.sport === selectedSport);

        if (dateRange !== &apos;all&apos;) {
            if (dateRange === &apos;custom&apos;) {
                const customStart = customDateRange.start ? new Date(`${customDateRange.start}T00:00:00.000Z`) : null;
                const customEnd = customDateRange.end ? new Date(`${customDateRange.end}T23:59:59.999Z`) : null;
                
                betsToFilter = betsToFilter.filter(bet =&gt; {
                    const betDate = new Date(bet.placedAt);
                    if (customStart &amp;&amp; betDate &lt; customStart) return false;
                    if (customEnd &amp;&amp; betDate &gt; customEnd) return false;
                    return true;
                });
            } else {
                let startDate: Date;
                const now = new Date();
                switch (dateRange) {
                    case &apos;1d&apos;: startDate = new Date(now.getTime() - 1 * 24 * 60 * 60 * 1000); break;
                    case &apos;3d&apos;: startDate = new Date(now.getTime() - 3 * 24 * 60 * 60 * 1000); break;
                    case &apos;1w&apos;: startDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000); break;
                    case &apos;1m&apos;: startDate = new Date(new Date().setMonth(now.getMonth() - 1)); break;
                    case &apos;1y&apos;: startDate = new Date(new Date().setFullYear(now.getFullYear() - 1)); break;
                    default: startDate = new Date(0);
                }
                betsToFilter = betsToFilter.filter(bet =&gt; new Date(bet.placedAt) &gt;= startDate);
            }
        }
        return betsToFilter;
    }, [bets, selectedSport, dateRange, customDateRange]);

    const processedData = useMemo(() =&gt; {
        if (filteredBets.length === 0) return null;

        const sortedBets = [...filteredBets].sort((a, b) =&gt; new Date(a.placedAt).getTime() - new Date(b.placedAt).getTime());
        
        const overallStats = {
            totalBets: sortedBets.length,
            totalWagered: sortedBets.reduce((sum, b) =&gt; sum + b.stake, 0),
            netProfit: sortedBets.reduce((sum, b) =&gt; sum + (b.payout - b.stake), 0),
            wins: sortedBets.filter(b =&gt; b.result === &apos;win&apos;).length,
            losses: sortedBets.filter(b =&gt; b.result === &apos;loss&apos;).length,
            pushes: sortedBets.filter(b =&gt; b.result === &apos;push&apos;).length,
            get winRate() { return (this.wins + this.losses) &gt; 0 ? (this.wins / (this.wins + this.losses)) * 100 : 0 },
            get roi() { return this.totalWagered &gt; 0 ? (this.netProfit / this.totalWagered) * 100 : 0 }
        };

        let cumulativeProfit = 0;
        const profitOverTime = sortedBets.map(bet =&gt; {
            cumulativeProfit += (bet.payout - bet.stake);
            return { date: new Date(bet.placedAt).toLocaleDateString(), profit: cumulativeProfit };
        });

        const playerTeamStatsMap = new Map&lt;string, { count: number; stake: number; net: number; wins: number; losses: number; }&gt;();
        const marketStatsMap = new Map&lt;string, { name: string; sport: string; count: number; stake: number; net: number; wins: number; losses: number; }&gt;();
        const tailStatsMap = new Map&lt;string, { count: number; stake: number; net: number; wins: number; losses: number; }&gt;();
        
        const addToMap = (map: Map&lt;string, any&gt;, key: string, stake: number, net: number, result: BetResult) =&gt; {
            if (!map.has(key)) map.set(key, { count: 0, stake: 0, net: 0, wins: 0, losses: 0 });
            const stats = map.get(key)!;
            stats.count++;
            stats.stake += stake;
            stats.net += net;
            if (result === &apos;win&apos;) stats.wins++;
            if (result === &apos;loss&apos;) stats.losses++;
        };

        filteredBets.forEach(bet =&gt; {
            const net = bet.payout - bet.stake;
            const result = bet.result;
            if (bet.tail) addToMap(tailStatsMap, bet.tail.trim(), bet.stake, net, result);
            
            if (bet.legs?.length) {
                bet.legs.forEach(leg =&gt; {
                    leg.entities?.forEach(entity =&gt; addToMap(playerTeamStatsMap, entity, bet.stake, net, result));
                    const key = `${bet.sport}-${leg.market}`;
                    if (!marketStatsMap.has(key)) marketStatsMap.set(key, { name: leg.market, sport: bet.sport, count: 0, stake: 0, net: 0, wins: 0, losses: 0 });
                    const mStats = marketStatsMap.get(key)!;
                    mStats.count++; mStats.stake += bet.stake; mStats.net += net;
                    if (result === &apos;win&apos;) mStats.wins++; if (result === &apos;loss&apos;) mStats.losses++;
                });
            } else {
                const entity = extractEntityFromDescription(bet.description);
                addToMap(playerTeamStatsMap, entity, bet.stake, net, result);
            }
        });

        const calculateRoi = (s: { stake: number, net: number }) =&gt; s.stake &gt; 0 ? (s.net / s.stake) * 100 : 0;
        
        let playerTeamStats = Array.from(playerTeamStatsMap.entries()).map(([name, stats]) =&gt; ({ name, ...stats, roi: calculateRoi(stats) }));
        if (entityType === &apos;player&apos;) {
            playerTeamStats = playerTeamStats.filter(item =&gt; allPlayers.has(item.name));
        } else if (entityType === &apos;team&apos;) {
            playerTeamStats = playerTeamStats.filter(item =&gt; allTeams.has(item.name));
        }

        return {
            overallStats, profitOverTime,
            playerTeamStats,
            marketStats: Array.from(marketStatsMap.values()).map(stats =&gt; ({...stats, roi: calculateRoi(stats)})),
            tailStats: Array.from(tailStatsMap.entries()).map(([name, stats]) =&gt; ({ name, ...stats, roi: calculateRoi(stats) })),
        };
    }, [filteredBets, entityType, allPlayers, allTeams]);

    if (loading) return &lt;div className=&quot;p-6 text-center&quot;&gt;Loading sport data...&lt;/div&gt;;

    const EntityTypeButton: React.FC&lt;{ type: &apos;all&apos; | &apos;player&apos; | &apos;team&apos;, label: string }&gt; = ({ type, label }) =&gt; (
        &lt;button
            onClick={() =&gt; setEntityType(type)}
            className={`px-3 py-1.5 rounded-md font-medium text-xs transition-colors ${
                entityType === type
                ? &apos;bg-primary-600 text-white shadow&apos;
                : &apos;text-neutral-600 dark:text-neutral-300 hover:bg-white dark:hover:bg-neutral-700&apos;
            }`}
        &gt;
            {label}
        &lt;/button&gt;
    );

    return (
        &lt;div className=&quot;p-6 h-full flex flex-col space-y-6 bg-neutral-100 dark:bg-neutral-950 overflow-y-auto&quot;&gt;
            &lt;header&gt;
                &lt;h1 className=&quot;text-3xl font-bold text-neutral-900 dark:text-white&quot;&gt;By Sport&lt;/h1&gt;
                &lt;p className=&quot;text-neutral-500 dark:text-neutral-400 mt-1&quot;&gt;A detailed performance analysis for each sport.&lt;/p&gt;
            &lt;/header&gt;

            &lt;div className=&quot;bg-white dark:bg-neutral-900 rounded-lg shadow-md p-6 space-y-4&quot;&gt;
                 &lt;div className=&quot;flex flex-col sm:flex-row sm:justify-between sm:items-center gap-4&quot;&gt;
                    &lt;div className=&quot;flex items-center space-x-1 flex-wrap gap-y-2 bg-neutral-100 dark:bg-neutral-800/50 p-1 rounded-lg&quot;&gt;
                        {availableSports.map(sport =&gt; (
                            &lt;button key={sport} onClick={() =&gt; setSelectedSport(sport)} className={`px-3 py-1.5 rounded-md font-medium text-xs transition-colors ${selectedSport === sport ? &apos;bg-primary-600 text-white shadow&apos; : &apos;text-neutral-600 dark:text-neutral-300 hover:bg-white dark:hover:bg-neutral-700&apos;}`}&gt;
                                {sport}
                            &lt;/button&gt;
                        ))}
                    &lt;/div&gt;
                    &lt;div className=&quot;flex items-center space-x-1 flex-wrap gap-y-2 bg-neutral-100 dark:bg-neutral-800/50 p-1 rounded-lg&quot;&gt;
                        &lt;DateRangeButton range=&quot;all&quot; label=&quot;All Time&quot; currentRange={dateRange} onClick={setDateRange} /&gt;
                        &lt;DateRangeButton range=&quot;1d&quot; label=&quot;1D&quot; currentRange={dateRange} onClick={setDateRange} /&gt;
                        &lt;DateRangeButton range=&quot;3d&quot; label=&quot;3D&quot; currentRange={dateRange} onClick={setDateRange} /&gt;
                        &lt;DateRangeButton range=&quot;1w&quot; label=&quot;1W&quot; currentRange={dateRange} onClick={setDateRange} /&gt;
                        &lt;DateRangeButton range=&quot;1m&quot; label=&quot;1M&quot; currentRange={dateRange} onClick={setDateRange} /&gt;
                        &lt;DateRangeButton range=&quot;1y&quot; label=&quot;1Y&quot; currentRange={dateRange} onClick={setDateRange} /&gt;
                        &lt;DateRangeButton range=&quot;custom&quot; label=&quot;Custom&quot; currentRange={dateRange} onClick={setDateRange} /&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
                {dateRange === &apos;custom&apos; &amp;&amp; (
                    &lt;div className=&quot;flex sm:justify-end items-center space-x-4&quot;&gt;
                        &lt;input type=&quot;date&quot; value={customDateRange.start} onChange={e =&gt; setCustomDateRange(p =&gt; ({ ...p, start: e.target.value }))} className=&quot;bg-neutral-50 dark:bg-neutral-800 border border-neutral-300 dark:border-neutral-600 rounded-lg p-2 text-sm&quot; /&gt;
                        &lt;input type=&quot;date&quot; value={customDateRange.end} onChange={e =&gt; setCustomDateRange(p =&gt; ({ ...p, end: e.target.value }))} className=&quot;bg-neutral-50 dark:bg-neutral-800 border border-neutral-300 dark:border-neutral-600 rounded-lg p-2 text-sm&quot; /&gt;
                    &lt;/div&gt;
                )}

                {processedData ? (
                    &lt;div className=&quot;space-y-6 pt-4&quot;&gt;
                        &lt;div className=&quot;grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6&quot;&gt;
                            &lt;StatCard title=&quot;Net Profit&quot; value={`${processedData.overallStats.netProfit &gt;= 0 ? &apos;$&apos; : &apos;-$&apos;}${Math.abs(processedData.overallStats.netProfit).toFixed(2)}`} icon={&lt;Scale className=&quot;w-6 h-6&quot;/&gt;} change={`${processedData.overallStats.roi.toFixed(1)}% ROI`}/&gt;
                            &lt;StatCard title=&quot;Total Wagered&quot; value={`$${processedData.overallStats.totalWagered.toFixed(2)}`} icon={&lt;BarChart2 className=&quot;w-6 h-6&quot;/&gt;} /&gt;
                            &lt;StatCard title=&quot;Total Bets&quot; value={processedData.overallStats.totalBets.toString()} icon={&lt;BarChart2 className=&quot;w-6 h-6&quot;/&gt;} /&gt;
                            &lt;StatCard title=&quot;Win Rate&quot; value={`${processedData.overallStats.winRate.toFixed(1)}%`} icon={&lt;BarChart2 className=&quot;w-6 h-6&quot;/&gt;} change={`${processedData.overallStats.wins}-${processedData.overallStats.losses}`} /&gt;
                        &lt;/div&gt;
                        &lt;ChartContainer title=&quot;Profit Over Time&quot;&gt;
                            &lt;ResponsiveContainer width=&quot;100%&quot; height=&quot;100%&quot;&gt;
                                &lt;LineChart data={processedData.profitOverTime}&gt;
                                    &lt;CartesianGrid strokeDasharray=&quot;3 3&quot; stroke=&quot;rgba(128, 128, 128, 0.2)&quot; /&gt;
                                    &lt;XAxis dataKey=&quot;date&quot; stroke=&quot;rgb(113, 113, 122)&quot; tick={{ fontSize: 12 }} /&gt;
                                    &lt;YAxis stroke=&quot;rgb(113, 113, 122)&quot; tick={{ fontSize: 12 }} tickFormatter={(value) =&gt; `$${value}`}/&gt;
                                    &lt;Tooltip content={&lt;CustomTooltip /&gt;} /&gt;
                                    &lt;Line type=&quot;monotone&quot; dataKey=&quot;profit&quot; name=&quot;Profit&quot; stroke=&quot;#8b5cf6&quot; strokeWidth={2} dot={false} /&gt;
                                &lt;/LineChart&gt;
                            &lt;/ResponsiveContainer&gt;
                        &lt;/ChartContainer&gt;
                    &lt;/div&gt;
                ) : (
                    &lt;div className=&quot;flex-grow flex items-center justify-center&quot;&gt;
                        &lt;div className=&quot;text-center text-neutral-500 dark:text-neutral-400 p-8&quot;&gt;
                            &lt;Trophy className=&quot;w-16 h-16 mx-auto text-neutral-400 dark:text-neutral-600&quot; /&gt;
                            &lt;h3 className=&quot;mt-4 text-xl font-semibold&quot;&gt;No Data Found&lt;/h3&gt;
                            &lt;p className=&quot;mt-1&quot;&gt;No betting data found for {selectedSport} in the selected date range.&lt;/p&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                )}
            &lt;/div&gt;
            
            {processedData &amp;&amp; (
                &lt;div className=&quot;pt-4 border-t border-neutral-200 dark:border-neutral-800&quot;&gt;
                    &lt;h2 className=&quot;text-2xl font-bold text-neutral-900 dark:text-white mb-6&quot;&gt;Performance Analysis for {selectedSport}&lt;/h2&gt;
                    &lt;div className=&quot;space-y-6&quot;&gt;
                        &lt;StatsTable data={processedData.marketStats} title=&quot;Market Performance&quot; searchPlaceholder=&quot;Search market...&quot; /&gt;
                        &lt;div className=&quot;h-[500px]&quot;&gt;
                            &lt;StatsTable data={processedData.playerTeamStats} title=&quot;Player &amp; Team Performance&quot; searchPlaceholder=&quot;Search player/team...&quot; className=&quot;h-full&quot;&gt;
                                &lt;div className=&quot;flex items-center space-x-1 flex-wrap gap-y-2 bg-neutral-100 dark:bg-neutral-800/50 p-1 rounded-lg&quot;&gt;
                                    &lt;EntityTypeButton type=&quot;all&quot; label=&quot;All&quot; /&gt;
                                    &lt;EntityTypeButton type=&quot;player&quot; label=&quot;Player&quot; /&gt;
                                    &lt;EntityTypeButton type=&quot;team&quot; label=&quot;Team&quot; /&gt;
                                &lt;/div&gt;
                            &lt;/StatsTable&gt;
                        &lt;/div&gt;
                        &lt;div className=&quot;grid grid-cols-1 lg:grid-cols-2 gap-6&quot;&gt;
                            &lt;OverUnderBreakdown bets={filteredBets} /&gt;
                            &lt;LiveVsPreMatchBreakdown bets={filteredBets} /&gt;
                        &lt;/div&gt;
                        {processedData.tailStats.length &gt; 0 &amp;&amp; (
                            &lt;StatsTable data={processedData.tailStats} title=&quot;Performance by Tail&quot; searchPlaceholder=&quot;Search tail...&quot; /&gt;
                        )}
                    &lt;/div&gt;
                &lt;/div&gt;
            )}

        &lt;/div&gt;
    );
};

export default BySportView;</file><file path="views/DashboardView.tsx">import React, { useMemo, useState } from &apos;react&apos;;
import { useBets } from &apos;../hooks/useBets&apos;;
import { useInputs } from &apos;../hooks/useInputs&apos;;
import { BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer, LineChart, Line, PieChart, Pie, Cell, Sector } from &apos;recharts&apos;;
import { TrendingUp, TrendingDown, Scale, BarChart2 } from &apos;../components/icons&apos;;
import { Bet } from &apos;../types&apos;;
import { MARKET_CATEGORIES } from &apos;../constants&apos;;

// --- HELPER FUNCTIONS &amp; COMPONENTS ---

const CustomTooltip = ({ active, payload, label }: any) =&gt; {
    if (active &amp;&amp; payload &amp;&amp; payload.length) {
        return (
            &lt;div className=&quot;bg-white dark:bg-neutral-800 p-2 border border-neutral-300 dark:border-neutral-600 rounded shadow-lg text-sm&quot;&gt;
                &lt;p className=&quot;label font-bold mb-1&quot;&gt;{`${label}`}&lt;/p&gt;
                {payload.map((pld: any, index: number) =&gt; (
                    &lt;p key={index} style={{ color: pld.color || pld.fill }}&gt;
                        {`${pld.name}: ${typeof pld.value === &apos;number&apos; ? pld.value.toFixed(2) : pld.value}`}
                    &lt;/p&gt;
                ))}
            &lt;/div&gt;
        );
    }
    return null;
};

const ChartContainer: React.FC&lt;{ title: string; children: React.ReactNode }&gt; = ({ title, children }) =&gt; (
    &lt;div className=&quot;bg-white dark:bg-neutral-900 rounded-lg shadow-md p-6&quot;&gt;
        &lt;h2 className=&quot;text-xl font-semibold mb-4 text-neutral-800 dark:text-neutral-200&quot;&gt;{title}&lt;/h2&gt;
        &lt;div className=&quot;h-72&quot;&gt;{children}&lt;/div&gt;
    &lt;/div&gt;
);

type StatsData = { name: string; count: number; wins: number; losses: number; stake: number; net: number; roi: number; sport?: string };
interface StatsTableProps {
    data: StatsData[];
    title: string;
    searchPlaceholder: string;
    className?: string;
    children?: React.ReactNode;
}

const StatsTable: React.FC&lt;StatsTableProps&gt; = ({ data, title, searchPlaceholder, className, children }) =&gt; {
    const [searchTerm, setSearchTerm] = useState(&apos;&apos;);
    const [sortConfig, setSortConfig] = useState&lt;{ key: keyof StatsData; direction: &apos;asc&apos; | &apos;desc&apos; }&gt;({ key: &apos;net&apos;, direction: &apos;desc&apos; });
    
    const sortedData = useMemo(() =&gt; {
        const filtered = data.filter(item =&gt; item.name.toLowerCase().includes(searchTerm.toLowerCase()));
        return [...filtered].sort((a, b) =&gt; {
            if (a[sortConfig.key] &lt; b[sortConfig.key]) return sortConfig.direction === &apos;asc&apos; ? -1 : 1;
            if (a[sortConfig.key] &gt; b[sortConfig.key]) return sortConfig.direction === &apos;asc&apos; ? 1 : -1;
            return 0;
        });
    }, [data, searchTerm, sortConfig]);

    const requestSort = (key: keyof StatsData) =&gt; {
        let direction: &apos;asc&apos; | &apos;desc&apos; = &apos;asc&apos;;
        if (sortConfig.key === key &amp;&amp; sortConfig.direction === &apos;asc&apos;) {
            direction = &apos;desc&apos;;
        }
        setSortConfig({ key, direction });
    };

    return (
        &lt;div className={`bg-white dark:bg-neutral-900 rounded-lg shadow-md p-6 flex flex-col ${className}`}&gt;
            &lt;div className=&quot;flex justify-between items-center&quot;&gt;
                &lt;h2 className=&quot;text-xl font-semibold text-neutral-800 dark:text-neutral-200&quot;&gt;{title}&lt;/h2&gt;
                {children}
            &lt;/div&gt;
            &lt;input
                type=&quot;text&quot;
                placeholder={searchPlaceholder}
                value={searchTerm}
                onChange={e =&gt; setSearchTerm(e.target.value)}
                className=&quot;my-4 p-2 border border-neutral-300 dark:border-neutral-700 rounded-md bg-neutral-50 dark:bg-neutral-800 w-full&quot;
            /&gt;
            &lt;div className=&quot;overflow-y-auto flex-grow&quot;&gt;
                &lt;table className=&quot;w-full text-sm text-left&quot;&gt;
                    &lt;thead className=&quot;text-xs text-neutral-500 dark:text-neutral-400 uppercase sticky top-0 bg-white dark:bg-neutral-900&quot;&gt;
                        &lt;tr&gt;
                            &lt;th className=&quot;px-4 py-2 cursor-pointer&quot; onClick={() =&gt; requestSort(&apos;name&apos;)}&gt;
                                {searchPlaceholder.split(&apos; &apos;)[1]} {sortConfig.key === &apos;name&apos; ? (sortConfig.direction === &apos;desc&apos; ? &apos;&apos; : &apos;&apos;) : &apos;&apos;}
                            &lt;/th&gt;
                            &lt;th className=&quot;px-4 py-2 cursor-pointer text-center&quot; onClick={() =&gt; requestSort(&apos;count&apos;)}&gt;
                                # Bets {sortConfig.key === &apos;count&apos; ? (sortConfig.direction === &apos;desc&apos; ? &apos;&apos; : &apos;&apos;) : &apos;&apos;}
                            &lt;/th&gt;
                            &lt;th className=&quot;px-4 py-2 cursor-pointer text-center&quot; onClick={() =&gt; requestSort(&apos;wins&apos;)}&gt;Win {sortConfig.key === &apos;wins&apos; ? (sortConfig.direction === &apos;desc&apos; ? &apos;&apos; : &apos;&apos;) : &apos;&apos;}&lt;/th&gt;
                            &lt;th className=&quot;px-4 py-2 cursor-pointer text-center&quot; onClick={() =&gt; requestSort(&apos;losses&apos;)}&gt;Loss {sortConfig.key === &apos;losses&apos; ? (sortConfig.direction === &apos;desc&apos; ? &apos;&apos; : &apos;&apos;) : &apos;&apos;}&lt;/th&gt;
                            &lt;th className=&quot;px-4 py-2 text-center&quot;&gt;Win %&lt;/th&gt;
                            &lt;th className=&quot;px-4 py-2 cursor-pointer&quot; onClick={() =&gt; requestSort(&apos;stake&apos;)}&gt;
                                Wagered {sortConfig.key === &apos;stake&apos; ? (sortConfig.direction === &apos;desc&apos; ? &apos;&apos; : &apos;&apos;) : &apos;&apos;}
                            &lt;/th&gt;
                            &lt;th className=&quot;px-4 py-2 cursor-pointer&quot; onClick={() =&gt; requestSort(&apos;net&apos;)}&gt;
                                Net {sortConfig.key === &apos;net&apos; ? (sortConfig.direction === &apos;desc&apos; ? &apos;&apos; : &apos;&apos;) : &apos;&apos;}
                            &lt;/th&gt;
                            &lt;th className=&quot;px-4 py-2 cursor-pointer&quot; onClick={() =&gt; requestSort(&apos;roi&apos;)}&gt;
                                ROI {sortConfig.key === &apos;roi&apos; ? (sortConfig.direction === &apos;desc&apos; ? &apos;&apos; : &apos;&apos;) : &apos;&apos;}
                            &lt;/th&gt;
                        &lt;/tr&gt;
                    &lt;/thead&gt;
                    &lt;tbody className=&quot;divide-y divide-neutral-200 dark:divide-neutral-800&quot;&gt;
                        {sortedData.map(item =&gt; {
                            const netColor = item.net &gt; 0 ? &apos;text-accent-500&apos; : item.net &lt; 0 ? &apos;text-danger-500&apos; : &apos;text-neutral-500&apos;;
                            const winPct = item.wins + item.losses &gt; 0 ? (item.wins / (item.wins + item.losses)) * 100 : 0;
                            const winPctColor = winPct &gt; 50 ? &apos;text-accent-500&apos; : winPct &lt; 50 &amp;&amp; (item.wins + item.losses &gt; 0) ? &apos;text-danger-500&apos; : &apos;text-neutral-500&apos;;
                            
                            return (
                                &lt;tr key={item.sport ? `${item.sport}-${item.name}` : item.name} className=&quot;odd:bg-white dark:odd:bg-neutral-900 even:bg-neutral-50 dark:even:bg-neutral-800/50 hover:bg-neutral-100 dark:hover:bg-neutral-800&quot;&gt;
                                    &lt;td className=&quot;px-4 py-2 font-medium text-neutral-900 dark:text-neutral-100 truncate max-w-xs&quot;&gt;{item.name}&lt;/td&gt;
                                    &lt;td className=&quot;px-4 py-2 text-center&quot;&gt;{item.count}&lt;/td&gt;
                                    &lt;td className=&quot;px-4 py-2 text-center&quot;&gt;{item.wins}&lt;/td&gt;
                                    &lt;td className=&quot;px-4 py-2 text-center&quot;&gt;{item.losses}&lt;/td&gt;
                                    &lt;td className={`px-4 py-2 text-center font-semibold ${winPctColor}`}&gt;{winPct.toFixed(1)}%&lt;/td&gt;
                                    &lt;td className=&quot;px-4 py-2&quot;&gt;${item.stake.toFixed(2)}&lt;/td&gt;
                                    &lt;td className={`px-4 py-2 font-semibold ${netColor}`}&gt;{item.net.toFixed(2)}&lt;/td&gt;
                                    &lt;td className={`px-4 py-2 font-semibold ${netColor}`}&gt;{item.roi.toFixed(1)}%&lt;/td&gt;
                                &lt;/tr&gt;
                            )
                        })}
                    &lt;/tbody&gt;
                &lt;/table&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    );
};

const extractEntityFromDescription = (description: string): string =&gt; {
    const patterns = [
        /^(.*?)\s+([+-]\d+(\.\d+)?|ML|PK|pk)$/i, 
        /^(.*?)\s+(?:to win|To Win|to Win Outright)/i,
        /^(.*?)\s+(?:Over|Under|O|U)\s+\d+(\.\d+)?/i,
    ];
    for (const pattern of patterns) {
        const match = description.match(pattern);
        if (match &amp;&amp; match[1]) return match[1].trim();
    }
    return description;
};

const ToggleButton: React.FC&lt;{
  value: string;
  label: string;
  currentValue: string;
  onClick: (value: string) =&gt; void;
}&gt; = ({ value, label, currentValue, onClick }) =&gt; (
  &lt;button
    onClick={() =&gt; onClick(value)}
    className={`px-2.5 py-1 rounded-md font-medium text-xs transition-colors ${
      currentValue === value
        ? &apos;bg-primary-600 text-white shadow&apos;
        : &apos;text-neutral-600 dark:text-neutral-300 bg-neutral-100 dark:bg-neutral-800 hover:bg-neutral-200 dark:hover:bg-neutral-700&apos;
    }`}
  &gt;
    {label}
  &lt;/button&gt;
);

const OverUnderBreakdown: React.FC&lt;{ bets: Bet[] }&gt; = ({ bets }) =&gt; {
    const [filter, setFilter] = useState&lt;&apos;props&apos; | &apos;totals&apos; | &apos;all&apos;&gt;(&apos;all&apos;);

    const data = useMemo(() =&gt; {
        const filteredBets = bets.filter(bet =&gt; {
            if (filter === &apos;props&apos;) return bet.marketCategory === &apos;Props&apos;;
            if (filter === &apos;totals&apos;) return bet.marketCategory === &apos;Main Markets&apos;;
            return bet.marketCategory === &apos;Props&apos; || bet.marketCategory === &apos;Main Markets&apos;;
        });

        const stats = { 
            over: { count: 0, wins: 0, losses: 0, stake: 0, net: 0 }, 
            under: { count: 0, wins: 0, losses: 0, stake: 0, net: 0 }
        };

        filteredBets.forEach(bet =&gt; {
            if (bet.legs?.length) {
                bet.legs.forEach(leg =&gt; {
                    if (leg.ou) {
                        const ou = leg.ou.toLowerCase() as &apos;over&apos; | &apos;under&apos;;
                        const net = bet.payout - bet.stake;
                        stats[ou].count++; 
                        stats[ou].stake += bet.stake; 
                        stats[ou].net += net;
                        if (bet.result === &apos;win&apos;) stats[ou].wins++; 
                        if (bet.result === &apos;loss&apos;) stats[ou].losses++;
                    }
                });
            }
        });

        const calculateRoi = (s: { stake: number, net: number }) =&gt; s.stake &gt; 0 ? (s.net / s.stake) * 100 : 0;
        
        return { 
            over: {...stats.over, roi: calculateRoi(stats.over)}, 
            under: {...stats.under, roi: calculateRoi(stats.under)}
        };
    }, [bets, filter]);

    const pieData = [
        { name: &apos;Over&apos;, value: data.over.count, color: &apos;#8b5cf6&apos; },
        { name: &apos;Under&apos;, value: data.under.count, color: &apos;#6d28d9&apos; }
    ].filter(d =&gt; d.value &gt; 0);

    const StatCard = ({ title, stats, color }: { title: string; stats: any; color: string }) =&gt; {
        const netColor = stats.net &gt; 0 ? &apos;text-accent-500&apos; : stats.net &lt; 0 ? &apos;text-danger-500&apos; : &apos;&apos;;
        const NetIcon = stats.net &gt; 0 ? TrendingUp : TrendingDown;
        const winPct = stats.wins + stats.losses &gt; 0 ? (stats.wins / (stats.wins + stats.losses)) * 100 : 0;
        return (
            &lt;div className=&quot;p-4 rounded-lg bg-neutral-100 dark:bg-neutral-800/50 flex-1&quot;&gt;
                &lt;h4 className=&quot;font-bold text-lg&quot; style={{ color }}&gt;{title}&lt;/h4&gt;
                &lt;div className=&quot;text-sm mt-2 space-y-1 text-neutral-600 dark:text-neutral-300&quot;&gt;
                    &lt;p&gt;&lt;b&gt;Bets:&lt;/b&gt; {stats.count}&lt;/p&gt;
                    &lt;p&gt;&lt;b&gt;Record:&lt;/b&gt; {stats.wins}-{stats.losses}&lt;/p&gt;
                    &lt;p&gt;&lt;b&gt;Win %:&lt;/b&gt; {winPct.toFixed(1)}%&lt;/p&gt;
                    &lt;p className={`flex items-center ${netColor}`}&gt;&lt;b&gt;Net:&lt;/b&gt;&lt;NetIcon className=&quot;w-4 h-4 mx-1&quot;/&gt; ${stats.net.toFixed(2)}&lt;/p&gt;
                    &lt;p className={netColor}&gt;&lt;b&gt;ROI:&lt;/b&gt; {stats.roi.toFixed(1)}%&lt;/p&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        )
    };
    
    return (
        &lt;div className=&quot;bg-white dark:bg-neutral-900 rounded-lg shadow-md p-6 flex flex-col&quot;&gt;
            &lt;div className=&quot;flex justify-between items-center mb-4&quot;&gt;
                &lt;h2 className=&quot;text-xl font-semibold text-neutral-800 dark:text-neutral-200&quot;&gt;Over vs. Under&lt;/h2&gt;
                 &lt;div className=&quot;flex items-center space-x-1 flex-wrap gap-y-2 bg-neutral-100 dark:bg-neutral-800/50 p-1 rounded-lg&quot;&gt;
                    &lt;ToggleButton value=&quot;props&quot; label=&quot;Props&quot; currentValue={filter} onClick={(v) =&gt; setFilter(v as any)} /&gt;
                    &lt;ToggleButton value=&quot;totals&quot; label=&quot;Totals&quot; currentValue={filter} onClick={(v) =&gt; setFilter(v as any)} /&gt;
                    &lt;ToggleButton value=&quot;all&quot; label=&quot;All&quot; currentValue={filter} onClick={(v) =&gt; setFilter(v as any)} /&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            &lt;div className=&quot;h-40&quot;&gt;
                &lt;ResponsiveContainer width=&quot;100%&quot; height=&quot;100%&quot;&gt;
                    &lt;PieChart&gt;
                        &lt;Pie data={pieData} dataKey=&quot;value&quot; nameKey=&quot;name&quot; cx=&quot;50%&quot; cy=&quot;50%&quot; outerRadius={60} label={({ name, percent }) =&gt; `${name} ${(percent * 100).toFixed(0)}%`}&gt;
                            {pieData.map((entry) =&gt; &lt;Cell key={`cell-${entry.name}`} fill={entry.color} /&gt;)}
                        &lt;/Pie&gt;
                        &lt;Tooltip content={&lt;CustomTooltip /&gt;} /&gt;
                    &lt;/PieChart&gt;
                &lt;/ResponsiveContainer&gt;
            &lt;/div&gt;
            &lt;div className=&quot;flex gap-4 mt-4&quot;&gt;
                &lt;StatCard title=&quot;Over&quot; stats={data.over} color={pieData.find(d =&gt; d.name === &apos;Over&apos;)?.color || &apos;#8b5cf6&apos;} /&gt;
                &lt;StatCard title=&quot;Under&quot; stats={data.under} color={pieData.find(d =&gt; d.name === &apos;Under&apos;)?.color || &apos;#6d28d9&apos;} /&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    );
}


const LiveVsPreMatchBreakdown: React.FC&lt;{ bets: Bet[] }&gt; = ({ bets }) =&gt; {
    const [filter, setFilter] = useState&lt;&apos;all&apos; | &apos;props&apos; | &apos;main&apos;&gt;(&apos;all&apos;);

    const data = useMemo(() =&gt; {
        const filteredBets = bets.filter(bet =&gt; {
            if (filter === &apos;props&apos;) return bet.marketCategory === &apos;Props&apos;;
            if (filter === &apos;main&apos;) return bet.marketCategory === &apos;Main Markets&apos;;
            return true; // all
        });
        
        const stats = { 
            live: { count: 0, wins: 0, losses: 0, stake: 0, net: 0 }, 
            preMatch: { count: 0, wins: 0, losses: 0, stake: 0, net: 0 }
        };

        filteredBets.forEach(bet =&gt; {
            const result = bet.result;
            const net = bet.payout - bet.stake;
            const liveTarget = bet.betType === &apos;live&apos; ? stats.live : stats.preMatch;
            liveTarget.count++; 
            liveTarget.stake += bet.stake; 
            liveTarget.net += net;
            if (result === &apos;win&apos;) liveTarget.wins++; 
            if (result === &apos;loss&apos;) liveTarget.losses++;
        });

        const calculateRoi = (s: { stake: number, net: number }) =&gt; s.stake &gt; 0 ? (s.net / s.stake) * 100 : 0;
        
        return { 
            live: {...stats.live, roi: calculateRoi(stats.live)}, 
            preMatch: {...stats.preMatch, roi: calculateRoi(stats.preMatch)}
        };
    }, [bets, filter]);

    const pieData = [
        { name: &apos;Pre-Match&apos;, value: data.preMatch.count, color: &apos;#4c1d95&apos; },
        { name: &apos;Live&apos;, value: data.live.count, color: &apos;#a78bfa&apos; }
    ].filter(d =&gt; d.value &gt; 0);

    const StatCard = ({ title, stats, color }: { title: string, stats: any, color: string }) =&gt; {
        const netColor = stats.net &gt; 0 ? &apos;text-accent-500&apos; : stats.net &lt; 0 ? &apos;text-danger-500&apos; : &apos;&apos;;
        const NetIcon = stats.net &gt; 0 ? TrendingUp : TrendingDown;
        const winPct = stats.wins + stats.losses &gt; 0 ? (stats.wins / (stats.wins + stats.losses)) * 100 : 0;
        return (
            &lt;div className=&quot;p-4 rounded-lg bg-neutral-100 dark:bg-neutral-800/50 flex-1&quot;&gt;
                &lt;h4 className=&quot;font-bold text-lg&quot; style={{ color }}&gt;{title}&lt;/h4&gt;
                &lt;div className=&quot;text-sm mt-2 space-y-1 text-neutral-600 dark:text-neutral-300&quot;&gt;
                    &lt;p&gt;&lt;b&gt;Bets:&lt;/b&gt; {stats.count}&lt;/p&gt;
                    &lt;p&gt;&lt;b&gt;Record:&lt;/b&gt; {stats.wins}-{stats.losses}&lt;/p&gt;
                    &lt;p&gt;&lt;b&gt;Win %:&lt;/b&gt; {winPct.toFixed(1)}%&lt;/p&gt;
                    &lt;p className={`flex items-center ${netColor}`}&gt;&lt;b&gt;Net:&lt;/b&gt;&lt;NetIcon className=&quot;w-4 h-4 mx-1&quot;/&gt; ${stats.net.toFixed(2)}&lt;/p&gt;
                    &lt;p className={netColor}&gt;&lt;b&gt;ROI:&lt;/b&gt; {stats.roi.toFixed(1)}%&lt;/p&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        )
    };
    
    return (
        &lt;div className=&quot;bg-white dark:bg-neutral-900 rounded-lg shadow-md p-6 flex flex-col&quot;&gt;
            &lt;div className=&quot;flex justify-between items-center mb-4&quot;&gt;
                &lt;h2 className=&quot;text-xl font-semibold text-neutral-800 dark:text-neutral-200&quot;&gt;Live vs. Pre-Match&lt;/h2&gt;
                 &lt;div className=&quot;flex items-center space-x-1 flex-wrap gap-y-2 bg-neutral-100 dark:bg-neutral-800/50 p-1 rounded-lg&quot;&gt;
                    &lt;ToggleButton value=&quot;props&quot; label=&quot;Props&quot; currentValue={filter} onClick={(v) =&gt; setFilter(v as any)} /&gt;
                    &lt;ToggleButton value=&quot;main&quot; label=&quot;Main Markets&quot; currentValue={filter} onClick={(v) =&gt; setFilter(v as any)} /&gt;
                    &lt;ToggleButton value=&quot;all&quot; label=&quot;All&quot; currentValue={filter} onClick={(v) =&gt; setFilter(v as any)} /&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            &lt;div className=&quot;h-40&quot;&gt;
                &lt;ResponsiveContainer width=&quot;100%&quot; height=&quot;100%&quot;&gt;
                    &lt;PieChart&gt;
                        &lt;Pie data={pieData} dataKey=&quot;value&quot; nameKey=&quot;name&quot; cx=&quot;50%&quot; cy=&quot;50%&quot; outerRadius={60} label={({ name, percent }) =&gt; `${name} ${(percent * 100).toFixed(0)}%`}&gt;
                            {pieData.map((entry) =&gt; &lt;Cell key={`cell-${entry.name}`} fill={entry.color} /&gt;)}
                        &lt;/Pie&gt;
                        &lt;Tooltip content={&lt;CustomTooltip /&gt;} /&gt;
                    &lt;/PieChart&gt;
                &lt;/ResponsiveContainer&gt;
            &lt;/div&gt;
            &lt;div className=&quot;flex gap-4 mt-4&quot;&gt;
                &lt;StatCard title=&quot;Pre-Match&quot; stats={data.preMatch} color={pieData.find(d=&gt;d.name===&apos;Pre-Match&apos;)?.color || &apos;#4c1d95&apos;} /&gt;
                &lt;StatCard title=&quot;Live&quot; stats={data.live} color={pieData.find(d=&gt;d.name===&apos;Live&apos;)?.color || &apos;#a78bfa&apos;} /&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    );
}

type DateRange = &apos;all&apos; | &apos;1d&apos; | &apos;3d&apos; | &apos;1w&apos; | &apos;1m&apos; | &apos;1y&apos; | &apos;custom&apos;;

const DateRangeButton: React.FC&lt;{
  range: DateRange;
  label: string;
  currentRange: DateRange;
  onClick: (range: DateRange) =&gt; void;
}&gt; = ({ range, label, currentRange, onClick }) =&gt; (
  &lt;button
    onClick={() =&gt; onClick(range)}
    className={`px-3 py-1.5 rounded-md font-medium text-xs transition-colors ${
      currentRange === range
        ? &apos;bg-primary-600 text-white shadow&apos;
        : &apos;text-neutral-600 dark:text-neutral-300 hover:bg-white dark:hover:bg-neutral-700&apos;
    }`}
  &gt;
    {label}
  &lt;/button&gt;
);

const QuickStatCard: React.FC&lt;{ label: string; value: number }&gt; = ({ label, value }) =&gt; {
    const valueColor = value &gt; 0 ? &apos;text-accent-500&apos; : value &lt; 0 ? &apos;text-danger-500&apos; : &apos;text-neutral-500&apos;;
    const formattedValue = `${value &gt;= 0 ? &apos;+&apos; : &apos;-&apos;}$${Math.abs(value).toFixed(2)}`;

    return (
        &lt;div className=&quot;bg-neutral-100 dark:bg-neutral-800/50 p-4 rounded-lg text-center&quot;&gt;
            &lt;p className=&quot;text-sm font-medium text-neutral-500 dark:text-neutral-400&quot;&gt;{label}&lt;/p&gt;
            &lt;p className={`text-2xl font-bold mt-1 ${valueColor}`}&gt;{formattedValue}&lt;/p&gt;
        &lt;/div&gt;
    );
};

const StatCard: React.FC&lt;{ title: string; value: string; icon: React.ReactNode; change?: string; }&gt; = ({ title, value, icon, change }) =&gt; {
    const isPositive = change &amp;&amp; parseFloat(change) &gt; 0;
    const isNegative = change &amp;&amp; parseFloat(change) &lt; 0;
    const changeColor = isPositive ? &apos;text-accent-500&apos; : isNegative ? &apos;text-danger-500&apos; : &apos;text-neutral-500 dark:text-neutral-400&apos;;

    return (
        &lt;div className=&quot;bg-white dark:bg-neutral-900 p-6 rounded-lg shadow-md flex items-start justify-between&quot;&gt;
            &lt;div&gt;
                &lt;p className=&quot;text-sm font-medium text-neutral-500 dark:text-neutral-400 uppercase&quot;&gt;{title}&lt;/p&gt;
                &lt;p className=&quot;text-3xl font-bold text-neutral-900 dark:text-white mt-1&quot;&gt;{value}&lt;/p&gt;
                {change &amp;&amp; (
                    &lt;p className={`text-sm font-semibold flex items-center mt-2 ${changeColor}`}&gt;
                        {isPositive &amp;&amp; &lt;TrendingUp className=&quot;w-4 h-4 mr-1&quot; /&gt;}
                        {isNegative &amp;&amp; &lt;TrendingDown className=&quot;w-4 h-4 mr-1&quot; /&gt;}
                        {change}
                    &lt;/p&gt;
                )}
            &lt;/div&gt;
            &lt;div className=&quot;bg-primary-100 dark:bg-primary-900/50 text-primary-600 dark:text-primary-400 p-3 rounded-full&quot;&gt;
                {icon}
            &lt;/div&gt;
        &lt;/div&gt;
    );
};

// --- MAIN DASHBOARD VIEW ---

const DashboardView: React.FC = () =&gt; {
    const { bets, loading } = useBets();
    const { players, teams } = useInputs();
    const [selectedMarketCategory, setSelectedMarketCategory] = useState&lt;string&gt;(&apos;all&apos;);
    const [dateRange, setDateRange] = useState&lt;DateRange&gt;(&apos;all&apos;);
    const [customDateRange, setCustomDateRange] = useState&lt;{ start: string; end: string }&gt;({ start: &apos;&apos;, end: &apos;&apos; });
    const [entityType, setEntityType] = useState&lt;&apos;all&apos; | &apos;player&apos; | &apos;team&apos;&gt;(&apos;all&apos;);
    
    const allPlayers = useMemo(() =&gt; new Set(Object.values(players).flat()), [players]);
    const allTeams = useMemo(() =&gt; new Set(Object.values(teams).flat()), [teams]);

    const filteredBets = useMemo(() =&gt; {
        let betsToFilter = bets.filter(bet =&gt; {
            if (selectedMarketCategory !== &apos;all&apos; &amp;&amp; bet.marketCategory !== selectedMarketCategory) return false;
            return true;
        });

        if (dateRange !== &apos;all&apos;) {
            if (dateRange === &apos;custom&apos;) {
                const customStart = customDateRange.start ? new Date(`${customDateRange.start}T00:00:00.000Z`) : null;
                const customEnd = customDateRange.end ? new Date(`${customDateRange.end}T23:59:59.999Z`) : null;
                
                betsToFilter = betsToFilter.filter(bet =&gt; {
                    const betDate = new Date(bet.placedAt);
                    if (customStart &amp;&amp; betDate &lt; customStart) return false;
                    if (customEnd &amp;&amp; betDate &gt; customEnd) return false;
                    return true;
                });
            } else {
                let startDate: Date;
                const now = new Date();
    
                switch (dateRange) {
                    case &apos;1d&apos;: startDate = new Date(now.getTime() - 1 * 24 * 60 * 60 * 1000); break;
                    case &apos;3d&apos;: startDate = new Date(now.getTime() - 3 * 24 * 60 * 60 * 1000); break;
                    case &apos;1w&apos;: startDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000); break;
                    case &apos;1m&apos;: startDate = new Date(new Date().setMonth(now.getMonth() - 1)); break;
                    case &apos;1y&apos;: startDate = new Date(new Date().setFullYear(now.getFullYear() - 1)); break;
                    default: startDate = new Date(0);
                }
                
                betsToFilter = betsToFilter.filter(bet =&gt; new Date(bet.placedAt) &gt;= startDate);
            }
        }

        return betsToFilter;
    }, [bets, selectedMarketCategory, dateRange, customDateRange]);


    const processedData = useMemo(() =&gt; {
        const initialData = {
            profitByBook: [], profitOverTime: [],
            marketCategoryStats: [], playerTeamStats: [], tailStats: [], sportStats: [],
            quickNetStats: { net1d: 0, net3d: 0, net1w: 0, net1m: 0, net1y: 0 },
            overallStats: { totalBets: 0, totalWagered: 0, netProfit: 0, wins: 0, losses: 0, winRate: 0, roi: 0 },
        };
        
        const now = new Date();
        const calculateNetForPeriod = (startDate: Date) =&gt; {
            return bets
                .filter(bet =&gt; new Date(bet.placedAt) &gt;= startDate)
                .reduce((sum, bet) =&gt; sum + (bet.payout - bet.stake), 0);
        };
        const quickNetStats = {
            net1d: calculateNetForPeriod(new Date(now.getTime() - 1 * 24 * 60 * 60 * 1000)),
            net3d: calculateNetForPeriod(new Date(now.getTime() - 3 * 24 * 60 * 60 * 1000)),
            net1w: calculateNetForPeriod(new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000)),
            net1m: calculateNetForPeriod(new Date(new Date().setMonth(now.getMonth() - 1))),
            net1y: calculateNetForPeriod(new Date(new Date().setFullYear(now.getFullYear() - 1))),
        };

        if (filteredBets.length === 0) return { ...initialData, quickNetStats };

        const overallStats = {
            totalBets: filteredBets.length,
            totalWagered: 0,
            netProfit: 0,
            wins: 0,
            losses: 0,
            winRate: 0,
            roi: 0
        };

        for (const bet of filteredBets) {
            const net = bet.payout - bet.stake;
            overallStats.totalWagered += bet.stake;
            overallStats.netProfit += net;
            if (bet.result === &apos;win&apos;) overallStats.wins++;
            if (bet.result === &apos;loss&apos;) overallStats.losses++;
        }

        overallStats.roi = overallStats.totalWagered &gt; 0 ? (overallStats.netProfit / overallStats.totalWagered) * 100 : 0;
        overallStats.winRate = (overallStats.wins + overallStats.losses) &gt; 0 ? (overallStats.wins / (overallStats.wins + overallStats.losses)) * 100 : 0;


        const sortedBets = [...filteredBets].sort((a, b) =&gt; new Date(a.placedAt).getTime() - new Date(b.placedAt).getTime());
        let cumulativeProfit = 0;
        const profitOverTime = sortedBets.map(bet =&gt; {
            cumulativeProfit += (bet.payout - bet.stake);
            return { date: new Date(bet.placedAt).toLocaleDateString(), profit: cumulativeProfit };
        });

        const profitByBookMap = new Map&lt;string, number&gt;();
        filteredBets.forEach(bet =&gt; {
            const profit = bet.payout - bet.stake;
            profitByBookMap.set(bet.book, (profitByBookMap.get(bet.book) || 0) + profit);
        });
        const profitByBook = Array.from(profitByBookMap.entries()).map(([name, profit]) =&gt; ({ name, profit }));
        
        const marketCategoryStatsMap = new Map&lt;string, { count: number; stake: number; net: number; wins: number; losses: number; }&gt;();
        const sportStatsMap = new Map&lt;string, { count: number; stake: number; net: number; wins: number; losses: number; }&gt;();
        const playerTeamStatsMap = new Map&lt;string, { count: number; stake: number; net: number; wins: number; losses: number; }&gt;();
        const tailStatsMap = new Map&lt;string, { count: number; stake: number; net: number; wins: number; losses: number; }&gt;();
        
        const addToMap = (map: Map&lt;string, any&gt;, key: string, stake: number, net: number, result: Bet[&apos;result&apos;]) =&gt; {
            if (!key) return;
            if (!map.has(key)) map.set(key, { count: 0, stake: 0, net: 0, wins: 0, losses: 0 });
            const stats = map.get(key)!;
            stats.count++;
            stats.stake += stake;
            stats.net += net;
            if (result === &apos;win&apos;) stats.wins++;
            if (result === &apos;loss&apos;) stats.losses++;
        };

        filteredBets.forEach(bet =&gt; {
            const net = bet.payout - bet.stake;
            const result = bet.result;
            addToMap(marketCategoryStatsMap, bet.marketCategory, bet.stake, net, result);
            addToMap(sportStatsMap, bet.sport, bet.stake, net, result);
            if (bet.tail) addToMap(tailStatsMap, bet.tail.trim(), bet.stake, net, result);
            
            if (bet.legs?.length) {
                bet.legs.forEach(leg =&gt; {
                    leg.entities?.forEach(entity =&gt; addToMap(playerTeamStatsMap, entity, bet.stake, net, result));
                });
            } else {
                const entity = extractEntityFromDescription(bet.description);
                addToMap(playerTeamStatsMap, entity, bet.stake, net, result);
            }
        });

        const calculateRoi = (s: { stake: number, net: number }) =&gt; s.stake &gt; 0 ? (s.net / s.stake) * 100 : 0;
        
        let playerTeamStats = Array.from(playerTeamStatsMap.entries()).map(([name, stats]) =&gt; ({ name, ...stats, roi: calculateRoi(stats) }));
        if (entityType === &apos;player&apos;) {
            playerTeamStats = playerTeamStats.filter(item =&gt; allPlayers.has(item.name));
        } else if (entityType === &apos;team&apos;) {
            playerTeamStats = playerTeamStats.filter(item =&gt; allTeams.has(item.name));
        }
        
        return {
            profitOverTime, profitByBook, quickNetStats, overallStats,
            marketCategoryStats: Array.from(marketCategoryStatsMap.entries()).map(([name, stats]) =&gt; ({ name, ...stats, roi: calculateRoi(stats) })),
            sportStats: Array.from(sportStatsMap.entries()).map(([name, stats]) =&gt; ({ name, ...stats, roi: calculateRoi(stats) })),
            playerTeamStats,
            tailStats: Array.from(tailStatsMap.entries()).map(([name, stats]) =&gt; ({ name, ...stats, roi: calculateRoi(stats) })),
        };
    }, [bets, filteredBets, allPlayers, allTeams, entityType]);

    const hasData = processedData.profitOverTime.length &gt; 0;

    if (loading) return &lt;div className=&quot;p-6 text-center&quot;&gt;Loading dashboard...&lt;/div&gt;;
    if (bets.length === 0) return &lt;div className=&quot;p-6 text-center text-neutral-500&quot;&gt;No data to display. Please import some bets first.&lt;/div&gt;;

    const EntityTypeButton: React.FC&lt;{ type: &apos;all&apos; | &apos;player&apos; | &apos;team&apos;, label: string }&gt; = ({ type, label }) =&gt; (
        &lt;button
            onClick={() =&gt; setEntityType(type)}
            className={`px-3 py-1.5 rounded-md font-medium text-xs transition-colors ${
                entityType === type
                ? &apos;bg-primary-600 text-white shadow&apos;
                : &apos;text-neutral-600 dark:text-neutral-300 hover:bg-white dark:hover:bg-neutral-700&apos;
            }`}
        &gt;
            {label}
        &lt;/button&gt;
    );

    return (
        &lt;div className=&quot;p-6 h-full flex flex-col space-y-6 bg-neutral-100 dark:bg-neutral-950 overflow-y-auto&quot;&gt;
            &lt;div className=&quot;flex-shrink-0 bg-white dark:bg-neutral-900 rounded-lg shadow-md p-6 space-y-6&quot;&gt;
                &lt;div&gt;
                    &lt;h1 className=&quot;text-3xl font-bold text-neutral-900 dark:text-white&quot;&gt;Dashboard&lt;/h1&gt;
                    &lt;p className=&quot;text-neutral-500 dark:text-neutral-400 mt-1&quot;&gt;A high-level overview of your betting performance.&lt;/p&gt;
                &lt;/div&gt;

                &lt;div className=&quot;grid grid-cols-2 md:grid-cols-3 lg:grid-cols-5 gap-6 border-t border-neutral-200 dark:border-neutral-800 pt-6&quot;&gt;
                    &lt;QuickStatCard label=&quot;Last 24h&quot; value={processedData.quickNetStats.net1d} /&gt;
                    &lt;QuickStatCard label=&quot;Last 3 Days&quot; value={processedData.quickNetStats.net3d} /&gt;
                    &lt;QuickStatCard label=&quot;Last Week&quot; value={processedData.quickNetStats.net1w} /&gt;
                    &lt;QuickStatCard label=&quot;Last Month&quot; value={processedData.quickNetStats.net1m} /&gt;
                    &lt;QuickStatCard label=&quot;Last Year&quot; value={processedData.quickNetStats.net1y} /&gt;
                &lt;/div&gt;
            &lt;/div&gt;

            &lt;div className=&quot;bg-white dark:bg-neutral-900 rounded-lg shadow-md p-6 space-y-4&quot;&gt;
                &lt;div className=&quot;flex flex-col sm:flex-row sm:justify-between sm:items-center gap-4&quot;&gt;
                    &lt;div className=&quot;flex items-center space-x-1 flex-wrap gap-y-2 bg-neutral-100 dark:bg-neutral-800/50 p-1 rounded-lg&quot;&gt;
                        &lt;button
                            onClick={() =&gt; setSelectedMarketCategory(&apos;all&apos;)}
                            className={`px-3 py-1.5 rounded-md font-medium text-xs transition-colors ${
                            selectedMarketCategory === &apos;all&apos;
                                ? &apos;bg-primary-600 text-white shadow&apos;
                                : &apos;text-neutral-600 dark:text-neutral-300 hover:bg-white dark:hover:bg-neutral-700&apos;
                            }`}
                        &gt;
                            All Categories
                        &lt;/button&gt;
                        {MARKET_CATEGORIES.map(cat =&gt; (
                            &lt;button
                                key={cat}
                                onClick={() =&gt; setSelectedMarketCategory(cat)}
                                className={`px-3 py-1.5 rounded-md font-medium text-xs transition-colors ${
                                selectedMarketCategory === cat
                                    ? &apos;bg-primary-600 text-white shadow&apos;
                                    : &apos;text-neutral-600 dark:text-neutral-300 hover:bg-white dark:hover:bg-neutral-700&apos;
                                }`}
                            &gt;
                                {cat}
                            &lt;/button&gt;
                        ))}
                    &lt;/div&gt;
                    &lt;div className=&quot;flex items-center space-x-1 flex-wrap gap-y-2 bg-neutral-100 dark:bg-neutral-800/50 p-1 rounded-lg&quot;&gt;
                        &lt;DateRangeButton range=&quot;all&quot; label=&quot;All Time&quot; currentRange={dateRange} onClick={setDateRange} /&gt;
                        &lt;DateRangeButton range=&quot;1d&quot; label=&quot;1D&quot; currentRange={dateRange} onClick={setDateRange} /&gt;
                        &lt;DateRangeButton range=&quot;3d&quot; label=&quot;3D&quot; currentRange={dateRange} onClick={setDateRange} /&gt;
                        &lt;DateRangeButton range=&quot;1w&quot; label=&quot;1W&quot; currentRange={dateRange} onClick={setDateRange} /&gt;
                        &lt;DateRangeButton range=&quot;1m&quot; label=&quot;1M&quot; currentRange={dateRange} onClick={setDateRange} /&gt;
                        &lt;DateRangeButton range=&quot;1y&quot; label=&quot;1Y&quot; currentRange={dateRange} onClick={setDateRange} /&gt;
                        &lt;DateRangeButton range=&quot;custom&quot; label=&quot;Custom&quot; currentRange={dateRange} onClick={setDateRange} /&gt;
                    &lt;/div&gt;
                &lt;/div&gt;

                {dateRange === &apos;custom&apos; &amp;&amp; (
                    &lt;div className=&quot;flex sm:justify-end items-center space-x-4&quot;&gt;
                        &lt;div className=&quot;flex items-center space-x-2&quot;&gt;
                            &lt;label htmlFor=&quot;start-date&quot; className=&quot;text-sm font-medium text-neutral-500 dark:text-neutral-400&quot;&gt;From&lt;/label&gt;
                            &lt;input
                                type=&quot;date&quot;
                                id=&quot;start-date&quot;
                                value={customDateRange.start}
                                onChange={e =&gt; setCustomDateRange(prev =&gt; ({ ...prev, start: e.target.value }))}
                                className=&quot;bg-neutral-50 dark:bg-neutral-800 border border-neutral-300 dark:border-neutral-600 text-neutral-900 dark:text-white text-sm rounded-lg focus:ring-primary-500 focus:border-primary-500 block w-full p-2&quot;
                            /&gt;
                        &lt;/div&gt;
                        &lt;div className=&quot;flex items-center space-x-2&quot;&gt;
                            &lt;label htmlFor=&quot;end-date&quot; className=&quot;text-sm font-medium text-neutral-500 dark:text-neutral-400&quot;&gt;To&lt;/label&gt;
                            &lt;input
                                type=&quot;date&quot;
                                id=&quot;end-date&quot;
                                value={customDateRange.end}
                                onChange={e =&gt; setCustomDateRange(prev =&gt; ({ ...prev, end: e.target.value }))}
                                className=&quot;bg-neutral-50 dark:bg-neutral-800 border border-neutral-300 dark:border-neutral-600 text-neutral-900 dark:text-white text-sm rounded-lg focus:ring-primary-500 focus:border-primary-500 block w-full p-2&quot;
                            /&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                )}

                {hasData ? (
                &lt;&gt;
                    &lt;div className=&quot;grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6&quot;&gt;
                        &lt;StatCard title=&quot;Net Profit&quot; value={`${processedData.overallStats.netProfit &gt;= 0 ? &apos;$&apos; : &apos;-$&apos;}${Math.abs(processedData.overallStats.netProfit).toFixed(2)}`} icon={&lt;Scale className=&quot;w-6 h-6&quot;/&gt;} change={`${processedData.overallStats.roi.toFixed(1)}% ROI`}/&gt;
                        &lt;StatCard title=&quot;Total Wagered&quot; value={`$${processedData.overallStats.totalWagered.toFixed(2)}`} icon={&lt;BarChart2 className=&quot;w-6 h-6&quot;/&gt;} /&gt;
                        &lt;StatCard title=&quot;Total Bets&quot; value={processedData.overallStats.totalBets.toString()} icon={&lt;BarChart2 className=&quot;w-6 h-6&quot;/&gt;} /&gt;
                        &lt;StatCard title=&quot;Win Rate&quot; value={`${processedData.overallStats.winRate.toFixed(1)}%`} icon={&lt;BarChart2 className=&quot;w-6 h-6&quot;/&gt;} change={`${processedData.overallStats.wins}-${processedData.overallStats.losses}`} /&gt;
                    &lt;/div&gt;
                    &lt;div className=&quot;grid grid-cols-1 lg:grid-cols-2 gap-6&quot;&gt;
                        &lt;ChartContainer title=&quot;Profit Over Time&quot;&gt;
                            &lt;ResponsiveContainer width=&quot;100%&quot; height=&quot;100%&quot;&gt;
                                &lt;LineChart data={processedData.profitOverTime}&gt;
                                    &lt;CartesianGrid strokeDasharray=&quot;3 3&quot; stroke=&quot;rgba(128, 128, 128, 0.2)&quot; /&gt;
                                    &lt;XAxis dataKey=&quot;date&quot; stroke=&quot;rgb(113, 113, 122)&quot; tick={{ fontSize: 12 }} /&gt;
                                    &lt;YAxis stroke=&quot;rgb(113, 113, 122)&quot; tick={{ fontSize: 12 }} tickFormatter={(value) =&gt; `$${value}`}/&gt;
                                    &lt;Tooltip content={&lt;CustomTooltip /&gt;} /&gt;
                                    &lt;Line type=&quot;monotone&quot; dataKey=&quot;profit&quot; name=&quot;Profit&quot; stroke=&quot;#8b5cf6&quot; strokeWidth={2} dot={false} /&gt;
                                &lt;/LineChart&gt;
                            &lt;/ResponsiveContainer&gt;
                        &lt;/ChartContainer&gt;

                        &lt;ChartContainer title=&quot;Total Profit by Sportsbook&quot;&gt;
                            &lt;ResponsiveContainer width=&quot;100%&quot; height=&quot;100%&quot;&gt;
                                &lt;BarChart data={processedData.profitByBook}&gt;
                                    &lt;CartesianGrid strokeDasharray=&quot;3 3&quot; stroke=&quot;rgba(128, 128, 128, 0.2)&quot; /&gt;
                                    &lt;XAxis dataKey=&quot;name&quot; stroke=&quot;rgb(113, 113, 122)&quot; tick={{ fontSize: 12 }} /&gt;
                                    &lt;YAxis stroke=&quot;rgb(113, 113, 122)&quot; tick={{ fontSize: 12 }} tickFormatter={(value) =&gt; `$${value}`}/&gt;
                                    &lt;Tooltip content={&lt;CustomTooltip /&gt;} /&gt;
                                    &lt;Bar dataKey=&quot;profit&quot; name=&quot;Profit&quot;&gt;
                                        {processedData.profitByBook.map((entry, index) =&gt; (
                                            &lt;Cell key={`cell-${index}`} fill={entry.profit &gt;= 0 ? &apos;#22c55e&apos; : &apos;#ef4444&apos;} /&gt;
                                        ))}
                                    &lt;/Bar&gt;
                                &lt;/BarChart&gt;
                            &lt;/ResponsiveContainer&gt;
                        &lt;/ChartContainer&gt;
                    &lt;/div&gt;
                &lt;/&gt;
                ) : (
                    &lt;div className=&quot;flex-grow flex items-center justify-center&quot;&gt;
                        &lt;div className=&quot;text-center text-neutral-500 dark:text-neutral-400 p-8&quot;&gt;
                            &lt;BarChart2 className=&quot;w-16 h-16 mx-auto text-neutral-400 dark:text-neutral-600&quot; /&gt;
                            &lt;h3 className=&quot;mt-4 text-xl font-semibold&quot;&gt;No Data Found&lt;/h3&gt;
                            &lt;p className=&quot;mt-1&quot;&gt;No betting data matches your selected filters.&lt;/p&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                )}
            &lt;/div&gt;
            
            {hasData &amp;&amp; (
                &lt;div className=&quot;pt-4 border-t border-neutral-200 dark:border-neutral-800&quot;&gt;
                    &lt;div className=&quot;flex items-center space-x-3 mb-6&quot;&gt;
                        &lt;BarChart2 className=&quot;w-8 h-8 text-primary-500&quot; /&gt;
                        &lt;h2 className=&quot;text-2xl font-bold text-neutral-900 dark:text-white&quot;&gt;Performance Review&lt;/h2&gt;
                    &lt;/div&gt;
                    &lt;div className=&quot;space-y-6&quot;&gt;
                        &lt;StatsTable data={processedData.marketCategoryStats} title=&quot;Performance by Market Category&quot; searchPlaceholder=&quot;Search category...&quot; /&gt;
                        &lt;StatsTable data={processedData.sportStats} title=&quot;Performance by Sport&quot; searchPlaceholder=&quot;Search sport...&quot; /&gt;
                        &lt;div className=&quot;h-[500px]&quot;&gt;
                            &lt;StatsTable data={processedData.playerTeamStats} title=&quot;Player &amp; Team Performance&quot; searchPlaceholder=&quot;Search player/team...&quot; className=&quot;h-full&quot;&gt;
                                &lt;div className=&quot;flex items-center space-x-1 flex-wrap gap-y-2 bg-neutral-100 dark:bg-neutral-800/50 p-1 rounded-lg&quot;&gt;
                                    &lt;EntityTypeButton type=&quot;all&quot; label=&quot;All&quot; /&gt;
                                    &lt;EntityTypeButton type=&quot;player&quot; label=&quot;Player&quot; /&gt;
                                    &lt;EntityTypeButton type=&quot;team&quot; label=&quot;Team&quot; /&gt;
                                &lt;/div&gt;
                            &lt;/StatsTable&gt;
                        &lt;/div&gt;
                        &lt;div className=&quot;grid grid-cols-1 lg:grid-cols-2 gap-6&quot;&gt;
                            &lt;OverUnderBreakdown bets={filteredBets} /&gt;
                            &lt;LiveVsPreMatchBreakdown bets={filteredBets} /&gt;
                        &lt;/div&gt;
                        {processedData.tailStats.length &gt; 0 &amp;&amp; (
                            &lt;StatsTable data={processedData.tailStats} title=&quot;Performance by Tail&quot; searchPlaceholder=&quot;Search tail...&quot; /&gt;
                        )}
                    &lt;/div&gt;
                &lt;/div&gt;
            )}
        &lt;/div&gt;
    );
};

export default DashboardView;</file><file path="views/ImportView.tsx">import React, { useState } from &apos;react&apos;;
import { useBets } from &apos;../hooks/useBets&apos;;
import { useInputs } from &apos;../hooks/useInputs&apos;;
import { SportsbookName } from &apos;../types&apos;;
import { AlertTriangle, CheckCircle2, ExternalLink } from &apos;../components/icons&apos;;
import { ManualPasteSourceProvider } from &apos;../services/pageSourceProvider&apos;;
import { handleImport } from &apos;../services/importer&apos;;
import { NoSourceDataError } from &apos;../services/errors&apos;;

const ImportView: React.FC = () =&gt; {
  const { addBets } = useBets();
  const { sportsbooks } = useInputs();
  const [selectedBook, setSelectedBook] = useState&lt;SportsbookName&gt;(sportsbooks[0]?.name || &apos;&apos;);
  const [pageHtml, setPageHtml] = useState(&apos;&apos;);
  const [notification, setNotification] = useState&lt;{ message: string; type: &apos;success&apos; | &apos;info&apos; | &apos;error&apos; } | null&gt;(null);
  const [isImporting, setIsImporting] = useState(false);
  
  const selectedBookUrl = sportsbooks.find(b =&gt; b.name === selectedBook)?.url || &apos;https://google.com/search?q=sportsbooks&apos;;

  const handleImportClick = async () =&gt; {
    if (!selectedBook) {
        showNotification(&apos;Please select a sportsbook first.&apos;, &apos;error&apos;);
        return;
    }
    setIsImporting(true);
    setNotification(null);

    const sourceProvider = new ManualPasteSourceProvider(() =&gt; pageHtml);
    
    try {
      const { foundCount, importedCount } = await handleImport(selectedBook, sourceProvider, addBets);

      if (foundCount &gt; 0) {
        if (importedCount &gt; 0) {
          showNotification(`Imported ${importedCount} new bets out of ${foundCount} found.`, &apos;success&apos;);
        } else {
          showNotification(`Found ${foundCount} bets, but none were new.`, &apos;info&apos;);
        }
      } else {
        showNotification(`Could not find any bets to import. Check the source or parser.`, &apos;error&apos;);
      }
      setPageHtml(&apos;&apos;);
    } catch (error) {
      if (error instanceof NoSourceDataError) {
        showNotification(error.message, &apos;error&apos;);
      } else {
        console.error(&quot;Import failed:&quot;, error);
        showNotification(`An unexpected error occurred during import. Check console for details.`, &apos;error&apos;);
      }
    } finally {
      setIsImporting(false);
    }
  };

  const showNotification = (message: string, type: &apos;success&apos; | &apos;info&apos; | &apos;error&apos;) =&gt; {
    setNotification({ message, type });
    setTimeout(() =&gt; setNotification(null), 5000);
  };
  
  const NotificationBanner = () =&gt; {
    if (!notification) return null;
    
    const colors = {
      success: &apos;bg-accent-900/50 border-accent-700 text-accent-300&apos;,
      info: &apos;bg-primary-900/50 border-primary-700 text-primary-300&apos;,
      error: &apos;bg-danger-900/50 border-danger-700 text-danger-300&apos;,
    };
    const Icon = notification.type === &apos;success&apos; ? CheckCircle2 : AlertTriangle;

    return (
      &lt;div className={`fixed top-8 right-8 z-50 p-4 rounded-lg border flex items-center space-x-3 shadow-lg transition-transform animate-pulse ${colors[notification.type]}`}&gt;
        &lt;Icon className=&quot;w-6 h-6&quot; /&gt;
        &lt;span className=&quot;font-medium&quot;&gt;{notification.message}&lt;/span&gt;
      &lt;/div&gt;
    );
  };

  return (
    &lt;div className=&quot;p-6 h-full flex flex-col space-y-4 bg-neutral-100 dark:bg-neutral-950&quot;&gt;
      {NotificationBanner()}
      &lt;header className=&quot;flex-shrink-0&quot;&gt;
        &lt;h1 className=&quot;text-3xl font-bold text-neutral-900 dark:text-white&quot;&gt;Import Bets&lt;/h1&gt;
        &lt;p className=&quot;text-neutral-500 dark:text-neutral-400 mt-1&quot;&gt;Navigate to your bet history and paste the page source to import.&lt;/p&gt;
      &lt;/header&gt;
      
      &lt;div className=&quot;flex-shrink-0 p-4 bg-white dark:bg-neutral-900 rounded-lg shadow-md flex items-center justify-between&quot;&gt;
        &lt;div className=&quot;flex items-center space-x-4&quot;&gt;
          &lt;label htmlFor=&quot;sportsbook-select&quot; className=&quot;font-medium text-neutral-700 dark:text-neutral-300&quot;&gt;Sportsbook:&lt;/label&gt;
          &lt;select
            id=&quot;sportsbook-select&quot;
            value={selectedBook}
            onChange={(e) =&gt; setSelectedBook(e.target.value as SportsbookName)}
            className=&quot;bg-neutral-50 dark:bg-neutral-800 border border-neutral-300 dark:border-neutral-600 text-neutral-900 dark:text-white text-sm rounded-lg focus:ring-primary-500 focus:border-primary-500 block w-full p-2.5&quot;
            disabled={isImporting}
          &gt;
            {sportsbooks.map((book) =&gt; (
              &lt;option key={book.name} value={book.name}&gt;{book.name}&lt;/option&gt;
            ))}
          &lt;/select&gt;
        &lt;/div&gt;
        &lt;button
          onClick={handleImportClick}
          disabled={isImporting || !pageHtml}
          className=&quot;px-6 py-2.5 bg-primary-600 text-white font-semibold rounded-lg shadow-md hover:bg-primary-700 focus:outline-none focus:ring-2 focus:ring-primary-500 focus:ring-opacity-75 transition-transform transform hover:scale-105 disabled:bg-neutral-600 dark:disabled:bg-neutral-700 disabled:cursor-not-allowed&quot;
        &gt;
          {isImporting ? &apos;Importing...&apos; : &apos;Import Bets From Source&apos;}
        &lt;/button&gt;
      &lt;/div&gt;

      &lt;div className=&quot;flex-grow grid grid-cols-1 lg:grid-cols-2 gap-4 min-h-0&quot;&gt;
        &lt;div className=&quot;flex flex-col bg-white dark:bg-neutral-900 rounded-lg shadow-md&quot;&gt;
            &lt;div className=&quot;p-3 bg-neutral-50 dark:bg-neutral-800/50 border-b border-neutral-200 dark:border-neutral-800 flex items-center justify-between&quot;&gt;
                &lt;h2 className=&quot;text-lg font-semibold&quot;&gt;Browser View&lt;/h2&gt;
                 &lt;a href={selectedBookUrl} target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; className=&quot;inline-flex items-center px-3 py-1 bg-neutral-100 dark:bg-neutral-700 text-xs font-medium rounded-md hover:bg-neutral-200 dark:hover:bg-neutral-600&quot;&gt;
                    Open in New Tab &lt;ExternalLink className=&quot;w-3 h-3 ml-1.5&quot; /&gt;
                &lt;/a&gt;
            &lt;/div&gt;
            &lt;div className=&quot;p-2 bg-yellow-400/10 border-b border-yellow-400/20&quot;&gt;
                &lt;p className=&quot;text-xs text-yellow-800 dark:text-yellow-300 text-center&quot;&gt;
                    &lt;b&gt;Note:&lt;/b&gt; Most sites block being embedded for security. This view is a placeholder for the real desktop app.
                &lt;/p&gt;
            &lt;/div&gt;
            &lt;iframe
                key={selectedBook}
                src={selectedBookUrl}
                className=&quot;w-full flex-grow border-0&quot;
                title={`${selectedBook} Browser`}
                sandbox=&quot;allow-scripts allow-same-origin&quot;
            &gt;&lt;/iframe&gt;
        &lt;/div&gt;

        &lt;div className=&quot;flex flex-col bg-white dark:bg-neutral-900 rounded-lg shadow-md&quot;&gt;
           &lt;div className=&quot;p-3 bg-neutral-50 dark:bg-neutral-800/50 border-b border-neutral-200 dark:border-neutral-800&quot;&gt;
            &lt;h2 className=&quot;text-lg font-semibold&quot;&gt;Paste Page Source Here&lt;/h2&gt;
          &lt;/div&gt;
          &lt;textarea
            value={pageHtml}
            onChange={(e) =&gt; setPageHtml(e.target.value)}
            placeholder={`1. Navigate to your ${selectedBook} settled bets page.\n2. Right-click -&gt; View Page Source.\n3. Copy everything (Ctrl+A, Ctrl+C).\n4. Paste it here (Ctrl+V).`}
            className=&quot;w-full flex-grow p-4 bg-neutral-50 dark:bg-neutral-800 text-neutral-800 dark:text-neutral-200 focus:outline-none focus:ring-2 focus:ring-primary-500 resize-none font-mono text-xs leading-relaxed&quot;
            disabled={isImporting}
          &gt;&lt;/textarea&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
};

export default ImportView;</file><file path="views/InputManagementView.tsx">import React, { useState, useMemo } from &apos;react&apos;;
import { useInputs, ItemsBySport } from &apos;../hooks/useInputs&apos;;
import { Trash2, ChevronDown } from &apos;../components/icons&apos;;

const Accordion: React.FC&lt;{title: string, description: string, children: React.ReactNode}&gt; = ({title, description, children}) =&gt; {
    const [isOpen, setIsOpen] = useState(false);
    
    return (
        &lt;div className=&quot;bg-white dark:bg-neutral-900 rounded-lg shadow-md transition-all duration-300&quot;&gt;
            &lt;button
                onClick={() =&gt; setIsOpen(!isOpen)}
                className=&quot;w-full flex justify-between items-center p-6 text-left&quot;
                aria-expanded={isOpen}
                aria-controls={`accordion-content-${title.replace(/\s/g, &apos;-&apos;)}`}
            &gt;
                &lt;div&gt;
                    &lt;h3 className=&quot;text-lg font-semibold text-neutral-900 dark:text-white&quot;&gt;{title}&lt;/h3&gt;
                    &lt;p className=&quot;text-neutral-500 dark:text-neutral-400 mt-1 text-sm&quot;&gt;{description}&lt;/p&gt;
                &lt;/div&gt;
                &lt;ChevronDown className={`w-6 h-6 text-neutral-500 transform transition-transform duration-300 ${isOpen ? &apos;rotate-180&apos; : &apos;&apos;}`} /&gt;
            &lt;/button&gt;
            {isOpen &amp;&amp; (
                &lt;div 
                    id={`accordion-content-${title.replace(/\s/g, &apos;-&apos;)}`}
                    className=&quot;bg-neutral-50 dark:bg-neutral-900/50 p-6 rounded-b-lg border-t border-neutral-200 dark:border-neutral-800&quot;
                &gt;
                    {children}
                &lt;/div&gt;
            )}
        &lt;/div&gt;
    );
};

const SportFilterButtons: React.FC&lt;{ sports: string[], selected: string, onSelect: (sport: string) =&gt; void }&gt; = ({ sports, selected, onSelect }) =&gt; (
    &lt;div className=&quot;flex items-center space-x-2 flex-wrap gap-y-2 mb-4&quot;&gt;
        &lt;button
            onClick={() =&gt; onSelect(&apos;All&apos;)}
            className={`px-3 py-1.5 rounded-md font-semibold text-xs transition-colors ${
                selected === &apos;All&apos;
                ? &apos;bg-primary-600 text-white shadow&apos;
                : &apos;text-neutral-600 dark:text-neutral-300 bg-neutral-100 dark:bg-neutral-800 hover:bg-neutral-200 dark:hover:bg-neutral-700&apos;
            }`}
        &gt;
            All
        &lt;/button&gt;
        {sports.map(sport =&gt; (
            &lt;button
                key={sport}
                onClick={() =&gt; onSelect(sport)}
                className={`px-3 py-1.5 rounded-md font-semibold text-xs transition-colors ${
                    selected === sport
                    ? &apos;bg-primary-600 text-white shadow&apos;
                    : &apos;text-neutral-600 dark:text-neutral-300 bg-neutral-100 dark:bg-neutral-800 hover:bg-neutral-200 dark:hover:bg-neutral-700&apos;
                }`}
            &gt;
                {sport}
            &lt;/button&gt;
        ))}
    &lt;/div&gt;
);


const SportsbooksManager: React.FC = () =&gt; {
    const { sportsbooks, addSportsbook, removeSportsbook } = useInputs();
    const [name, setName] = useState(&apos;&apos;);
    const [abbreviation, setAbbreviation] = useState(&apos;&apos;);
    const [url, setUrl] = useState(&apos;&apos;);

    const handleAdd = () =&gt; {
        if (name &amp;&amp; abbreviation &amp;&amp; url) {
            if (addSportsbook({ name, abbreviation, url })) {
                setName(&apos;&apos;);
                setAbbreviation(&apos;&apos;);
                setUrl(&apos;&apos;);
            } else {
                alert(`Sportsbook &quot;${name}&quot; already exists.`);
            }
        }
    };

    return (
        &lt;Accordion title=&quot;Sportsbooks&quot; description=&quot;Manage the sportsbooks you bet on.&quot;&gt;
            &lt;div className=&quot;space-y-4&quot;&gt;
                &lt;div className=&quot;grid grid-cols-1 md:grid-cols-4 gap-4 items-end&quot;&gt;
                    &lt;input value={name} onChange={e =&gt; setName(e.target.value)} placeholder=&quot;Full Name (e.g., BetMGM)&quot; className=&quot;md:col-span-2 bg-white dark:bg-neutral-800 border border-neutral-300 dark:border-neutral-700 rounded-md p-2 text-sm w-full&quot; /&gt;
                    &lt;input value={abbreviation} onChange={e =&gt; setAbbreviation(e.target.value)} placeholder=&quot;Abbr. (e.g., MGM)&quot; className=&quot;bg-white dark:bg-neutral-800 border border-neutral-300 dark:border-neutral-700 rounded-md p-2 text-sm w-full&quot; /&gt;
                    &lt;button onClick={handleAdd} className=&quot;bg-primary-600 text-white px-4 py-2 rounded-md text-sm font-semibold hover:bg-primary-700 disabled:bg-neutral-500&quot; disabled={!name || !abbreviation || !url}&gt;Add&lt;/button&gt;
                    &lt;input value={url} onChange={e =&gt; setUrl(e.target.value)} placeholder=&quot;URL (e.g., https://betmgm.com)&quot; className=&quot;col-span-full bg-white dark:bg-neutral-800 border border-neutral-300 dark:border-neutral-700 rounded-md p-2 text-sm w-full&quot; /&gt;
                &lt;/div&gt;
                &lt;div className=&quot;max-h-60 overflow-y-auto pr-2&quot;&gt;
                    &lt;ul className=&quot;space-y-2&quot;&gt;
                        {sportsbooks.map((book, index) =&gt; (
                            &lt;li key={book.name} className={`flex justify-between items-center p-2 rounded-md ${index % 2 === 0 ? &apos;bg-white dark:bg-neutral-800&apos; : &apos;bg-neutral-50 dark:bg-neutral-800/50&apos;}`}&gt;
                                &lt;div&gt;
                                    &lt;span className=&quot;font-semibold&quot;&gt;{book.name} ({book.abbreviation})&lt;/span&gt;
                                    &lt;span className=&quot;text-xs text-neutral-500 dark:text-neutral-400 ml-2&quot;&gt;{book.url}&lt;/span&gt;
                                &lt;/div&gt;
                                &lt;button onClick={() =&gt; removeSportsbook(book.name)} className=&quot;text-danger-500 hover:text-danger-700&quot;&gt;&lt;Trash2 className=&quot;w-4 h-4&quot;/&gt;&lt;/button&gt;
                            &lt;/li&gt;
                        ))}
                    &lt;/ul&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/Accordion&gt;
    );
};

const ListManager: React.FC&lt;{title: string, description: string, items: string[], onAdd: (item: string) =&gt; boolean, onRemove: (item: string) =&gt; void, placeholder: string, canAdd?: boolean}&gt; = ({ title, description, items, onAdd, onRemove, placeholder, canAdd = true }) =&gt; {
    const [newItem, setNewItem] = useState(&apos;&apos;);
    const handleAdd = () =&gt; {
        if (newItem) {
            if (onAdd(newItem)) {
                setNewItem(&apos;&apos;);
            } else {
                alert(`&quot;${newItem}&quot; already exists.`);
            }
        }
    };
    return (
        &lt;Accordion title={title} description={description}&gt;
            &lt;div className=&quot;space-y-4&quot;&gt;
                {canAdd &amp;&amp; (
                  &lt;div className=&quot;flex gap-4&quot;&gt;
                      &lt;input value={newItem} onChange={e =&gt; setNewItem(e.target.value)} placeholder={placeholder} className=&quot;bg-white dark:bg-neutral-800 border border-neutral-300 dark:border-neutral-700 rounded-md p-2 text-sm w-full&quot; /&gt;
                      &lt;button onClick={handleAdd} className=&quot;bg-primary-600 text-white px-4 py-2 rounded-md text-sm font-semibold hover:bg-primary-700 disabled:bg-neutral-500&quot; disabled={!newItem}&gt;Add&lt;/button&gt;
                  &lt;/div&gt;
                )}
                &lt;div className=&quot;max-h-60 overflow-y-auto pr-2&quot;&gt;
                    &lt;ul className=&quot;space-y-2&quot;&gt;
                        {items.map((item, index) =&gt; (
                            &lt;li key={item} className={`flex justify-between items-center p-2 rounded-md ${index % 2 === 0 ? &apos;bg-white dark:bg-neutral-800&apos; : &apos;bg-neutral-50 dark:bg-neutral-800/50&apos;}`}&gt;
                                &lt;span className=&quot;font-semibold&quot;&gt;{item}&lt;/span&gt;
                                &lt;button onClick={() =&gt; onRemove(item)} className=&quot;text-danger-500 hover:text-danger-700&quot;&gt;&lt;Trash2 className=&quot;w-4 h-4&quot;/&gt;&lt;/button&gt;
                            &lt;/li&gt;
                        ))}
                    &lt;/ul&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/Accordion&gt;
    );
};

const BetTypesManager: React.FC = () =&gt; {
    const { sports, betTypes, addBetType, removeBetType } = useInputs();
    const [selectedSport, setSelectedSport] = useState(sports[0] || &apos;&apos;);
    const [newType, setNewType] = useState(&apos;&apos;);
    const [filterSport, setFilterSport] = useState(&apos;All&apos;);

    const handleAdd = () =&gt; {
        if (selectedSport &amp;&amp; newType) {
            if (addBetType(selectedSport, newType)) {
                setNewType(&apos;&apos;);
            } else {
                alert(`Bet type &quot;${newType}&quot; already exists for ${selectedSport}.`);
            }
        }
    };

    // Fix: Add explicit return type &lt;ItemsBySport&gt; to useMemo to ensure correct type inference.
    const filteredBetTypes = useMemo&lt;ItemsBySport&gt;(() =&gt; {
        if (filterSport === &apos;All&apos;) return betTypes;
        if (betTypes[filterSport]) {
            return { [filterSport]: betTypes[filterSport] };
        }
        return {};
    }, [betTypes, filterSport]);

    return (
        &lt;Accordion title=&quot;Bet Types by Sport&quot; description=&quot;Organize bet markets for accurate filtering on the dashboard.&quot;&gt;
            &lt;div className=&quot;space-y-4&quot;&gt;
                &lt;div className=&quot;flex gap-4&quot;&gt;
                    &lt;select value={selectedSport} onChange={e =&gt; setSelectedSport(e.target.value)} className=&quot;bg-white dark:bg-neutral-800 border border-neutral-300 dark:border-neutral-700 rounded-md p-2 text-sm&quot;&gt;
                        {sports.map(s =&gt; &lt;option key={s} value={s}&gt;{s}&lt;/option&gt;)}
                    &lt;/select&gt;
                    &lt;input value={newType} onChange={e =&gt; setNewType(e.target.value)} placeholder=&quot;e.g., Player Points&quot; className=&quot;bg-white dark:bg-neutral-800 border border-neutral-300 dark:border-neutral-700 rounded-md p-2 text-sm w-full&quot; /&gt;
                    &lt;button onClick={handleAdd} className=&quot;bg-primary-600 text-white px-4 py-2 rounded-md text-sm font-semibold hover:bg-primary-700 disabled:bg-neutral-500&quot; disabled={!selectedSport || !newType}&gt;Add&lt;/button&gt;
                &lt;/div&gt;
                &lt;SportFilterButtons sports={sports} selected={filterSport} onSelect={setFilterSport} /&gt;
                 &lt;div className=&quot;max-h-96 overflow-y-auto pr-2 space-y-4&quot;&gt;
                    {Object.keys(filteredBetTypes).length === 0 &amp;&amp; &lt;p className=&quot;text-sm text-neutral-500 dark:text-neutral-400&quot;&gt;No items to display for this filter.&lt;/p&gt;}
                    {/* FIX: Cast the result of Object.entries to [string, string[]][] to provide a concrete type for `types`, resolving errors on `.map()` and `.length`. */}
                    {(Object.entries(filteredBetTypes) as [string, string[]][]).map(([sport, types]) =&gt; (
                        &lt;div key={sport}&gt;
                            &lt;h4 className=&quot;font-bold text-neutral-800 dark:text-neutral-200 mb-2&quot;&gt;{sport}&lt;/h4&gt;
                            &lt;ul className=&quot;space-y-2&quot;&gt;
                                {types.map((type, index) =&gt; (
                                     &lt;li key={type} className={`flex justify-between items-center p-2 rounded-md ${index % 2 === 0 ? &apos;bg-white dark:bg-neutral-800&apos; : &apos;bg-neutral-50 dark:bg-neutral-800/50&apos;}`}&gt;
                                        &lt;span className=&quot;font-semibold&quot;&gt;{type}&lt;/span&gt;
                                        &lt;button onClick={() =&gt; removeBetType(sport, type)} className=&quot;text-danger-500 hover:text-danger-700&quot;&gt;&lt;Trash2 className=&quot;w-4 h-4&quot;/&gt;&lt;/button&gt;
                                    &lt;/li&gt;
                                ))}
                                {types.length === 0 &amp;&amp; &lt;p className=&quot;text-xs text-neutral-500 dark:text-neutral-400&quot;&gt;No bet types for this sport.&lt;/p&gt;}
                            &lt;/ul&gt;
                        &lt;/div&gt;
                    ))}
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/Accordion&gt;
    )
}

const SportFilteredListManager: React.FC&lt;{
    title: string;
    description: string;
    itemsBySport: ItemsBySport;
    sports: string[];
    onRemove: (sport: string, item: string) =&gt; void;
}&gt; = ({ title, description, itemsBySport, sports, onRemove }) =&gt; {
    const [filterSport, setFilterSport] = useState(&apos;All&apos;);

    // Fix: Add explicit return type &lt;ItemsBySport&gt; to useMemo to ensure correct type inference.
    // This resolves an issue where TypeScript could not infer the type of `items`, leading to an error when calling `.map()`.
    const displayedItemsBySport = useMemo&lt;ItemsBySport&gt;(() =&gt; {
        if (filterSport === &apos;All&apos;) {
            return itemsBySport;
        }
        if (itemsBySport[filterSport]) {
            return { [filterSport]: itemsBySport[filterSport] };
        }
        return {};
    }, [itemsBySport, filterSport]);

    return (
        &lt;Accordion title={title} description={description}&gt;
            &lt;div className=&quot;space-y-4&quot;&gt;
                &lt;SportFilterButtons sports={sports} selected={filterSport} onSelect={setFilterSport} /&gt;
                &lt;div className=&quot;max-h-96 overflow-y-auto pr-2 space-y-4&quot;&gt;
                    {Object.keys(displayedItemsBySport).length === 0 &amp;&amp; &lt;p className=&quot;text-sm text-neutral-500 dark:text-neutral-400&quot;&gt;No items to display for this filter.&lt;/p&gt;}
                    {/* FIX: Cast the result of Object.entries to [string, string[]][] to provide a concrete type for `items`, resolving the error on `.map()`. */}
                    {(Object.entries(displayedItemsBySport) as [string, string[]][]).map(([sport, items]) =&gt; (
                        &lt;div key={sport}&gt;
                            &lt;h4 className=&quot;font-bold text-neutral-800 dark:text-neutral-200 mb-2&quot;&gt;{sport}&lt;/h4&gt;
                            &lt;ul className=&quot;space-y-2&quot;&gt;
                                {items.map((item, index) =&gt; (
                                     &lt;li key={item} className={`flex justify-between items-center p-2 rounded-md ${index % 2 === 0 ? &apos;bg-white dark:bg-neutral-800&apos; : &apos;bg-neutral-50 dark:bg-neutral-800/50&apos;}`}&gt;
                                        &lt;span className=&quot;font-semibold&quot;&gt;{item}&lt;/span&gt;
                                        &lt;button onClick={() =&gt; onRemove(sport, item)} className=&quot;text-danger-500 hover:text-danger-700&quot;&gt;&lt;Trash2 className=&quot;w-4 h-4&quot;/&gt;&lt;/button&gt;
                                    &lt;/li&gt;
                                ))}
                            &lt;/ul&gt;
                        &lt;/div&gt;
                    ))}
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/Accordion&gt;
    );
};


const InputManagementSection: React.FC = () =&gt; {
    const inputs = useInputs();

    return (
        &lt;div className=&quot;space-y-4&quot;&gt;
            &lt;SportsbooksManager /&gt;
            &lt;ListManager title=&quot;Sports&quot; description=&quot;Manage the sports you track.&quot; items={inputs.sports} onAdd={inputs.addSport} onRemove={inputs.removeSport} placeholder=&quot;e.g., NBA&quot; /&gt;
            &lt;BetTypesManager /&gt;
            &lt;SportFilteredListManager 
                title=&quot;Players&quot; 
                description=&quot;Automatically populated on import, can be managed here.&quot; 
                itemsBySport={inputs.players}
                sports={inputs.sports}
                onRemove={inputs.removePlayer}
            /&gt;
            &lt;SportFilteredListManager 
                title=&quot;Teams&quot; 
                description=&quot;Automatically populated on import, can be managed here.&quot; 
                itemsBySport={inputs.teams}
                sports={inputs.sports}
                onRemove={inputs.removeTeam}
            /&gt;
        &lt;/div&gt;
    );
};

export default InputManagementSection;</file><file path="views/PlayerProfileView.tsx">import React, { useState, useMemo, useEffect } from &apos;react&apos;;
import { useBets } from &apos;../hooks/useBets&apos;;
import { useInputs } from &apos;../hooks/useInputs&apos;;
import { BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer, LineChart, Line, PieChart, Pie, Cell, Sector } from &apos;recharts&apos;;
import { TrendingUp, TrendingDown, Scale, BarChart2, User } from &apos;../components/icons&apos;;
import { Bet } from &apos;../types&apos;;

// --- HELPER COMPONENTS ---

const CustomTooltip = ({ active, payload, label }: any) =&gt; {
    if (active &amp;&amp; payload &amp;&amp; payload.length) {
        return (
            &lt;div className=&quot;bg-white dark:bg-neutral-800 p-2 border border-neutral-300 dark:border-neutral-600 rounded shadow-lg text-sm&quot;&gt;
                &lt;p className=&quot;label font-bold mb-1&quot;&gt;{`${label}`}&lt;/p&gt;
                {payload.map((pld: any, index: number) =&gt; (
                    &lt;p key={index} style={{ color: pld.color }}&gt;
                        {`${pld.name}: ${typeof pld.value === &apos;number&apos; ? pld.value.toFixed(2) : pld.value}`}
                    &lt;/p&gt;
                ))}
            &lt;/div&gt;
        );
    }
    return null;
};

const ChartContainer: React.FC&lt;{ title: string; children: React.ReactNode }&gt; = ({ title, children }) =&gt; (
    &lt;div className=&quot;bg-white dark:bg-neutral-900 rounded-lg shadow-md p-6&quot;&gt;
        &lt;h2 className=&quot;text-xl font-semibold mb-4 text-neutral-800 dark:text-neutral-200&quot;&gt;{title}&lt;/h2&gt;
        &lt;div className=&quot;h-72&quot;&gt;{children}&lt;/div&gt;
    &lt;/div&gt;
);

const StatCard: React.FC&lt;{ title: string; value: string; icon: React.ReactNode; change?: string; }&gt; = ({ title, value, icon, change }) =&gt; {
    const isPositive = change &amp;&amp; parseFloat(change) &gt; 0;
    const isNegative = change &amp;&amp; parseFloat(change) &lt; 0;
    const changeColor = isPositive ? &apos;text-accent-500&apos; : isNegative ? &apos;text-danger-500&apos; : &apos;text-neutral-500 dark:text-neutral-400&apos;;

    return (
        &lt;div className=&quot;bg-white dark:bg-neutral-900 p-6 rounded-lg shadow-md flex items-start justify-between&quot;&gt;
            &lt;div&gt;
                &lt;p className=&quot;text-sm font-medium text-neutral-500 dark:text-neutral-400 uppercase&quot;&gt;{title}&lt;/p&gt;
                &lt;p className=&quot;text-3xl font-bold text-neutral-900 dark:text-white mt-1&quot;&gt;{value}&lt;/p&gt;
                {change &amp;&amp; (
                    &lt;p className={`text-sm font-semibold flex items-center mt-2 ${changeColor}`}&gt;
                        {isPositive &amp;&amp; &lt;TrendingUp className=&quot;w-4 h-4 mr-1&quot; /&gt;}
                        {isNegative &amp;&amp; &lt;TrendingDown className=&quot;w-4 h-4 mr-1&quot; /&gt;}
                        {change}
                    &lt;/p&gt;
                )}
            &lt;/div&gt;
            &lt;div className=&quot;bg-primary-100 dark:bg-primary-900/50 text-primary-600 dark:text-primary-400 p-3 rounded-full&quot;&gt;
                {icon}
            &lt;/div&gt;
        &lt;/div&gt;
    );
};


type StatsData = { name: string; count: number; wins: number; losses: number; stake: number; net: number; roi: number };
interface StatsTableProps {
    data: StatsData[];
    title: string;
}

const StatsTable: React.FC&lt;StatsTableProps&gt; = ({ data, title }) =&gt; {
    const [sortConfig, setSortConfig] = useState&lt;{ key: keyof StatsData; direction: &apos;asc&apos; | &apos;desc&apos; }&gt;({ key: &apos;net&apos;, direction: &apos;desc&apos; });
    const [searchTerm, setSearchTerm] = useState(&apos;&apos;);
    
    const sortedData = useMemo(() =&gt; {
        const filteredData = data.filter(item =&gt; item.name.toLowerCase().includes(searchTerm.toLowerCase()));
        return [...filteredData].sort((a, b) =&gt; {
            if (a[sortConfig.key] &lt; b[sortConfig.key]) return sortConfig.direction === &apos;asc&apos; ? -1 : 1;
            if (a[sortConfig.key] &gt; b[sortConfig.key]) return sortConfig.direction === &apos;asc&apos; ? 1 : -1;
            return 0;
        });
    }, [data, sortConfig, searchTerm]);

    const requestSort = (key: keyof StatsData) =&gt; {
        let direction: &apos;asc&apos; | &apos;desc&apos; = &apos;asc&apos;;
        if (sortConfig.key === key &amp;&amp; sortConfig.direction === &apos;asc&apos;) {
            direction = &apos;desc&apos;;
        }
        setSortConfig({ key, direction });
    };
    
    const headers: { key: keyof StatsData | &apos;win_pct&apos;; label: string; sortable: boolean }[] = [
        { key: &apos;name&apos;, label: &apos;Market&apos;, sortable: true },
        { key: &apos;count&apos;, label: &apos;Bets&apos;, sortable: true },
        { key: &apos;wins&apos;, label: &apos;Win&apos;, sortable: true },
        { key: &apos;losses&apos;, label: &apos;Loss&apos;, sortable: true },
        { key: &apos;win_pct&apos;, label: &apos;Win %&apos;, sortable: false },
        { key: &apos;stake&apos;, label: &apos;Wagered&apos;, sortable: true },
        { key: &apos;net&apos;, label: &apos;Net&apos;, sortable: true },
        { key: &apos;roi&apos;, label: &apos;ROI&apos;, sortable: true },
    ];

    return (
        &lt;div className=&quot;bg-white dark:bg-neutral-900 rounded-lg shadow-md p-6 flex flex-col&quot;&gt;
            &lt;h2 className=&quot;text-xl font-semibold text-neutral-800 dark:text-neutral-200&quot;&gt;{title}&lt;/h2&gt;
            &lt;input
                type=&quot;text&quot;
                placeholder=&quot;Search markets...&quot;
                value={searchTerm}
                onChange={e =&gt; setSearchTerm(e.target.value)}
                className=&quot;my-4 p-2 border border-neutral-300 dark:border-neutral-700 rounded-md bg-neutral-50 dark:bg-neutral-800 w-full&quot;
            /&gt;
            &lt;div className=&quot;overflow-x-auto&quot;&gt;
                &lt;table className=&quot;w-full text-sm text-left&quot;&gt;
                    &lt;thead className=&quot;text-xs text-neutral-500 dark:text-neutral-400 uppercase sticky top-0 bg-white dark:bg-neutral-900&quot;&gt;
                        &lt;tr&gt;
                            {headers.map(header =&gt; (
                                &lt;th 
                                    key={header.key} 
                                    className={`px-4 py-2 ${header.sortable ? &apos;cursor-pointer&apos; : &apos;&apos;} ${[&apos;win_pct&apos;].includes(header.key) ? &apos;text-center&apos; : &apos;&apos;}`} 
                                    onClick={() =&gt; header.sortable &amp;&amp; requestSort(header.key as keyof StatsData)}
                                &gt;
                                    {header.label} {header.sortable &amp;&amp; (sortConfig.key === header.key ? (sortConfig.direction === &apos;desc&apos; ? &apos;&apos; : &apos;&apos;) : &apos;&apos;)}
                                &lt;/th&gt;
                            ))}
                        &lt;/tr&gt;
                    &lt;/thead&gt;
                    &lt;tbody className=&quot;divide-y divide-neutral-200 dark:divide-neutral-800&quot;&gt;
                        {sortedData.map(item =&gt; {
                            const netColor = item.net &gt; 0 ? &apos;text-accent-500&apos; : item.net &lt; 0 ? &apos;text-danger-500&apos; : &apos;text-neutral-500&apos;;
                            const winPct = item.wins + item.losses &gt; 0 ? (item.wins / (item.wins + item.losses)) * 100 : 0;
                            const winPctColor = winPct &gt; 50 ? &apos;text-accent-500&apos; : winPct &lt; 50 &amp;&amp; (item.wins + item.losses &gt; 0) ? &apos;text-danger-500&apos; : &apos;text-neutral-500&apos;;
                            
                            return (
                                &lt;tr key={item.name} className=&quot;odd:bg-white dark:odd:bg-neutral-900 even:bg-neutral-50 dark:even:bg-neutral-800/50 hover:bg-neutral-100 dark:hover:bg-neutral-800&quot;&gt;
                                    &lt;td className=&quot;px-4 py-2 font-medium text-neutral-900 dark:text-neutral-100 truncate max-w-xs&quot;&gt;{item.name}&lt;/td&gt;
                                    &lt;td className=&quot;px-4 py-2&quot;&gt;{item.count}&lt;/td&gt;
                                    &lt;td className=&quot;px-4 py-2&quot;&gt;{item.wins}&lt;/td&gt;
                                    &lt;td className=&quot;px-4 py-2&quot;&gt;{item.losses}&lt;/td&gt;
                                    &lt;td className={`px-4 py-2 text-center font-semibold ${winPctColor}`}&gt;{winPct.toFixed(1)}%&lt;/td&gt;
                                    &lt;td className=&quot;px-4 py-2&quot;&gt;${item.stake.toFixed(2)}&lt;/td&gt;
                                    &lt;td className={`px-4 py-2 font-semibold ${netColor}`}&gt;{item.net.toFixed(2)}&lt;/td&gt;
                                    &lt;td className={`px-4 py-2 font-semibold ${netColor}`}&gt;{item.roi.toFixed(1)}%&lt;/td&gt;
                                &lt;/tr&gt;
                            )
                        })}
                    &lt;/tbody&gt;
                &lt;/table&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    );
};

const RecentBetsTable: React.FC&lt;{ bets: Bet[] }&gt; = ({ bets }) =&gt; (
  &lt;div className=&quot;bg-white dark:bg-neutral-900 rounded-lg shadow-md p-6&quot;&gt;
    &lt;h2 className=&quot;text-xl font-semibold text-neutral-800 dark:text-neutral-200 mb-4&quot;&gt;Recent Bets&lt;/h2&gt;
    &lt;div className=&quot;overflow-x-auto&quot;&gt;
      &lt;table className=&quot;w-full text-sm&quot;&gt;
        &lt;thead className=&quot;text-xs text-neutral-500 dark:text-neutral-400 uppercase&quot;&gt;
          &lt;tr&gt;
            &lt;th className=&quot;p-2 text-left&quot;&gt;Date&lt;/th&gt;
            &lt;th className=&quot;p-2 text-left&quot;&gt;Description&lt;/th&gt;
            &lt;th className=&quot;p-2 text-right&quot;&gt;Stake&lt;/th&gt;
            &lt;th className=&quot;p-2 text-right&quot;&gt;Net&lt;/th&gt;
            &lt;th className=&quot;p-2 text-center&quot;&gt;Result&lt;/th&gt;
          &lt;/tr&gt;
        &lt;/thead&gt;
        &lt;tbody&gt;
          {bets.map((bet, index) =&gt; {
            const net = bet.payout - bet.stake;
            const netColor = net &gt; 0 ? &apos;text-accent-500&apos; : net &lt; 0 ? &apos;text-danger-500&apos; : &apos;&apos;;
            return (
              &lt;tr key={bet.id} className=&quot;border-b border-neutral-200 dark:border-neutral-800 odd:bg-white dark:odd:bg-neutral-900 even:bg-neutral-50 dark:even:bg-neutral-800/50&quot;&gt;
                &lt;td className=&quot;p-2 whitespace-nowrap&quot;&gt;{new Date(bet.placedAt).toLocaleDateString()}&lt;/td&gt;
                &lt;td className=&quot;p-2&quot;&gt;{bet.description}&lt;/td&gt;
                &lt;td className=&quot;p-2 text-right&quot;&gt;${bet.stake.toFixed(2)}&lt;/td&gt;
                &lt;td className={`p-2 text-right font-semibold ${netColor}`}&gt;{net.toFixed(2)}&lt;/td&gt;
                &lt;td className={`p-2 text-center font-semibold capitalize ${netColor}`}&gt;{bet.result}&lt;/td&gt;
              &lt;/tr&gt;
            );
          })}
        &lt;/tbody&gt;
      &lt;/table&gt;
    &lt;/div&gt;
  &lt;/div&gt;
);

const ToggleButton: React.FC&lt;{
  value: string;
  label: string;
  currentValue: string;
  onClick: (value: string) =&gt; void;
}&gt; = ({ value, label, currentValue, onClick }) =&gt; (
  &lt;button
    onClick={() =&gt; onClick(value)}
    className={`px-2.5 py-1 rounded-md font-medium text-xs transition-colors ${
      currentValue === value
        ? &apos;bg-primary-600 text-white shadow&apos;
        : &apos;text-neutral-600 dark:text-neutral-300 bg-neutral-100 dark:bg-neutral-800 hover:bg-neutral-200 dark:hover:bg-neutral-700&apos;
    }`}
  &gt;
    {label}
  &lt;/button&gt;
);

const OverUnderBreakdown: React.FC&lt;{ bets: Bet[], selectedPlayer: string | null }&gt; = ({ bets, selectedPlayer }) =&gt; {
    const [filter, setFilter] = useState&lt;&apos;props&apos; | &apos;totals&apos; | &apos;all&apos;&gt;(&apos;all&apos;);

    const data = useMemo(() =&gt; {
        const filteredBets = bets.filter(bet =&gt; {
            if (filter === &apos;props&apos;) return bet.marketCategory === &apos;Props&apos;;
            if (filter === &apos;totals&apos;) return bet.marketCategory === &apos;Main Markets&apos;;
            return bet.marketCategory === &apos;Props&apos; || bet.marketCategory === &apos;Main Markets&apos;;
        });

        const stats = { 
            over: { count: 0, wins: 0, losses: 0, stake: 0, net: 0 }, 
            under: { count: 0, wins: 0, losses: 0, stake: 0, net: 0 }
        };

        filteredBets.forEach(bet =&gt; {
            if (bet.legs?.length) {
                bet.legs.forEach(leg =&gt; {
                    if (leg.ou &amp;&amp; (!selectedPlayer || leg.entities?.includes(selectedPlayer))) {
                        const ou = leg.ou.toLowerCase() as &apos;over&apos; | &apos;under&apos;;
                        const net = bet.payout - bet.stake;
                        stats[ou].count++; 
                        stats[ou].stake += bet.stake; 
                        stats[ou].net += net;
                        if (bet.result === &apos;win&apos;) stats[ou].wins++; 
                        if (bet.result === &apos;loss&apos;) stats[ou].losses++;
                    }
                });
            }
        });

        const calculateRoi = (s: { stake: number, net: number }) =&gt; s.stake &gt; 0 ? (s.net / s.stake) * 100 : 0;
        
        return { 
            over: {...stats.over, roi: calculateRoi(stats.over)}, 
            under: {...stats.under, roi: calculateRoi(stats.under)}
        };
    }, [bets, filter, selectedPlayer]);

    const pieData = [
        { name: &apos;Over&apos;, value: data.over.count, color: &apos;#8b5cf6&apos; },
        { name: &apos;Under&apos;, value: data.under.count, color: &apos;#6d28d9&apos; }
    ];

    const StatCard = ({ title, stats }: { title: string, stats: any }) =&gt; {
        const netColor = stats.net &gt; 0 ? &apos;text-accent-500&apos; : stats.net &lt; 0 ? &apos;text-danger-500&apos; : &apos;&apos;;
        const NetIcon = stats.net &gt; 0 ? TrendingUp : TrendingDown;
        const winPct = stats.wins + stats.losses &gt; 0 ? (stats.wins / (stats.wins + stats.losses)) * 100 : 0;
        return (
            &lt;div className=&quot;p-4 rounded-lg bg-neutral-100 dark:bg-neutral-800/50 flex-1&quot;&gt;
                &lt;h4 className=&quot;font-bold text-lg&quot; style={{ color: title === &apos;Over&apos; ? pieData[0].color : pieData[1].color }}&gt;{title}&lt;/h4&gt;
                &lt;div className=&quot;text-sm mt-2 space-y-1 text-neutral-600 dark:text-neutral-300&quot;&gt;
                    &lt;p&gt;&lt;b&gt;Bets:&lt;/b&gt; {stats.count}&lt;/p&gt;
                    &lt;p&gt;&lt;b&gt;Win/Loss:&lt;/b&gt; {stats.wins}-{stats.losses}&lt;/p&gt;
                    &lt;p&gt;&lt;b&gt;Win %:&lt;/b&gt; {winPct.toFixed(1)}%&lt;/p&gt;
                    &lt;p className={`flex items-center ${netColor}`}&gt;&lt;b&gt;Net:&lt;/b&gt;&lt;NetIcon className=&quot;w-4 h-4 mx-1&quot;/&gt; ${stats.net.toFixed(2)}&lt;/p&gt;
                    &lt;p className={netColor}&gt;&lt;b&gt;ROI:&lt;/b&gt; {stats.roi.toFixed(1)}%&lt;/p&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        )
    };
    
    return (
        &lt;div className=&quot;bg-white dark:bg-neutral-900 rounded-lg shadow-md p-6 h-full flex flex-col&quot;&gt;
            &lt;div className=&quot;flex justify-between items-center mb-4&quot;&gt;
                &lt;h2 className=&quot;text-xl font-semibold text-neutral-800 dark:text-neutral-200&quot;&gt;Over vs. Under&lt;/h2&gt;
                &lt;div className=&quot;flex items-center space-x-1 flex-wrap gap-y-2 bg-neutral-100 dark:bg-neutral-800/50 p-1 rounded-lg&quot;&gt;
                    &lt;ToggleButton value=&quot;props&quot; label=&quot;Props&quot; currentValue={filter} onClick={(v) =&gt; setFilter(v as any)} /&gt;
                    &lt;ToggleButton value=&quot;totals&quot; label=&quot;Totals&quot; currentValue={filter} onClick={(v) =&gt; setFilter(v as any)} /&gt;
                    &lt;ToggleButton value=&quot;all&quot; label=&quot;All&quot; currentValue={filter} onClick={(v) =&gt; setFilter(v as any)} /&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            &lt;div className=&quot;h-40&quot;&gt;
                &lt;ResponsiveContainer width=&quot;100%&quot; height=&quot;100%&quot;&gt;
                    &lt;PieChart&gt;
                        &lt;Pie data={pieData} dataKey=&quot;value&quot; nameKey=&quot;name&quot; cx=&quot;50%&quot; cy=&quot;50%&quot; outerRadius={60} label&gt;
                            {pieData.map((entry, index) =&gt; &lt;Cell key={`cell-${index}`} fill={entry.color} /&gt;)}
                        &lt;/Pie&gt;
                        &lt;Tooltip /&gt;
                    &lt;/PieChart&gt;
                &lt;/ResponsiveContainer&gt;
            &lt;/div&gt;
            &lt;div className=&quot;flex gap-4 mt-4&quot;&gt;
                &lt;StatCard title=&quot;Over&quot; stats={data.over} /&gt;
                &lt;StatCard title=&quot;Under&quot; stats={data.under} /&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    );
}

// --- MAIN VIEW ---

type DateRange = &apos;all&apos; | &apos;1d&apos; | &apos;3d&apos; | &apos;1w&apos; | &apos;1m&apos; | &apos;1y&apos; | &apos;custom&apos;;

const DateRangeButton: React.FC&lt;{
  range: DateRange;
  label: string;
  currentRange: DateRange;
  onClick: (range: DateRange) =&gt; void;
}&gt; = ({ range, label, currentRange, onClick }) =&gt; (
  &lt;button
    onClick={() =&gt; onClick(range)}
    className={`px-3 py-1.5 rounded-md font-medium text-xs transition-colors ${
      currentRange === range
        ? &apos;bg-primary-600 text-white shadow&apos;
        : &apos;text-neutral-600 dark:text-neutral-300 hover:bg-white dark:hover:bg-neutral-700&apos;
    }`}
  &gt;
    {label}
  &lt;/button&gt;
);

interface PlayerProfileViewProps {
  selectedPlayer: string | null;
  setSelectedPlayer: (player: string | null) =&gt; void;
}

const PlayerProfileView: React.FC&lt;PlayerProfileViewProps&gt; = ({ selectedPlayer, setSelectedPlayer }) =&gt; {
    const { bets, loading } = useBets();
    const { players } = useInputs();
    const [searchTerm, setSearchTerm] = useState(selectedPlayer || &apos;&apos;);
    const [isSearchFocused, setIsSearchFocused] = useState(false);
    const [dateRange, setDateRange] = useState&lt;DateRange&gt;(&apos;all&apos;);
    const [customDateRange, setCustomDateRange] = useState&lt;{ start: string; end: string }&gt;({ start: &apos;&apos;, end: &apos;&apos; });

    useEffect(() =&gt; {
        setSearchTerm(selectedPlayer || &apos;&apos;);
    }, [selectedPlayer]);

    const allPlayers = useMemo(() =&gt; {
        return Array.from(new Set(Object.values(players).flat())).sort();
    }, [players]);

    const filteredPlayers = useMemo(() =&gt; {
        if (!searchTerm) return [];
        return allPlayers.filter(p =&gt; p.toLowerCase().includes(searchTerm.toLowerCase())).slice(0, 10);
    }, [allPlayers, searchTerm]);

    const handlePlayerSelect = (player: string) =&gt; {
        setSelectedPlayer(player);
        setSearchTerm(player);
        setIsSearchFocused(false);
        setDateRange(&apos;all&apos;);
        setCustomDateRange({ start: &apos;&apos;, end: &apos;&apos; });
    };

    const handleClearPlayer = () =&gt; {
        setSelectedPlayer(null);
        setSearchTerm(&apos;&apos;);
        setDateRange(&apos;all&apos;);
        setCustomDateRange({ start: &apos;&apos;, end: &apos;&apos; });
    };

    const playerBets = useMemo(() =&gt; {
         if (!selectedPlayer) return [];

        let dateFilteredBets = bets;

        if (dateRange !== &apos;all&apos;) {
            if (dateRange === &apos;custom&apos;) {
                const customStart = customDateRange.start ? new Date(`${customDateRange.start}T00:00:00.000Z`) : null;
                const customEnd = customDateRange.end ? new Date(`${customDateRange.end}T23:59:59.999Z`) : null;
                
                dateFilteredBets = bets.filter(bet =&gt; {
                    const betDate = new Date(bet.placedAt);
                    if (customStart &amp;&amp; betDate &lt; customStart) return false;
                    if (customEnd &amp;&amp; betDate &gt; customEnd) return false;
                    return true;
                });
            } else {
                let startDate: Date;
                const now = new Date();
    
                switch (dateRange) {
                    case &apos;1d&apos;: startDate = new Date(now.getTime() - 1 * 24 * 60 * 60 * 1000); break;
                    case &apos;3d&apos;: startDate = new Date(now.getTime() - 3 * 24 * 60 * 60 * 1000); break;
                    case &apos;1w&apos;: startDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000); break;
                    case &apos;1m&apos;: startDate = new Date(new Date().setMonth(now.getMonth() - 1)); break;
                    case &apos;1y&apos;: startDate = new Date(new Date().setFullYear(now.getFullYear() - 1)); break;
                    default: startDate = new Date(0);
                }
                
                dateFilteredBets = bets.filter(bet =&gt; new Date(bet.placedAt) &gt;= startDate);
            }
        }

        return dateFilteredBets.filter(bet =&gt;
            bet.legs?.some(leg =&gt; leg.entities?.includes(selectedPlayer))
        );
    }, [bets, selectedPlayer, dateRange, customDateRange]);

    const processedData = useMemo(() =&gt; {
        if (!selectedPlayer || playerBets.length === 0) return null;

        const sortedBets = [...playerBets].sort((a, b) =&gt; new Date(a.placedAt).getTime() - new Date(b.placedAt).getTime());

        const totalWagered = sortedBets.reduce((sum, bet) =&gt; sum + bet.stake, 0);
        const netProfit = sortedBets.reduce((sum, bet) =&gt; sum + (bet.payout - bet.stake), 0);
        const wins = sortedBets.filter(b =&gt; b.result === &apos;win&apos;).length;
        const losses = sortedBets.filter(b =&gt; b.result === &apos;loss&apos;).length;
        const pushes = sortedBets.filter(b =&gt; b.result === &apos;push&apos;).length;
        const roi = totalWagered &gt; 0 ? (netProfit / totalWagered) * 100 : 0;
        const winRate = (wins + losses) &gt; 0 ? (wins / (wins + losses)) * 100 : 0;
        const overallStats = { totalBets: sortedBets.length, totalWagered, netProfit, roi, winRate, record: `${wins}-${losses}-${pushes}` };

        let cumulativeProfit = 0;
        const profitOverTime = sortedBets.map(bet =&gt; {
            cumulativeProfit += (bet.payout - bet.stake);
            return { date: new Date(bet.placedAt).toLocaleDateString(&apos;en-CA&apos;), profit: cumulativeProfit };
        });

        const marketStatsMap = new Map();

        sortedBets.forEach(bet =&gt; {
            const net = bet.payout - bet.stake;
            bet.legs?.forEach(leg =&gt; {
                if (leg.entities?.includes(selectedPlayer)) {
                    if (!marketStatsMap.has(leg.market)) {
                        marketStatsMap.set(leg.market, { count: 0, wins: 0, losses: 0, stake: 0, net: 0 });
                    }
                    const market = marketStatsMap.get(leg.market);
                    market.count++;
                    market.stake += bet.stake;
                    market.net += net;
                    if (bet.result === &apos;win&apos;) market.wins++;
                    if (bet.result === &apos;loss&apos;) market.losses++;
                }
            });
        });

        const calculateStats = (s: any) =&gt; ({ ...s, roi: s.stake &gt; 0 ? (s.net / s.stake) * 100 : 0 });
        const marketStats = Array.from(marketStatsMap.entries()).map(([name, stats]) =&gt; ({ name, ...calculateStats(stats) }));

        return {
            overallStats, profitOverTime, marketStats,
            recentBets: sortedBets.slice(-10).reverse()
        };
    }, [playerBets, selectedPlayer]);

    if (loading) return &lt;div className=&quot;p-6 text-center&quot;&gt;Loading player data...&lt;/div&gt;;

    const showSuggestions = isSearchFocused &amp;&amp; searchTerm &amp;&amp; filteredPlayers.length &gt; 0;

    return (
        &lt;div className=&quot;p-6 h-full flex flex-col space-y-6 bg-neutral-100 dark:bg-neutral-950 overflow-y-auto&quot;&gt;
            &lt;header&gt;
                &lt;h1 className=&quot;text-3xl font-bold text-neutral-900 dark:text-white&quot;&gt;Player Profiles&lt;/h1&gt;
                &lt;p className=&quot;text-neutral-500 dark:text-neutral-400 mt-1&quot;&gt;Search for a player to see a deep-dive analysis of your betting performance.&lt;/p&gt;
            &lt;/header&gt;
            
             &lt;div className=&quot;bg-white dark:bg-neutral-900 rounded-lg shadow-md p-6&quot;&gt;
                &lt;div className=&quot;relative&quot;&gt;
                    &lt;input
                        type=&quot;text&quot;
                        placeholder=&quot;Search for a player...&quot;
                        value={searchTerm}
                        onChange={e =&gt; setSearchTerm(e.target.value)}
                        onFocus={() =&gt; setIsSearchFocused(true)}
                        onBlur={() =&gt; {
                            // Delay hiding to allow click event on suggestion list to register
                            setTimeout(() =&gt; setIsSearchFocused(false), 150);
                        }}
                        className=&quot;w-full p-4 pr-10 text-lg bg-neutral-50 dark:bg-neutral-800 rounded-lg border border-neutral-300 dark:border-neutral-700 focus:ring-2 focus:ring-primary-500 outline-none&quot;
                    /&gt;
                    &lt;User className=&quot;absolute right-4 top-1/2 -translate-y-1/2 w-6 h-6 text-neutral-400&quot; /&gt;
                    {showSuggestions &amp;&amp; (
                        &lt;ul className=&quot;absolute z-10 w-full mt-1 bg-white dark:bg-neutral-800 rounded-lg shadow-lg border border-neutral-200 dark:border-neutral-700 max-h-60 overflow-y-auto&quot;&gt;
                            {filteredPlayers.map(player =&gt; (
                                &lt;li key={player}
                                    onClick={() =&gt; handlePlayerSelect(player)}
                                    className=&quot;px-4 py-2 cursor-pointer hover:bg-neutral-100 dark:hover:bg-neutral-700&quot;&gt;
                                    {player}
                                &lt;/li&gt;
                            ))}
                        &lt;/ul&gt;
                    )}
                &lt;/div&gt;
            &lt;/div&gt;

            {!selectedPlayer ? (
                &lt;div className=&quot;flex-grow flex items-center justify-center text-center text-neutral-500 dark:text-neutral-400&quot;&gt;
                    &lt;div&gt;
                        &lt;User className=&quot;w-16 h-16 mx-auto text-neutral-400 dark:text-neutral-600&quot; /&gt;
                        &lt;h3 className=&quot;mt-4 text-xl font-semibold&quot;&gt;Select a Player&lt;/h3&gt;
                        &lt;p className=&quot;mt-1&quot;&gt;Start typing in the search bar above to find a player.&lt;/p&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            ) : (
                &lt;div className=&quot;space-y-6&quot;&gt;
                    &lt;div className=&quot;bg-white dark:bg-neutral-900 rounded-lg shadow-md p-6 space-y-6&quot;&gt;
                        &lt;div className=&quot;space-y-4&quot;&gt;
                            &lt;div className=&quot;flex flex-col sm:flex-row sm:justify-between sm:items-center gap-4&quot;&gt;
                                &lt;div className=&quot;flex items-center gap-2 bg-neutral-100 dark:bg-neutral-800/50 p-1 rounded-lg&quot;&gt;
                                    &lt;div className=&quot;px-3 py-1.5 rounded-md font-semibold text-xs bg-primary-600 text-white shadow&quot;&gt;
                                        PLAYER: {selectedPlayer}
                                    &lt;/div&gt;
                                    &lt;button
                                        onClick={handleClearPlayer}
                                        className=&quot;px-3 py-1.5 rounded-md font-semibold text-xs text-danger-600 dark:text-danger-400 hover:bg-danger-100 dark:hover:bg-danger-900/50&quot;
                                    &gt;
                                        Clear
                                    &lt;/button&gt;
                                &lt;/div&gt;

                                &lt;div className=&quot;flex items-center space-x-1 flex-wrap gap-y-2 bg-neutral-100 dark:bg-neutral-800/50 p-1 rounded-lg&quot;&gt;
                                    &lt;DateRangeButton range=&quot;all&quot; label=&quot;All Time&quot; currentRange={dateRange} onClick={setDateRange} /&gt;
                                    &lt;DateRangeButton range=&quot;1d&quot; label=&quot;1D&quot; currentRange={dateRange} onClick={setDateRange} /&gt;
                                    &lt;DateRangeButton range=&quot;3d&quot; label=&quot;3D&quot; currentRange={dateRange} onClick={setDateRange} /&gt;
                                    &lt;DateRangeButton range=&quot;1w&quot; label=&quot;1W&quot; currentRange={dateRange} onClick={setDateRange} /&gt;
                                    &lt;DateRangeButton range=&quot;1m&quot; label=&quot;1M&quot; currentRange={dateRange} onClick={setDateRange} /&gt;
                                    &lt;DateRangeButton range=&quot;1y&quot; label=&quot;1Y&quot; currentRange={dateRange} onClick={setDateRange} /&gt;
                                    &lt;DateRangeButton range=&quot;custom&quot; label=&quot;Custom&quot; currentRange={dateRange} onClick={setDateRange} /&gt;
                                &lt;/div&gt;
                            &lt;/div&gt;

                            {dateRange === &apos;custom&apos; &amp;&amp; (
                                &lt;div className=&quot;flex sm:justify-end items-center space-x-4&quot;&gt;
                                    &lt;div className=&quot;flex items-center space-x-2&quot;&gt;
                                        &lt;label htmlFor=&quot;start-date&quot; className=&quot;text-sm font-medium text-neutral-500 dark:text-neutral-400&quot;&gt;From&lt;/label&gt;
                                        &lt;input
                                            type=&quot;date&quot;
                                            id=&quot;start-date&quot;
                                            value={customDateRange.start}
                                            onChange={e =&gt; setCustomDateRange(prev =&gt; ({ ...prev, start: e.target.value }))}
                                            className=&quot;bg-neutral-50 dark:bg-neutral-800 border border-neutral-300 dark:border-neutral-600 text-neutral-900 dark:text-white text-sm rounded-lg focus:ring-primary-500 focus:border-primary-500 block w-full p-2&quot;
                                        /&gt;
                                    &lt;/div&gt;
                                    &lt;div className=&quot;flex items-center space-x-2&quot;&gt;
                                        &lt;label htmlFor=&quot;end-date&quot; className=&quot;text-sm font-medium text-neutral-500 dark:text-neutral-400&quot;&gt;To&lt;/label&gt;
                                        &lt;input
                                            type=&quot;date&quot;
                                            id=&quot;end-date&quot;
                                            value={customDateRange.end}
                                            onChange={e =&gt; setCustomDateRange(prev =&gt; ({ ...prev, end: e.target.value }))}
                                            className=&quot;bg-neutral-50 dark:bg-neutral-800 border border-neutral-300 dark:border-neutral-600 text-neutral-900 dark:text-white text-sm rounded-lg focus:ring-primary-500 focus:border-primary-500 block w-full p-2&quot;
                                        /&gt;
                                    &lt;/div&gt;
                                &lt;/div&gt;
                            )}
                        &lt;/div&gt;
                        
                        {!processedData ? (
                            &lt;div className=&quot;flex-grow flex items-center justify-center text-center text-neutral-500 dark:text-neutral-400 py-10&quot;&gt;
                                &lt;div&gt;
                                    &lt;BarChart2 className=&quot;w-16 h-16 mx-auto text-neutral-400 dark:text-neutral-600&quot; /&gt;
                                    &lt;h3 className=&quot;mt-4 text-xl font-semibold&quot;&gt;No Data Found&lt;/h3&gt;
                                    &lt;p className=&quot;mt-1&quot;&gt;No bets found for {selectedPlayer} in the selected date range.&lt;/p&gt;
                                &lt;/div&gt;
                            &lt;/div&gt;
                        ) : (
                            &lt;div className=&quot;grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 border-t border-neutral-200 dark:border-neutral-800 pt-6&quot;&gt;
                                &lt;StatCard title=&quot;Net Profit&quot; value={`${processedData.overallStats.netProfit &gt;= 0 ? &apos;$&apos; : &apos;-$&apos;}${Math.abs(processedData.overallStats.netProfit).toFixed(2)}`} icon={&lt;Scale className=&quot;w-6 h-6&quot;/&gt;} change={`${processedData.overallStats.roi.toFixed(1)}% ROI`}/&gt;
                                &lt;StatCard title=&quot;Total Wagered&quot; value={`$${processedData.overallStats.totalWagered.toFixed(2)}`} icon={&lt;BarChart2 className=&quot;w-6 h-6&quot;/&gt;} /&gt;
                                &lt;StatCard title=&quot;Total Bets&quot; value={processedData.overallStats.totalBets.toString()} icon={&lt;BarChart2 className=&quot;w-6 h-6&quot;/&gt;} /&gt;
                                &lt;StatCard title=&quot;Win/Loss/Push&quot; value={processedData.overallStats.record} icon={&lt;BarChart2 className=&quot;w-6 h-6&quot;/&gt;} change={`${processedData.overallStats.winRate.toFixed(1)}% Win Rate`} /&gt;
                            &lt;/div&gt;
                        )}
                    &lt;/div&gt;

                    {processedData &amp;&amp; (
                        &lt;div className=&quot;space-y-6&quot;&gt;
                             &lt;div className=&quot;grid grid-cols-1 lg:grid-cols-2 gap-6&quot;&gt;
                                &lt;ChartContainer title=&quot;Profit Over Time&quot;&gt;
                                    &lt;ResponsiveContainer width=&quot;100%&quot; height=&quot;100%&quot;&gt;
                                        &lt;LineChart data={processedData.profitOverTime}&gt;
                                            &lt;CartesianGrid strokeDasharray=&quot;3 3&quot; stroke=&quot;rgba(128, 128, 128, 0.2)&quot; /&gt;
                                            &lt;XAxis dataKey=&quot;date&quot; stroke=&quot;rgb(113, 113, 122)&quot; tick={{ fontSize: 12 }} /&gt;
                                            &lt;YAxis stroke=&quot;rgb(113, 113, 122)&quot; tick={{ fontSize: 12 }} tickFormatter={(value) =&gt; `$${value}`}/&gt;
                                            &lt;Tooltip content={&lt;CustomTooltip /&gt;} /&gt;
                                            &lt;Line type=&quot;monotone&quot; dataKey=&quot;profit&quot; name=&quot;Profit&quot; stroke=&quot;#8b5cf6&quot; strokeWidth={2} dot={false} /&gt;
                                        &lt;/LineChart&gt;
                                    &lt;/ResponsiveContainer&gt;
                                &lt;/ChartContainer&gt;
                                &lt;OverUnderBreakdown bets={playerBets} selectedPlayer={selectedPlayer} /&gt;
                            &lt;/div&gt;

                            &lt;StatsTable data={processedData.marketStats} title=&quot;Performance by Market&quot; /&gt;
                            
                            &lt;RecentBetsTable bets={processedData.recentBets} /&gt;
                        &lt;/div&gt;
                    )}
                &lt;/div&gt;
            )}
        &lt;/div&gt;
    );
};

export default PlayerProfileView;</file><file path="views/SettingsView.tsx">import React, { useState } from &apos;react&apos;;
import { useBets } from &apos;../hooks/useBets&apos;;
import { useInputs } from &apos;../hooks/useInputs&apos;;
import { Bet, BetResult, BetType, BetLeg } from &apos;../types&apos;;
import { parseCsv } from &apos;../services/csvParser&apos;;
import { classifyBet } from &apos;../services/classificationService&apos;;
import { AlertTriangle, CheckCircle2 } from &apos;../components/icons&apos;;
import InputManagementSection from &apos;./InputManagementView&apos;;

interface SettingsViewProps {
  theme: &apos;light&apos; | &apos;dark&apos;;
  toggleTheme: () =&gt; void;
}

const SettingsView: React.FC&lt;SettingsViewProps&gt; = ({ theme, toggleTheme }) =&gt; {
  const { bets, clearBets, addBets } = useBets();
  const { sportsbooks } = useInputs();
  const [csvFile, setCsvFile] = useState&lt;File | null&gt;(null);
  const [isImporting, setIsImporting] = useState(false);
  const [notification, setNotification] = useState&lt;{ message: string; type: &apos;success&apos; | &apos;error&apos; } | null&gt;(null);
  
  const showNotification = (message: string, type: &apos;success&apos; | &apos;error&apos;) =&gt; {
    setNotification({ message, type });
    setTimeout(() =&gt; setNotification(null), 5000);
  };

  const handleFileChange = (event: React.ChangeEvent&lt;HTMLInputElement&gt;) =&gt; {
    const file = event.target.files?.[0];
    if (file &amp;&amp; file.type === &quot;text/csv&quot;) {
        setCsvFile(file);
    } else {
        setCsvFile(null);
        if (file) {
            showNotification(&quot;Please select a valid .csv file.&quot;, &apos;error&apos;);
        }
    }
  };

  const handleCsvImport = async () =&gt; {
    if (!csvFile) return;

    setIsImporting(true);
    setNotification(null);
    
    try {
        const csvString = await csvFile.text();
        const parsedRows = parseCsv(csvString);

        const siteMap = new Map&lt;string, string&gt;();
        sportsbooks.forEach(book =&gt; {
            siteMap.set(book.abbreviation.toLowerCase(), book.name);
            siteMap.set(book.name.toLowerCase(), book.name);
        });

        const newBets: Bet[] = parsedRows.map((row, index) =&gt; {
            if (!row.date || !row.site || !row.sport || !row.name || !row.type) {
                throw new Error(`Row ${index + 2} is missing required text fields (Date, Site, Sport, Name, Type).`);
            }

            const bookName = siteMap.get(row.site.toLowerCase()) || row.site;
            const description = `${row.name} ${row.ou || &apos;&apos;} ${row.line || &apos;&apos;} ${row.type}`.replace(/\s+/g, &apos; &apos;).trim();
            const betType: BetType = row.notes?.toLowerCase().includes(&apos;live&apos;) ? &apos;live&apos; : &apos;single&apos;;
            
            let placedAtDate: Date;
            if (row.date.includes(&apos;/&apos;)) {
                const parts = row.date.split(&apos;/&apos;);
                placedAtDate = new Date(parseInt(parts[2]), parseInt(parts[0]) - 1, parseInt(parts[1]));
            } else {
                placedAtDate = new Date(row.date);
            }

            if (isNaN(placedAtDate.getTime())) {
                throw new Error(`Row ${index + 2}: Invalid date format for &quot;${row.date}&quot;. Please use MM/DD/YYYY.`);
            }
            
            const placedAt = placedAtDate.toISOString();
            const betId = `csv-${placedAtDate.getTime()}-${index}`;
            const id = `${bookName}-${betId}`;

            const singleLeg: BetLeg = {
                market: row.type,
                entities: [row.name],
                ou: row.ou,
                target: row.line ? (isNaN(Number(row.line)) ? row.line : Number(row.line)) : undefined,
                result: row.result, // For single bets, leg result is same as bet result
            };

            const stake = row.bet;
            const profit = row.toWin;
            let payout: number;

            switch (row.result) {
                case &apos;win&apos;:
                    // Payout is the total return: stake + profit
                    payout = stake + profit;
                    break;
                case &apos;loss&apos;:
                    payout = 0;
                    break;
                case &apos;push&apos;:
                    // Payout for a push is just the stake back
                    payout = stake;
                    break;
                case &apos;pending&apos;:
                default:
                    // Pending bets have not paid out yet
                    payout = 0;
                    break;
            }

            const betData = {
                id,
                book: bookName,
                betId,
                placedAt,
                betType,
                sport: row.sport,
                description,
                odds: row.odds,
                stake: stake,
                payout: payout,
                result: row.result,
                legs: [singleLeg],
                tail: row.tail,
                raw: `Imported from CSV. Notes: ${row.notes || &apos;&apos;}`.trim()
            };

            return {
                ...betData,
                marketCategory: classifyBet(betData)
            };
        });

        const importedCount = addBets(newBets);
        showNotification(`Successfully imported ${importedCount} new bets from CSV.`, &apos;success&apos;);

    } catch (error: any) {
        console.error(&quot;CSV Import failed:&quot;, error);
        showNotification(error.message || `An unexpected error occurred during import.`, &apos;error&apos;);
    } finally {
        setIsImporting(false);
        setCsvFile(null);
        const fileInput = document.getElementById(&apos;csv-importer&apos;) as HTMLInputElement;
        if(fileInput) fileInput.value = &apos;&apos;;
    }
  };

  const exportToCSV = () =&gt; {
    if (bets.length === 0) {
      alert(&quot;No bets to export.&quot;);
      return;
    }

    const headers = Object.keys(bets[0]).filter(key =&gt; key !== &apos;legs&apos; &amp;&amp; key !== &apos;raw&apos;);
    const csvRows = [headers.join(&apos;,&apos;)];

    bets.forEach(bet =&gt; {
      const values = headers.map(header =&gt; {
        let value = (bet as any)[header];
        if (typeof value === &apos;string&apos;) {
          return `&quot;${value.replace(/&quot;/g, &apos;&quot;&quot;&apos;)}&quot;`;
        }
        return value;
      });
      csvRows.push(values.join(&apos;,&apos;));
    });

    const csvString = csvRows.join(&apos;\n&apos;);
    const blob = new Blob([csvString], { type: &apos;text/csv;charset=utf-8;&apos; });
    const link = document.createElement(&apos;a&apos;);
    if (link.download !== undefined) {
      const url = URL.createObjectURL(blob);
      link.setAttribute(&apos;href&apos;, url);
      link.setAttribute(&apos;download&apos;, `bettracker_export_${new Date().toISOString().split(&apos;T&apos;)[0]}.csv`);
      link.style.visibility = &apos;hidden&apos;;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }
  };

  const handleClearData = () =&gt; {
    if (window.confirm(&quot;Are you sure you want to delete ALL bet data? This action cannot be undone.&quot;)) {
      clearBets();
      alert(&quot;All bet data has been cleared.&quot;);
    }
  };

  const SettingCard: React.FC&lt;{title: string, description: string, children: React.ReactNode}&gt; = ({title, description, children}) =&gt; (
    &lt;div className=&quot;bg-white dark:bg-neutral-900 rounded-lg shadow-md p-6 flex justify-between items-center&quot;&gt;
        &lt;div&gt;
            &lt;h3 className=&quot;text-lg font-semibold text-neutral-900 dark:text-white&quot;&gt;{title}&lt;/h3&gt;
            &lt;p className=&quot;text-neutral-500 dark:text-neutral-400 mt-1&quot;&gt;{description}&lt;/p&gt;
        &lt;/div&gt;
        &lt;div&gt;
            {children}
        &lt;/div&gt;
    &lt;/div&gt;
  );

  const CsvImportInstructions = () =&gt; (
    &lt;details className=&quot;mt-4 text-sm text-left w-full&quot;&gt;
        &lt;summary className=&quot;cursor-pointer font-medium text-primary-500 hover:text-primary-400&quot;&gt;View CSV format instructions&lt;/summary&gt;
        &lt;div className=&quot;mt-2 p-4 bg-neutral-100 dark:bg-neutral-800/50 rounded-lg space-y-2 text-neutral-600 dark:text-neutral-300&quot;&gt;
            &lt;p&gt;Your CSV file should match the format of common bet tracking spreadsheets.&lt;/p&gt;
            &lt;p&gt;&lt;b&gt;Required Header Row:&lt;/b&gt;&lt;/p&gt;
            &lt;code className=&quot;block text-xs bg-neutral-200 dark:bg-neutral-900 p-2 rounded&quot;&gt;
              Date,Site,Sport,Type,Name,O/U,Line,Odds,Bet,To Win,Result,Net,Tail,Notes
            &lt;/code&gt;
            &lt;p&gt;&lt;b&gt;Notes:&lt;/b&gt;&lt;/p&gt;
            &lt;ul className=&quot;list-disc list-inside space-y-1 text-xs&quot;&gt;
                &lt;li&gt;The header row is &lt;b&gt;required&lt;/b&gt; and must match the names above. Column order does not matter.&lt;/li&gt;
                &lt;li&gt;&lt;b&gt;Date:&lt;/b&gt; Should be a recognizable format, like &lt;code&gt;MM/DD/YYYY&lt;/code&gt;.&lt;/li&gt;
                &lt;li&gt;&lt;b&gt;Site:&lt;/b&gt; Use abbreviations (e.g., FD, DK). These will be mapped to the full names you&apos;ve configured in Input Management.&lt;/li&gt;
                &lt;li&gt;&lt;b&gt;Result:&lt;/b&gt; Must contain &apos;Won&apos;, &apos;Lost&apos;, or &apos;Push&apos;.&lt;/li&gt;
                &lt;li&gt;&lt;b&gt;Bet &amp; To Win:&lt;/b&gt; Can include &apos;$&apos; signs; they will be removed automatically.&lt;/li&gt;
                &lt;li&gt;&lt;b&gt;Notes:&lt;/b&gt; If this column contains the word &quot;Live&quot;, the bet will be marked as a live bet.&lt;/li&gt;
                &lt;li&gt;The &lt;code&gt;Net&lt;/code&gt; column is ignored and will be recalculated by the app.&lt;/li&gt;
                &lt;li&gt;Each row is imported as a single bet. Parlays are not supported via this CSV import method yet.&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/div&gt;
    &lt;/details&gt;
  );

  const NotificationBanner = () =&gt; {
    if (!notification) return null;
    
    const colors = {
      success: &apos;bg-accent-900/50 border-accent-700 text-accent-300&apos;,
      error: &apos;bg-danger-900/50 border-danger-700 text-danger-300&apos;,
    };
    const Icon = notification.type === &apos;success&apos; ? CheckCircle2 : AlertTriangle;

    return (
      &lt;div className={`fixed top-8 right-8 z-50 p-4 rounded-lg border flex items-center space-x-3 shadow-lg transition-transform animate-pulse ${colors[notification.type]}`}&gt;
        &lt;Icon className=&quot;w-6 h-6&quot; /&gt;
        &lt;span className=&quot;font-medium&quot;&gt;{notification.message}&lt;/span&gt;
      &lt;/div&gt;
    );
  };

  return (
    &lt;div className=&quot;p-6 h-full flex flex-col space-y-6 bg-neutral-100 dark:bg-neutral-950 overflow-y-auto&quot;&gt;
      {NotificationBanner()}
      &lt;header&gt;
        &lt;h1 className=&quot;text-3xl font-bold text-neutral-900 dark:text-white&quot;&gt;Settings&lt;/h1&gt;
        &lt;p className=&quot;text-neutral-500 dark:text-neutral-400 mt-1&quot;&gt;Manage your application data and preferences.&lt;/p&gt;
      &lt;/header&gt;
      
      &lt;div className=&quot;space-y-4&quot;&gt;
        &lt;SettingCard title=&quot;Appearance&quot; description=&quot;Toggle between light and dark themes.&quot;&gt;
            &lt;button
                onClick={toggleTheme}
                className=&quot;px-4 py-2 bg-neutral-200 dark:bg-neutral-700 text-neutral-800 dark:text-neutral-200 font-semibold rounded-lg hover:bg-neutral-300 dark:hover:bg-neutral-600&quot;
            &gt;
                Switch to {theme === &apos;light&apos; ? &apos;Dark&apos; : &apos;Light&apos;} Mode
            &lt;/button&gt;
        &lt;/SettingCard&gt;
      &lt;/div&gt;

      &lt;div className=&quot;pt-6 border-t border-neutral-200 dark:border-neutral-800&quot;&gt;
        &lt;h2 className=&quot;text-2xl font-bold text-neutral-800 dark:text-neutral-200&quot;&gt;Data Management&lt;/h2&gt;
         &lt;div className=&quot;space-y-4 mt-4&quot;&gt;
            &lt;SettingCard title=&quot;Import from CSV&quot; description=&quot;Bulk import your bet history from a formatted CSV file.&quot;&gt;
                &lt;div className=&quot;flex flex-col items-end space-y-4 w-96&quot;&gt;
                    &lt;input 
                        id=&quot;csv-importer&quot;
                        type=&quot;file&quot; 
                        accept=&quot;.csv&quot;
                        onChange={handleFileChange}
                        className=&quot;w-full text-sm text-neutral-500 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-primary-50 dark:file:bg-primary-900/50 file:text-primary-700 dark:file:text-primary-300 hover:file:bg-primary-100 dark:hover:file:bg-primary-900&quot;
                    /&gt;
                    &lt;button
                        onClick={handleCsvImport}
                        disabled={!csvFile || isImporting}
                        className=&quot;w-full px-4 py-2 bg-primary-600 text-white font-semibold rounded-lg shadow-md hover:bg-primary-700 disabled:bg-neutral-600 disabled:cursor-not-allowed&quot;
                    &gt;
                        {isImporting ? &apos;Importing...&apos; : &apos;Import from CSV&apos;}
                    &lt;/button&gt;
                    &lt;CsvImportInstructions /&gt;
                &lt;/div&gt;
            &lt;/SettingCard&gt;
            &lt;SettingCard title=&quot;Export All Data&quot; description=&quot;Download your entire bet history as a single CSV file.&quot;&gt;
                &lt;button
                    onClick={exportToCSV}
                    className=&quot;px-4 py-2 bg-primary-600 text-white font-semibold rounded-lg shadow-md hover:bg-primary-700 focus:outline-none focus:ring-2 focus:ring-primary-500 focus:ring-opacity-75&quot;
                &gt;
                    Export All Bets to CSV
                &lt;/button&gt;
            &lt;/SettingCard&gt;
          &lt;/div&gt;
      &lt;/div&gt;

      &lt;div className=&quot;pt-6 border-t border-neutral-200 dark:border-neutral-800&quot;&gt;
        &lt;h2 className=&quot;text-2xl font-bold text-neutral-800 dark:text-neutral-200&quot;&gt;Input Management&lt;/h2&gt;
        &lt;p className=&quot;text-neutral-500 dark:text-neutral-400 mt-1&quot;&gt;Customize the entities used for tracking and filtering throughout the app.&lt;/p&gt;
        &lt;div className=&quot;mt-4&quot;&gt;
          &lt;InputManagementSection /&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;div className=&quot;pt-6 border-t border-neutral-200 dark:border-neutral-800&quot;&gt;
        &lt;h2 className=&quot;text-2xl font-bold text-danger-700 dark:text-danger-500&quot;&gt;Danger Zone&lt;/h2&gt;
         &lt;div className=&quot;space-y-4 mt-4&quot;&gt;
            &lt;SettingCard title=&quot;Clear All Data&quot; description=&quot;Permanently delete all imported bets from the application. This cannot be undone.&quot;&gt;
                 &lt;button
                    onClick={handleClearData}
                    className=&quot;px-4 py-2 bg-danger-600 text-white font-semibold rounded-lg shadow-md hover:bg-danger-700 focus:outline-none focus:ring-2 focus:ring-danger-500 focus:ring-opacity-75&quot;
                &gt;
                    Clear All Bet Data
                &lt;/button&gt;
            &lt;/SettingCard&gt;
          &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
};

export default SettingsView;</file><file path="views/SportsbookBreakdownView.tsx">import React, { useMemo, useState } from &apos;react&apos;;
import { useBets } from &apos;../hooks/useBets&apos;;
import { BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer, LineChart, Line, Cell } from &apos;recharts&apos;;
import { TrendingUp, TrendingDown, Scale, BarChart2, ChevronDown } from &apos;../components/icons&apos;;

// --- HELPER COMPONENTS ---

const CustomTooltip = ({ active, payload, label }: any) =&gt; {
    if (active &amp;&amp; payload &amp;&amp; payload.length) {
        return (
            &lt;div className=&quot;bg-white dark:bg-neutral-800 p-2 border border-neutral-300 dark:border-neutral-600 rounded shadow-lg text-sm&quot;&gt;
                &lt;p className=&quot;label font-bold mb-1&quot;&gt;{`${label}`}&lt;/p&gt;
                {payload.map((pld: any, index: number) =&gt; (
                    &lt;p key={index} style={{ color: pld.color || pld.fill }}&gt;
                        {`${pld.name}: ${typeof pld.value === &apos;number&apos; ? pld.value.toFixed(2) : pld.value}`}
                    &lt;/p&gt;
                ))}
            &lt;/div&gt;
        );
    }
    return null;
};

const ChartContainer: React.FC&lt;{ title: string; children: React.ReactNode }&gt; = ({ title, children }) =&gt; (
    &lt;div className=&quot;bg-white dark:bg-neutral-900 rounded-lg shadow-md p-6&quot;&gt;
        &lt;h2 className=&quot;text-xl font-semibold mb-4 text-neutral-800 dark:text-neutral-200&quot;&gt;{title}&lt;/h2&gt;
        &lt;div className=&quot;h-72&quot;&gt;{children}&lt;/div&gt;
    &lt;/div&gt;
);

const StatCard: React.FC&lt;{ title: string; value: string; icon: React.ReactNode; change?: string; }&gt; = ({ title, value, icon, change }) =&gt; {
    const isPositive = change &amp;&amp; parseFloat(change) &gt; 0;
    const isNegative = change &amp;&amp; parseFloat(change) &lt; 0;
    const changeColor = isPositive ? &apos;text-accent-500&apos; : isNegative ? &apos;text-danger-500&apos; : &apos;text-neutral-500 dark:text-neutral-400&apos;;

    return (
        &lt;div className=&quot;bg-white dark:bg-neutral-900 p-6 rounded-lg shadow-md flex items-start justify-between&quot;&gt;
            &lt;div&gt;
                &lt;p className=&quot;text-sm font-medium text-neutral-500 dark:text-neutral-400 uppercase&quot;&gt;{title}&lt;/p&gt;
                &lt;p className=&quot;text-3xl font-bold text-neutral-900 dark:text-white mt-1&quot;&gt;{value}&lt;/p&gt;
                {change &amp;&amp; (
                    &lt;p className={`text-sm font-semibold flex items-center mt-2 ${changeColor}`}&gt;
                        {isPositive &amp;&amp; &lt;TrendingUp className=&quot;w-4 h-4 mr-1&quot; /&gt;}
                        {isNegative &amp;&amp; &lt;TrendingDown className=&quot;w-4 h-4 mr-1&quot; /&gt;}
                        {change}
                    &lt;/p&gt;
                )}
            &lt;/div&gt;
            &lt;div className=&quot;bg-primary-100 dark:bg-primary-900/50 text-primary-600 dark:text-primary-400 p-3 rounded-full&quot;&gt;
                {icon}
            &lt;/div&gt;
        &lt;/div&gt;
    );
};

type DateRange = &apos;all&apos; | &apos;1d&apos; | &apos;3d&apos; | &apos;1w&apos; | &apos;1m&apos; | &apos;1y&apos; | &apos;custom&apos;;

const DateRangeButton: React.FC&lt;{
  range: DateRange;
  label: string;
  currentRange: DateRange;
  onClick: (range: DateRange) =&gt; void;
}&gt; = ({ range, label, currentRange, onClick }) =&gt; (
  &lt;button
    onClick={() =&gt; onClick(range)}
    className={`px-3 py-1.5 rounded-md font-medium text-xs transition-colors ${
      currentRange === range
        ? &apos;bg-primary-600 text-white shadow&apos;
        : &apos;text-neutral-600 dark:text-neutral-300 hover:bg-white dark:hover:bg-neutral-700&apos;
    }`}
  &gt;
    {label}
  &lt;/button&gt;
);


// --- MAIN VIEW ---

const SportsbookBreakdownView: React.FC = () =&gt; {
    const { bets, loading } = useBets();
    // FIX: The selected book is a string (the sportsbook name) or &apos;all&apos;, not a Sportsbook object.
    const [selectedBook, setSelectedBook] = useState&lt;string | &apos;all&apos;&gt;(&apos;all&apos;);
    const [dateRange, setDateRange] = useState&lt;DateRange&gt;(&apos;all&apos;);
    const [customDateRange, setCustomDateRange] = useState&lt;{ start: string; end: string }&gt;({ start: &apos;&apos;, end: &apos;&apos; });


    const availableBooks = useMemo(() =&gt; {
        if (loading) return [];
        const books = new Set(bets.map(b =&gt; b.book));
        // FIX: The list of available books is an array of strings. The incorrect cast to `Sportsbook[]` is removed.
        return [&apos;all&apos;, ...Array.from(books).sort()];
    }, [bets, loading]);

    const filteredBets = useMemo(() =&gt; {
        let betsToFilter = bets;

        if (selectedBook !== &apos;all&apos;) {
            // FIX: This comparison is now valid (string === string) because selectedBook&apos;s type is corrected.
            betsToFilter = betsToFilter.filter(b =&gt; b.book === selectedBook);
        }
        
        if (dateRange === &apos;all&apos;) {
            return betsToFilter;
        }

        if (dateRange === &apos;custom&apos;) {
            const customStart = customDateRange.start ? new Date(`${customDateRange.start}T00:00:00.000Z`) : null;
            const customEnd = customDateRange.end ? new Date(`${customDateRange.end}T23:59:59.999Z`) : null;
            
            return betsToFilter.filter(bet =&gt; {
                const betDate = new Date(bet.placedAt);
                if (customStart &amp;&amp; betDate &lt; customStart) return false;
                if (customEnd &amp;&amp; betDate &gt; customEnd) return false;
                return true;
            });
        }

        let startDate: Date;
        const now = new Date();

        switch (dateRange) {
            case &apos;1d&apos;:
                startDate = new Date(now.getTime() - 24 * 60 * 60 * 1000);
                break;
            case &apos;3d&apos;:
                startDate = new Date(now.getTime() - 3 * 24 * 60 * 60 * 1000);
                break;
            case &apos;1w&apos;:
                startDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
                break;
            case &apos;1m&apos;:
                const oneMonthAgo = new Date();
                oneMonthAgo.setMonth(oneMonthAgo.getMonth() - 1);
                startDate = oneMonthAgo;
                break;
            case &apos;1y&apos;:
                const oneYearAgo = new Date();
                oneYearAgo.setFullYear(oneYearAgo.getFullYear() - 1);
                startDate = oneYearAgo;
                break;
            default:
                return betsToFilter;
        }
        
        return betsToFilter.filter(bet =&gt; new Date(bet.placedAt) &gt;= startDate);
    }, [bets, selectedBook, dateRange, customDateRange]);

    const processedData = useMemo(() =&gt; {
        if (filteredBets.length === 0) return null;

        const sortedBets = [...filteredBets].sort((a, b) =&gt; new Date(a.placedAt).getTime() - new Date(b.placedAt).getTime());

        let cumulativeProfit = 0;
        const profitOverTime = sortedBets.map(bet =&gt; {
            cumulativeProfit += (bet.payout - bet.stake);
            return { date: new Date(bet.placedAt).toLocaleDateString(&apos;en-CA&apos;), profit: cumulativeProfit };
        });

        const stats = {
            totalBets: filteredBets.length,
            totalWagered: 0,
            netProfit: 0,
            wins: 0,
            losses: 0,
            winRate: 0,
            roi: 0
        };
        const profitBySport = new Map&lt;string, number&gt;();

        for (const bet of filteredBets) {
            const net = bet.payout - bet.stake;
            stats.totalWagered += bet.stake;
            stats.netProfit += net;
            if (bet.result === &apos;win&apos;) stats.wins++;
            if (bet.result === &apos;loss&apos;) stats.losses++;

            profitBySport.set(bet.sport, (profitBySport.get(bet.sport) || 0) + net);
        }

        stats.roi = stats.totalWagered &gt; 0 ? (stats.netProfit / stats.totalWagered) * 100 : 0;
        stats.winRate = (stats.wins + stats.losses) &gt; 0 ? (stats.wins / (stats.wins + stats.losses)) * 100 : 0;
        
        const profitBySportData = Array.from(profitBySport.entries()).map(([name, profit]) =&gt; ({ name, profit })).sort((a,b) =&gt; b.profit - a.profit);

        return { stats, profitOverTime, profitBySportData };
    }, [filteredBets]);

    if (loading) return &lt;div className=&quot;p-6 text-center&quot;&gt;Loading breakdown...&lt;/div&gt;;
    if (bets.length === 0) return &lt;div className=&quot;p-6 text-center text-neutral-500&quot;&gt;No data to display. Please import some bets first.&lt;/div&gt;;
    
    const FAVORITE_BOOKS = [&apos;FanDuel&apos;, &apos;DraftKings&apos;];
    const mainBooks: string[] = [&apos;all&apos;];
    const dropdownBooks: string[] = [];

    const otherBooks: string[] = [];
    availableBooks.forEach(book =&gt; {
        if (book === &apos;all&apos;) return;
        if (FAVORITE_BOOKS.includes(book)) {
            mainBooks.push(book);
        } else {
            otherBooks.push(book);
        }
    });
    dropdownBooks.push(...otherBooks.sort());

    const isDropdownBookSelected = dropdownBooks.includes(selectedBook as string);

    return (
         &lt;div className=&quot;p-6 h-full flex flex-col space-y-6 bg-neutral-100 dark:bg-neutral-950 overflow-y-auto&quot;&gt;
            &lt;header&gt;
                &lt;h1 className=&quot;text-3xl font-bold text-neutral-900 dark:text-white&quot;&gt;By Sportsbook&lt;/h1&gt;
                &lt;p className=&quot;text-neutral-500 dark:text-neutral-400 mt-1&quot;&gt;A detailed performance analysis for each sportsbook.&lt;/p&gt;
            &lt;/header&gt;
            
            &lt;div className=&quot;bg-white dark:bg-neutral-900 rounded-lg shadow-md p-6 space-y-4&quot;&gt;
                &lt;div className=&quot;flex flex-col sm:flex-row sm:justify-between sm:items-center gap-4&quot;&gt;
                    &lt;div className=&quot;flex items-center space-x-1 flex-wrap gap-y-2 bg-neutral-100 dark:bg-neutral-800/50 p-1 rounded-lg&quot;&gt;
                        {mainBooks.map(book =&gt; (
                            &lt;button
                                key={book}
                                onClick={() =&gt; setSelectedBook(book)}
                                className={`px-3 py-1.5 rounded-md font-medium text-xs transition-colors ${
                                selectedBook === book
                                    ? &apos;bg-primary-600 text-white shadow&apos;
                                    : &apos;text-neutral-700 dark:text-neutral-300 bg-neutral-200 dark:bg-neutral-800 hover:bg-neutral-300 dark:hover:bg-neutral-700&apos;
                                }`}
                            &gt;
                                {book === &apos;all&apos; ? &apos;All Books&apos; : book}
                            &lt;/button&gt;
                        ))}
                        {dropdownBooks.length &gt; 0 &amp;&amp; (
                            &lt;div className=&quot;relative&quot;&gt;
                                &lt;select
                                    value={isDropdownBookSelected ? selectedBook : &apos;more&apos;}
                                    onChange={(e) =&gt; {
                                        const value = e.target.value;
                                        if (value !== &apos;more&apos;) {
                                            setSelectedBook(value);
                                        }
                                    }}
                                    className={`w-full px-3 py-1.5 rounded-md font-medium text-xs transition-colors appearance-none pr-8 text-left ${
                                        isDropdownBookSelected
                                        ? &apos;bg-primary-600 text-white shadow&apos;
                                        : &apos;text-neutral-700 dark:text-neutral-300 bg-neutral-200 dark:bg-neutral-800 hover:bg-neutral-300 dark:hover:bg-neutral-700&apos;
                                    }`}
                                &gt;
                                    &lt;option value=&quot;more&quot; disabled&gt;More...&lt;/option&gt;
                                    {dropdownBooks.map(book =&gt; (
                                        &lt;option key={book} value={book}&gt;{book}&lt;/option&gt;
                                    ))}
                                &lt;/select&gt;
                                &lt;ChevronDown 
                                    className={`w-4 h-4 absolute right-2 top-1/2 -translate-y-1/2 pointer-events-none ${isDropdownBookSelected ? &apos;text-white&apos; : &apos;text-neutral-500&apos;}`} 
                                /&gt;
                            &lt;/div&gt;
                        )}
                    &lt;/div&gt;
                    &lt;div className=&quot;flex items-center space-x-1 flex-wrap gap-y-2 bg-neutral-100 dark:bg-neutral-800/50 p-1 rounded-lg&quot;&gt;
                        &lt;DateRangeButton range=&quot;all&quot; label=&quot;All Time&quot; currentRange={dateRange} onClick={setDateRange} /&gt;
                        &lt;DateRangeButton range=&quot;1d&quot; label=&quot;1D&quot; currentRange={dateRange} onClick={setDateRange} /&gt;
                        &lt;DateRangeButton range=&quot;3d&quot; label=&quot;3D&quot; currentRange={dateRange} onClick={setDateRange} /&gt;
                        &lt;DateRangeButton range=&quot;1w&quot; label=&quot;1W&quot; currentRange={dateRange} onClick={setDateRange} /&gt;
                        &lt;DateRangeButton range=&quot;1m&quot; label=&quot;1M&quot; currentRange={dateRange} onClick={setDateRange} /&gt;
                        &lt;DateRangeButton range=&quot;1y&quot; label=&quot;1Y&quot; currentRange={dateRange} onClick={setDateRange} /&gt;
                        &lt;DateRangeButton range=&quot;custom&quot; label=&quot;Custom&quot; currentRange={dateRange} onClick={setDateRange} /&gt;
                    &lt;/div&gt;
                &lt;/div&gt;

                {dateRange === &apos;custom&apos; &amp;&amp; (
                    &lt;div className=&quot;flex sm:justify-end items-center space-x-4&quot;&gt;
                        &lt;div className=&quot;flex items-center space-x-2&quot;&gt;
                            &lt;label htmlFor=&quot;start-date&quot; className=&quot;text-sm font-medium text-neutral-500 dark:text-neutral-400&quot;&gt;From&lt;/label&gt;
                            &lt;input
                                type=&quot;date&quot;
                                id=&quot;start-date&quot;
                                value={customDateRange.start}
                                onChange={e =&gt; setCustomDateRange(prev =&gt; ({ ...prev, start: e.target.value }))}
                                className=&quot;bg-neutral-50 dark:bg-neutral-800 border border-neutral-300 dark:border-neutral-600 text-neutral-900 dark:text-white text-sm rounded-lg focus:ring-primary-500 focus:border-primary-500 block w-full p-2&quot;
                            /&gt;
                        &lt;/div&gt;
                        &lt;div className=&quot;flex items-center space-x-2&quot;&gt;
                            &lt;label htmlFor=&quot;end-date&quot; className=&quot;text-sm font-medium text-neutral-500 dark:text-neutral-400&quot;&gt;To&lt;/label&gt;
                            &lt;input
                                type=&quot;date&quot;
                                id=&quot;end-date&quot;
                                value={customDateRange.end}
                                onChange={e =&gt; setCustomDateRange(prev =&gt; ({ ...prev, end: e.target.value }))}
                                className=&quot;bg-neutral-50 dark:bg-neutral-800 border border-neutral-300 dark:border-neutral-600 text-neutral-900 dark:text-white text-sm rounded-lg focus:ring-primary-500 focus:border-primary-500 block w-full p-2&quot;
                            /&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                )}
            
                {processedData ? (
                    &lt;div className=&quot;space-y-6 pt-4&quot;&gt;
                        &lt;div className=&quot;grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6&quot;&gt;
                            &lt;StatCard title=&quot;Net Profit&quot; value={`${processedData.stats.netProfit &gt;= 0 ? &apos;$&apos; : &apos;-$&apos;}${Math.abs(processedData.stats.netProfit).toFixed(2)}`} icon={&lt;Scale className=&quot;w-6 h-6&quot;/&gt;} change={`${processedData.stats.roi.toFixed(1)}% ROI`}/&gt;
                            &lt;StatCard title=&quot;Total Wagered&quot; value={`$${processedData.stats.totalWagered.toFixed(2)}`} icon={&lt;BarChart2 className=&quot;w-6 h-6&quot;/&gt;} /&gt;
                            &lt;StatCard title=&quot;Total Bets&quot; value={processedData.stats.totalBets.toString()} icon={&lt;BarChart2 className=&quot;w-6 h-6&quot;/&gt;} /&gt;
                            &lt;StatCard title=&quot;Win Rate&quot; value={`${processedData.stats.winRate.toFixed(1)}%`} icon={&lt;BarChart2 className=&quot;w-6 h-6&quot;/&gt;} change={`${processedData.stats.wins}-${processedData.stats.losses}`} /&gt;
                        &lt;/div&gt;

                        &lt;div className=&quot;grid grid-cols-1 lg:grid-cols-2 gap-6&quot;&gt;
                            &lt;ChartContainer title=&quot;Profit Over Time&quot;&gt;
                                &lt;ResponsiveContainer width=&quot;100%&quot; height=&quot;100%&quot;&gt;
                                    &lt;LineChart data={processedData.profitOverTime}&gt;
                                        &lt;CartesianGrid strokeDasharray=&quot;3 3&quot; stroke=&quot;rgba(128, 128, 128, 0.2)&quot; /&gt;
                                        &lt;XAxis dataKey=&quot;date&quot; stroke=&quot;rgb(113, 113, 122)&quot; tick={{ fontSize: 12 }} /&gt;
                                        &lt;YAxis stroke=&quot;rgb(113, 113, 122)&quot; tick={{ fontSize: 12 }} tickFormatter={(value) =&gt; `$${value}`}/&gt;
                                        &lt;Tooltip content={&lt;CustomTooltip /&gt;} /&gt;
                                        &lt;Line type=&quot;monotone&quot; dataKey=&quot;profit&quot; name=&quot;Profit&quot; stroke=&quot;#8b5cf6&quot; strokeWidth={2} dot={false} /&gt;
                                    &lt;/LineChart&gt;
                                &lt;/ResponsiveContainer&gt;
                            &lt;/ChartContainer&gt;
                            
                            &lt;ChartContainer title=&quot;Net Profit by Sport&quot;&gt;
                                &lt;ResponsiveContainer width=&quot;100%&quot; height=&quot;100%&quot;&gt;
                                    &lt;BarChart data={processedData.profitBySportData} layout=&quot;vertical&quot; margin={{ top: 5, right: 30, left: 20, bottom: 5 }}&gt;
                                        &lt;CartesianGrid strokeDasharray=&quot;3 3&quot; stroke=&quot;rgba(128, 128, 128, 0.2)&quot; /&gt;
                                        &lt;XAxis type=&quot;number&quot; stroke=&quot;rgb(113, 113, 122)&quot; tick={{ fontSize: 12 }} tickFormatter={(value) =&gt; `$${value}`}/&gt;
                                        &lt;YAxis type=&quot;category&quot; dataKey=&quot;name&quot; stroke=&quot;rgb(113, 113, 122)&quot; tick={{ fontSize: 12 }} width={80} /&gt;
                                        &lt;Tooltip content={&lt;CustomTooltip /&gt;} /&gt;
                                        &lt;Bar dataKey=&quot;profit&quot; name=&quot;Profit&quot;&gt;
                                            {processedData.profitBySportData.map((entry, index) =&gt; (
                                                &lt;Cell key={`cell-${index}`} fill={entry.profit &gt;= 0 ? &apos;#22c55e&apos; : &apos;#ef4444&apos;} /&gt;
                                            ))}
                                        &lt;/Bar&gt;
                                    &lt;/BarChart&gt;
                                &lt;/ResponsiveContainer&gt;
                            &lt;/ChartContainer&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                ) : (
                    &lt;div className=&quot;flex-grow flex items-center justify-center&quot;&gt;
                        &lt;div className=&quot;text-center text-neutral-500 dark:text-neutral-400 p-8&quot;&gt;
                            &lt;BarChart2 className=&quot;w-16 h-16 mx-auto text-neutral-400 dark:text-neutral-600&quot; /&gt;
                            &lt;h3 className=&quot;mt-4 text-xl font-semibold&quot;&gt;No Data Found&lt;/h3&gt;
                            &lt;p className=&quot;mt-1&quot;&gt;No betting data found for the selected sportsbook and date range.&lt;/p&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                )}
            &lt;/div&gt;
        &lt;/div&gt;
    );
};

export default SportsbookBreakdownView;</file><file path=".env.local">GEMINI_API_KEY=PLACEHOLDER_API_KEY</file><file path=".gitignore"># Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?</file><file path="App.tsx">import React, { useState, useEffect } from &apos;react&apos;;
import { BetsProvider } from &apos;./hooks/useBets&apos;;
import { InputsProvider } from &apos;./hooks/useInputs&apos;;
import ImportView from &apos;./views/ImportView&apos;;
import BetTableView from &apos;./views/BetTableView&apos;;
import DashboardView from &apos;./views/DashboardView&apos;;
import SettingsView from &apos;./views/SettingsView&apos;;
import SportsbookBreakdownView from &apos;./views/SportsbookBreakdownView&apos;;
import BySportView from &apos;./views/BySportView&apos;;
import PlayerProfileView from &apos;./views/PlayerProfileView&apos;;
import { DownloadCloud, BarChart2, Settings, Table, Sun, Moon, Scale, User, Trophy } from &apos;./components/icons&apos;;

type Tab = &apos;import&apos; | &apos;table&apos; | &apos;dashboard&apos; | &apos;bySport&apos; | &apos;sportsbooks&apos; | &apos;player&apos; | &apos;settings&apos;;

const App: React.FC = () =&gt; {
  const [activeTab, setActiveTab] = useState&lt;Tab&gt;(&apos;import&apos;);
  const [selectedPlayer, setSelectedPlayer] = useState&lt;string | null&gt;(null);
  const [theme, setTheme] = useState&lt;&apos;light&apos; | &apos;dark&apos;&gt;(() =&gt; {
    const savedTheme = localStorage.getItem(&apos;bettracker-theme&apos;);
    if (savedTheme === &apos;dark&apos; || savedTheme === &apos;light&apos;) {
        return savedTheme;
    }
    // Default to dark theme
    return &apos;dark&apos;;
  });

  useEffect(() =&gt; {
    if (theme === &apos;dark&apos;) {
      document.documentElement.classList.add(&apos;dark&apos;);
    } else {
      document.documentElement.classList.remove(&apos;dark&apos;);
    }
    localStorage.setItem(&apos;bettracker-theme&apos;, theme);
  }, [theme]);

  const toggleTheme = () =&gt; {
    setTheme(prevTheme =&gt; (prevTheme === &apos;light&apos; ? &apos;dark&apos; : &apos;light&apos;));
  };

  const renderTab = () =&gt; {
    switch (activeTab) {
      case &apos;import&apos;:
        return &lt;ImportView /&gt;;
      case &apos;table&apos;:
        return &lt;BetTableView /&gt;;
      case &apos;dashboard&apos;:
        return &lt;DashboardView /&gt;;
      case &apos;bySport&apos;:
        return &lt;BySportView /&gt;;
      case &apos;sportsbooks&apos;:
        return &lt;SportsbookBreakdownView /&gt;;
      case &apos;player&apos;:
        return &lt;PlayerProfileView selectedPlayer={selectedPlayer} setSelectedPlayer={setSelectedPlayer} /&gt;;
      case &apos;settings&apos;:
        return &lt;SettingsView theme={theme} toggleTheme={toggleTheme} /&gt;;
      default:
        return &lt;ImportView /&gt;;
    }
  };

  const NavItem: React.FC&lt;{ tab: Tab; icon: React.ReactNode; label: string }&gt; = ({ tab, icon, label }) =&gt; (
    &lt;button
      onClick={() =&gt; setActiveTab(tab)}
      className={`flex items-center space-x-3 px-4 py-3 rounded-lg w-full text-left transition-colors duration-200 ${
        activeTab === tab
          ? &apos;bg-primary-600 text-white shadow-lg&apos;
          : &apos;text-neutral-500 dark:text-neutral-400 hover:bg-neutral-200 dark:hover:bg-neutral-800/50&apos;
      }`}
    &gt;
      {icon}
      &lt;span className=&quot;font-medium&quot;&gt;{label}&lt;/span&gt;
    &lt;/button&gt;
  );

  return (
    &lt;InputsProvider&gt;
      &lt;BetsProvider&gt;
        &lt;div className=&quot;flex h-screen bg-neutral-100 dark:bg-neutral-950 font-sans&quot;&gt;
          &lt;aside className=&quot;w-64 flex-shrink-0 bg-white dark:bg-neutral-900 border-r border-neutral-200 dark:border-neutral-800 flex flex-col p-4&quot;&gt;
            &lt;div className=&quot;flex items-center space-x-2 px-4 pb-4 border-b border-neutral-200 dark:border-neutral-800&quot;&gt;
              &lt;BarChart2 className=&quot;w-8 h-8 text-primary-500&quot; /&gt;
              &lt;h1 className=&quot;text-2xl font-bold text-neutral-900 dark:text-white&quot;&gt;BetTracker&lt;/h1&gt;
            &lt;/div&gt;
            &lt;nav className=&quot;mt-6 flex-grow space-y-2&quot;&gt;
              &lt;NavItem tab=&quot;import&quot; icon={&lt;DownloadCloud className=&quot;w-6 h-6&quot; /&gt;} label=&quot;Import Bets&quot; /&gt;
              &lt;NavItem tab=&quot;table&quot; icon={&lt;Table className=&quot;w-6 h-6&quot; /&gt;} label=&quot;Bet Table&quot; /&gt;
              &lt;NavItem tab=&quot;dashboard&quot; icon={&lt;BarChart2 className=&quot;w-6 h-6&quot; /&gt;} label=&quot;Dashboard&quot; /&gt;
              &lt;NavItem tab=&quot;bySport&quot; icon={&lt;Trophy className=&quot;w-6 h-6&quot; /&gt;} label=&quot;By Sport&quot; /&gt;
              &lt;NavItem tab=&quot;sportsbooks&quot; icon={&lt;Scale className=&quot;w-6 h-6&quot; /&gt;} label=&quot;By Sportsbook&quot; /&gt;
              &lt;NavItem tab=&quot;player&quot; icon={&lt;User className=&quot;w-6 h-6&quot; /&gt;} label=&quot;Player Profiles&quot; /&gt;
              &lt;NavItem tab=&quot;settings&quot; icon={&lt;Settings className=&quot;w-6 h-6&quot; /&gt;} label=&quot;Settings&quot; /&gt;
            &lt;/nav&gt;
            &lt;div className=&quot;mt-auto p-4&quot;&gt;
               &lt;button
                onClick={toggleTheme}
                className=&quot;w-full flex items-center justify-center space-x-2 p-2 rounded-lg bg-neutral-200 dark:bg-neutral-800 text-neutral-600 dark:text-neutral-300 hover:bg-neutral-300 dark:hover:bg-neutral-700 transition-colors&quot;
              &gt;
                {theme === &apos;light&apos; ? &lt;Moon className=&quot;w-5 h-5&quot; /&gt; : &lt;Sun className=&quot;w-5 h-5&quot; /&gt;}
                &lt;span&gt;{theme === &apos;light&apos; ? &apos;Dark Mode&apos; : &apos;Light Mode&apos;}&lt;/span&gt;
              &lt;/button&gt;
            &lt;/div&gt;
          &lt;/aside&gt;
          &lt;main className=&quot;flex-1 overflow-y-auto&quot;&gt;
            {renderTab()}
          &lt;/main&gt;
        &lt;/div&gt;
      &lt;/BetsProvider&gt;
    &lt;/InputsProvider&gt;
  );
};

export default App;</file><file path="constants.ts">export const MARKET_CATEGORIES: string[] = [&apos;Props&apos;, &apos;Main Markets&apos;, &apos;Futures&apos;, &apos;SGP/SGP+&apos;, &apos;Parlays&apos;, &apos;Other&apos;];</file><file path="index.html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;link rel=&quot;icon&quot; type=&quot;image/svg+xml&quot; href=&quot;/vite.svg&quot; /&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
    &lt;title&gt;BetTracker&lt;/title&gt;
    &lt;script src=&quot;https://cdn.tailwindcss.com&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
      tailwind.config = {
        darkMode: &apos;class&apos;,
        theme: {
          extend: {
            colors: {
              neutral: {
                50: &apos;#fafafa&apos;,
                100: &apos;#f5f5f5&apos;,
                200: &apos;#e5e5e5&apos;,
                300: &apos;#d4d4d4&apos;,
                400: &apos;#a3a3a3&apos;,
                500: &apos;#737373&apos;,
                600: &apos;#525252&apos;,
                700: &apos;#404040&apos;,
                800: &apos;#262626&apos;,
                900: &apos;#171717&apos;,
                950: &apos;#0a0a0a&apos;,
              },
              primary: {
                50: &apos;#f5f3ff&apos;,
                100: &apos;#ede9fe&apos;,
                200: &apos;#ddd6fe&apos;,
                300: &apos;#c4b5fd&apos;,
                400: &apos;#a78bfa&apos;,
                500: &apos;#8b5cf6&apos;,
                600: &apos;#7c3aed&apos;,
                700: &apos;#6d28d9&apos;,
                800: &apos;#5b21b6&apos;,
                900: &apos;#4c1d95&apos;,
                950: &apos;#2e1065&apos;,
              },
              accent: {
                50: &apos;#f0fdf4&apos;,
                100: &apos;#dcfce7&apos;,
                200: &apos;#bbf7d0&apos;,
                300: &apos;#86efac&apos;,
                400: &apos;#4ade80&apos;,
                500: &apos;#22c55e&apos;,
                600: &apos;#16a34a&apos;,
                700: &apos;#15803d&apos;,
                800: &apos;#166534&apos;,
                900: &apos;#14532d&apos;,
                950: &apos;#052e16&apos;,
              },
              danger: {
                50: &apos;#fef2f2&apos;,
                100: &apos;#fee2e2&apos;,
                200: &apos;#fecaca&apos;,
                300: &apos;#fca5a5&apos;,
                400: &apos;#f87171&apos;,
                500: &apos;#ef4444&apos;,
                600: &apos;#dc2626&apos;,
                700: &apos;#b91c1c&apos;,
                800: &apos;#991b1b&apos;,
                900: &apos;#7f1d1d&apos;,
                950: &apos;#450a0a&apos;,
              }
            }
          }
        }
      }
    &lt;/script&gt;
  &lt;script type=&quot;importmap&quot;&gt;
{
  &quot;imports&quot;: {
    &quot;react&quot;: &quot;https://aistudiocdn.com/react@^19.2.0&quot;,
    &quot;react-dom/&quot;: &quot;https://aistudiocdn.com/react-dom@^19.2.0/&quot;,
    &quot;react/&quot;: &quot;https://aistudiocdn.com/react@^19.2.0/&quot;,
    &quot;recharts&quot;: &quot;https://aistudiocdn.com/recharts@^3.4.1&quot;
  }
}
&lt;/script&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;/index.css&quot;&gt;
&lt;/head&gt;
  &lt;body class=&quot;bg-neutral-100 dark:bg-neutral-950 text-neutral-900 dark:text-neutral-100&quot;&gt;
    &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;
    &lt;script type=&quot;module&quot; src=&quot;/index.tsx&quot;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</file><file path="index.tsx">import React from &apos;react&apos;;
import ReactDOM from &apos;react-dom/client&apos;;
import App from &apos;./App&apos;;

const rootElement = document.getElementById(&apos;root&apos;);
if (!rootElement) {
  throw new Error(&quot;Could not find root element to mount to&quot;);
}

const root = ReactDOM.createRoot(rootElement);
root.render(
  &lt;React.StrictMode&gt;
    &lt;App /&gt;
  &lt;/React.StrictMode&gt;
);</file><file path="metadata.json">{
  &quot;name&quot;: &quot;Copy of BetTracker&quot;,
  &quot;description&quot;: &quot;A local-only desktop application to import, track, and analyze sports bets from various sportsbooks. All data is stored locally on your machine.&quot;,
  &quot;requestFramePermissions&quot;: []
}</file><file path="package.json">{
  &quot;name&quot;: &quot;copy-of-bettracker&quot;,
  &quot;private&quot;: true,
  &quot;version&quot;: &quot;0.0.0&quot;,
  &quot;type&quot;: &quot;module&quot;,
  &quot;scripts&quot;: {
    &quot;dev&quot;: &quot;vite&quot;,
    &quot;build&quot;: &quot;vite build&quot;,
    &quot;preview&quot;: &quot;vite preview&quot;
  },
  &quot;dependencies&quot;: {
    &quot;react&quot;: &quot;^19.2.0&quot;,
    &quot;react-dom&quot;: &quot;^19.2.0&quot;,
    &quot;recharts&quot;: &quot;^3.4.1&quot;
  },
  &quot;devDependencies&quot;: {
    &quot;@types/node&quot;: &quot;^22.14.0&quot;,
    &quot;@vitejs/plugin-react&quot;: &quot;^5.0.0&quot;,
    &quot;typescript&quot;: &quot;~5.8.2&quot;,
    &quot;vite&quot;: &quot;^6.2.0&quot;
  }
}</file><file path="README.md">&lt;div align=&quot;center&quot;&gt;
&lt;img width=&quot;1200&quot; height=&quot;475&quot; alt=&quot;GHBanner&quot; src=&quot;https://github.com/user-attachments/assets/0aa67016-6eaf-458a-adb2-6e31a0763ed6&quot; /&gt;
&lt;/div&gt;

# Run and deploy your AI Studio app

This contains everything you need to run your app locally.

View your app in AI Studio: https://ai.studio/apps/drive/11os0u2vJGgezQeyxDfX31mtnYZfTnl_y

## Run Locally

**Prerequisites:**  Node.js


1. Install dependencies:
   `npm install`
2. Set the `GEMINI_API_KEY` in [.env.local](.env.local) to your Gemini API key
3. Run the app:
   `npm run dev`</file><file path="tsconfig.json">{
  &quot;compilerOptions&quot;: {
    &quot;target&quot;: &quot;ES2022&quot;,
    &quot;experimentalDecorators&quot;: true,
    &quot;useDefineForClassFields&quot;: false,
    &quot;module&quot;: &quot;ESNext&quot;,
    &quot;lib&quot;: [
      &quot;ES2022&quot;,
      &quot;DOM&quot;,
      &quot;DOM.Iterable&quot;
    ],
    &quot;skipLibCheck&quot;: true,
    &quot;types&quot;: [
      &quot;node&quot;
    ],
    &quot;moduleResolution&quot;: &quot;bundler&quot;,
    &quot;isolatedModules&quot;: true,
    &quot;moduleDetection&quot;: &quot;force&quot;,
    &quot;allowJs&quot;: true,
    &quot;jsx&quot;: &quot;react-jsx&quot;,
    &quot;paths&quot;: {
      &quot;@/*&quot;: [
        &quot;./*&quot;
      ]
    },
    &quot;allowImportingTsExtensions&quot;: true,
    &quot;noEmit&quot;: true
  }
}</file><file path="types.ts">export type BetResult = &apos;win&apos; | &apos;loss&apos; | &apos;push&apos; | &apos;pending&apos;;
export type BetType = &apos;single&apos; | &apos;parlay&apos; | &apos;sgp&apos; | &apos;live&apos; | &apos;other&apos;;
export type SportsbookName = string;
export type MarketCategory = string;

export interface Sportsbook {
  name: SportsbookName;
  abbreviation: string;
  url: string;
}

export interface BetLeg {
  entities?: string[];
  market: string;
  target?: number | string;
  ou?: &apos;Over&apos; | &apos;Under&apos;;
  odds?: number;
  actual?: number | string;
  result: BetResult;
}

export interface Bet {
  id: string; // Unique identifier, could be betId + placedAt
  book: SportsbookName;
  betId: string;
  placedAt: string; // ISO timestamp
  settledAt?: string; // ISO timestamp
  betType: BetType;
  marketCategory: MarketCategory;
  sport: string;
  description: string;
  odds: number;
  stake: number;
  payout: number;
  result: BetResult;
  legs?: BetLeg[];
  tail?: string; // Who the bet was tailed from
  raw?: string; // Full raw text block for this bet
}</file><file path="vite.config.ts">import path from &apos;path&apos;;
import { defineConfig, loadEnv } from &apos;vite&apos;;
import react from &apos;@vitejs/plugin-react&apos;;

export default defineConfig(({ mode }) =&gt; {
    const env = loadEnv(mode, &apos;.&apos;, &apos;&apos;);
    return {
      server: {
        port: 3000,
        host: &apos;0.0.0.0&apos;,
      },
      plugins: [react()],
      define: {
        &apos;process.env.API_KEY&apos;: JSON.stringify(env.GEMINI_API_KEY),
        &apos;process.env.GEMINI_API_KEY&apos;: JSON.stringify(env.GEMINI_API_KEY)
      },
      resolve: {
        alias: {
          &apos;@&apos;: path.resolve(__dirname, &apos;.&apos;),
        }
      }
    };
});</file></files></repomix>